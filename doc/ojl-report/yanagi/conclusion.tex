\chapter{おわりに}
\section{まとめ}
本OJLでは，トレースログ可視化ツールであるTLVの開発を継続して行ない，
TLVに対して機能追加とリファクタリングを行なった．

TLVを開発された背景として，組込みシステムにおいてもマルチコアプロセッサ
の利用が進んでおり，それに伴い従来のデバッグ方法が有効でなくなってきた
ことを述べた．これは，マルチコアプロセッサが各コアで並列処理を行うため，
プログラムの挙動が非決定的になり，バグの再現が保証されず，従来のブレー
クポイントによるステップ実行ではバグを確実に捕らえることができないから
である．

一方，マルチコアプロセッサ環境におけるデバッグで有効な方法として，実行
中にデバッグを行うのではなく，実行後にトレースログを解析する手法がある
．そして，開発者が直接トレースログを扱うのは効率が悪く，ト
レースログの解析を支援するツールが要求されており，その1つとして可視化表
示ツールがある．

既存のトレースログ可視化ツールは，標準化されたトレースログを扱っていな
いため，利用できるトレースログの形式が限られており，汎用性に乏しい．
また，可視化表示項目が提供されているものに限られ，変更や追加
を行う仕組みも提供されておらず，拡張性に乏しい．

そこで後藤ら\cite{goto,ipsj}によって，汎用性と拡張性を備えたトレースロ
グ可視化ツールTLVが開発された．TLV内部でトレースログを抽象的に扱えるよ
う，トレースログを一般化した標準形式トレースログを定め，任意の形式のト
レースログを標準形式トレースログに変換する仕組みを変換ルールとして形式
化した．トレースログの可視化表現を指示する仕組みを抽象化し，可視化ルー
ルとして形式化した．TLVでは，変換ルールと可視化ルールを外部ファイルとし
て与えることで，汎用性と拡張性を実現している．

本OJLでは，TLVのリリースを複数回行ない，要求の収集を行なった．
収集した要求のうち``CPUごとのタスク表示''に対する要求が強かったため，
これらの実現を行なった．
また，ユーザアプリケーションのログ出力を可視化するための機能追加を行った．
特定のフォーマットに従ったログ出力を受理し，文字列やユーザ定義状態として
可視化することで，ユーザアプリケーションの様々な出力を可視化できるように
なった．
特に，文字列の可視化は汎用性が高く，システムのメッセージや変数値の変化など
様々な出力が可能である．

また，TLVの高速化に対する要求も多かったので，第一段階として
プロファイリングによりボトルネックを調査した．
今回は標準形式トレースログへの変換部分を対象とし，
どのクラスや処理に時間がかかるかを明らかにした．


\section{今後の課題}
\subsection*{変換・可視化の高速化}
TLVの変換・可視化の高速化を行なう必要がある．

第\ref{profiling}章で述べたプロファイリング結果を参考に，
同時期に行われたリファクタリング案に従って
TLVを抜本的に更新する必要がある．

\subsection*{不安定な動作の修正}
現在，TLVが実行中にエラーを出力して動作を中断するバグレポートが
しばしば送られている．
ソフトウェアが広く利用され，開発に貢献するためには，
機能が優れているだけでなく，道具として信頼できる必要がある．
そのため，不安定な動作をする箇所を洗い出し，それらに対処する必要がある．

