\documentclass[a4j]{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{listings}
\usepackage{here}
\newcommand{\figref}[1]{図\ref{#1}}

\lstset{language=C,%
        basicstyle=\footnotesize,%
        commentstyle=\textit,%
        classoffset=1,%
        keywordstyle=\bfseries,%
	frame=tRBl,framesep=5pt,%
	showstringspaces=false,%
        numbers=left,stepnumber=1,numberstyle=\footnotesize%
	}%


\title{組込みRTOS向けアプリケーション開発支援ツール\\
TLV（トレース ログ ヴィジュアライザー）\\
フェーズ5 リファクタリング仕様書}
\begin{document}
\maketitle
\titlepage

\section*{改訂履歴}
\begin{table}[h]
 \centering
 \begin{tabular}{|c|c|c|c|} \hline
  版番& 日付&    更新内容& 更新者\\ \hline\hline
  1.0 & 10/4/23& 新規作成& 市原大輔\\ \hline
  1.1 & 10/5/11& \shortstack{リファクタリング後の例変更。説明の具体化・明確化。\\
  クラス図の変更・追加。リファクタリング報告書追加。}& 市原大輔\\ \hline
 \end{tabular}
\end{table}
\clearpage

\tableofcontents
\clearpage

\section{はじめに}
\subsection{本書の目的}
本書の目的は、文部科学省先導的ITスペシャリスト育成推進プログラム「OJLに
  よる最先端技術適応能力を持つIT人材育成拠点の形成」プロジェクトにおけ
る、OJL科目ソフトウェア工学実践研究の研究テーマである「組込みRTOS向けア
  プリケーション開発支援ツールの開発」に対して、その開発するソフトウェ
アに対する設計を記述することである。

本書は特に、フェーズ5におけるリファクタリング作業に関する記述を行う。

\subsection{本書の適用範囲}
本書は、組込みMPRTOS向けアプリケーション開発支援ツールの開発プロジェク
ト（以下本プロジェクト）のフェーズ5におけるリファクタリング作業に関する
記述を行う。

\subsection{用語の定義/略語の説明}

\begin{table}[h]
 \centering
 \caption{用語定義}
 \begin{tabular}{|p{8em}|p{36em}|} \hline
  用語・略語& 定義・説明\\ \hline \hline
  TLV& Trace Log Visualizer\\ \hline
  MPRTOS& マルチプロセッサ対応リアルタイムオペレーティングシステム\\
  \hline
  トレースログファイル&
      RTOSのトレースログ機能を用いて出力したトレースログや、
      シミュレータなどが出力するトレースログをファイルにしたもの\\
  \hline
  標準形式トレースログファイル&
      本ソフトウェアが扱うことの出来る形式をもつトレースログファイル。
      各種トレースログファイルは、この共通形式トレースログファイルに
      変換することにより本ソフトウェアで扱うことが出来るようになる。 \\
  \hline
  変換ルール  &
  トレースログファイルを標準形式トレースログファイルに変換する際に用いられるルール。
  \\
  \hline
  可視化ルール  &
  標準形式トレースログファイルを可視化する際に用いられるルール。
  \\
  \hline
  TLVファイル &
      本ソフトウェアが中間形式として用いるファイル。
      前述の標準形式トレースログファイルは、このTLVファイルの一部である。 \\
  \hline
  \\
  \hline
  EBNF &
      Extended Backus?Naur Formの略。 \\
  \hline

 \end{tabular}
\end{table}

\subsection{概要}
本書では、組込みMPRTOS向けアプリケーション開発支援ツールの
ソフトウェアの仕様を記述する。
本書は特に、フェーズ5におけるリファクタリング作業に関する記述を行う。

\part{リファクタリング概要}
\section{実施理由}
現状の\verb!TraceLog!クラス(クラス概要は\ref{sec:tl}参照)では、標準形式トレースログのパースにおいて、
Listing\ref{rex}のような複雑な正規表現を計8回適用している。これは、Objectなどの要素1つにつき1行の正規表現で
取得するためである。こうすることで、TimeやValue等の有無に関わらず
\footnote{可視化ルールファイルには、Timeがない、Valueがない、AttributeNameがない等といった
不完全な標準形式トレースログが記述されている。}
パースできるようにしている。
しかし、このような複雑な正規表現は、可読性が低く保守が難しいため、リファクタリングを実施する。

リファクタリング後のTLVは、標準形式トレースログのパースを専用のパーサに任せる。
パーサは、TLV変換ルール・可視化ルールマニュアル(rule-maual.pdf)の「2.1.2標準形式トレースログの定義」
にあるEBNFのようにコードを記述することで、構文を直感的に理解できるようになる。
コード例をListing\ref{refacted}に示す。

また、重複したコードおよび生成規則変更時の変更箇所も減らすことができるため、保守性も向上する。
例えば、Timeを囲む記号\verb!"[","]"!を\verb!"<",">"!にするとき、従来の正規表現を用いた
方法では、8行すべての正規表現を変更する必要があるが、リファクタリング後は1箇所で済むようになる。
生成規則を追加する場合でも、従来の方法では8行の正規表現の中から変更箇所を探さねばならないが、
リファクタリング後は、EBNFのように記述されているため、変更箇所が明確であるので見落としを減らせる。
しかしながら、このような構文の変更は稀であるため、一番のメリットは構文を直感的に理解できるようになる
ことである。

\begin{lstlisting}[caption=リファクタリング前のコード例,label=rex]
m = Regex.Match(_log, @"^(\[[^\]]+\])?(?<objectType>[^\[\]\(\)\.]+)\([^\)]+\)(\.[^\s]+)?$");
	if (m.Success)
		ObjectType = m.Groups["objectType"].Value;
	HasObjectType = m.Success;
\end{lstlisting}

\begin{lstlisting}[caption=リファクタリング後に表現したいコード例,label=refacted]
var object_ = 
	ObjectTypeName().Char('(').AttributeCondition().Char(')')
	.OR().
	ObjectName();
\end{lstlisting}



\section{対象}\label{sec:tl}
リファクタリング対象は、\verb!TraceLog!クラス、特にそのコンストラクタである。
この\verb!TraceLog!クラスは、標準形式トレースログを構成するトークンを保持し、
標準形式トレースログを用いた処理(可視化表示など)を容易にする。

現在、標準形式トレースログのパースに正規表現を用いている箇所を
パーサを用いるように、\verb!TraceLog!コンストラクタを変更する。


\newpage
\section{変更内容}
\subsection{クラス構成}
正規表現によるパース(\verb!Regex!クラスおよび\verb!Match!クラス)を廃止し、
標準形式トレースログ用のパーサを作成して、\verb!TraceLog!クラスはそのパーサへパース処理を委譲する。
これにより、現在はパースの実装が\verb!TraceLog!クラスに直書きされているため
パースの実装方法を変更するのが困難であるのが、
\verb!TraceLog!クラスとパースの実装を分離することでパーサの交換が容易になり、
パーサの実装方法変更が容易になる。

今回の変更に伴う影響範囲は、\verb!TraceLog!クラス以外に存在しない。
リファクタリング前後のクラス図を図\ref{bclass},\ref{aclass}に示す。

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 500]{bclass.png}
\caption{リファクタリング前のクラス構成}\label{bclass}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 500]{aclass.png}
\caption{リファクタリング後のクラス構成}\label{aclass}
\end{figure}


% \subsection{処理の流れ}
% リファクタリング前の処理の流れは、図\ref{before}のように、
% \verb!TraceLog!コンストラクタにて正規表現を用いたパースを行っている。

% リファクタリング後の処理の流れは、図\ref{after}のように、
% \verb!TraceLog!コンストラクタでパーサクラスのメソッドを呼び、
% パーサクラスにて標準形式トレースログのパースを行う。
% パースが終了したら、パーサクラスから結果を受け取り、各値を設定する。

% \begin{figure}[H]
% \centering
% \includegraphics[width=0.8\hsize,bb=0 0 660 512]{before.png}
% \caption{リファクタリング前の標準ログ変換処理}\label{before}
% \end{figure}

% \begin{figure}[H]
% \centering
% \includegraphics[width=0.8\hsize,bb=0 0 660 500]{after.png}
% \caption{リファクタリング後の標準ログ変換処理}\label{after}
% \end{figure}


\subsection{パーサの構成}
パーサの実装は、コードでEBNFを表現し、直感的に理解できるようにする。

例として、HaskellのパーサコンビネータライブラリParsecを参考にした次のURLにあるものが挙げられる
(コードの一部はListing\ref{refacted}参照)。
あくまで例であり、このコードを使用するか、自作など他の実装方法を用いるかは、
デバッグの容易さ、実装のしやすさ、可読性、実行速度などの要素により決定する。


\begin{verbatim}
LukeH's WebLog : Monadic Parser Combinators using C# 3.0
http://blogs.msdn.com/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
\end{verbatim}


\newpage
\part{詳細仕様}
本章は、Phase5で行ったリファクタリングにより変更・追加された箇所、および、
リファクタリング後のシーケンスを説明し、今回採用しなかった手法との比較や今回の実装の採用理由を記述する。


\section{コード設計}
ここでは、リファクタリングの目標であった「EBNFを表現し、直感的に理解できる」コードの紹介と、
小節にて実装に用いた手法・概念および主要メソッドの説明をする。

まず、「EBNFを表現」したコードの例をListing\ref{code1}に示す。

\begin{lstlisting}[caption=「コードでEBNFを表現」したコード例(最終更新日現在),label=code1]
var line = Char('[').Time().Char(']').Event();
...
var object_ = 
	ObjectTypeName().Char('(').AttributeCondition().Char(')')
	.OR().
	ObjectName();
...			
var typeName = Many1(() => AnyCharOtherThan('(', ')', '.'));
\end{lstlisting}


これは、次のEBNFをパースすることを示している(rule-manual.pdfの2．1.2参照)。


\begin{lstlisting}[caption=Listing\ref{code1}が表す実際のEBNF,label=ebnf1]
TraceLogLine = "[", Time, "]", Event;

Resource = ResourceTypeName, "(", AttributeCondition, ")"
	 | ResourceName;

ResourceTypeName = /[0-9a-Z_]+/;
\end{lstlisting}



このように、Listing\ref{code1}はEBNFを表現しており、正規表現によるパージングより可読性が
向上している。Listing\ref{code1}は完全なものではなく、実際にはListing\ref{code2}
のような解析メソッド内に記述され、それを組み合わせることでListing\ref{code1}を実現している。

\begin{lstlisting}[caption=解析メソッド例,label=code2]
public ITraceLogParser ObjectTypeName()
{
	Begin();

	var typeName = Many1(() => AnyCharOtherThan('(', ')', '.'));

	typeName.ObjectTypeValue = Result();
	return (ITraceLogParser)typeName.End();
}
\end{lstlisting}

\subsection{利用した概念・手法}
\subsubsection{再帰下降パーサ}
今回、実装したパーサは、スタックを利用した再帰下降パーサであり、バックトラッキングを用いている。
これは、EBNFのようにトップダウンに記述されているものを表現するのに適しているが、
バックトラッキングによる処理効率低下が懸念される。

\subsubsection{パーサ・コンビネータ}
パーサ・コンビネータとは、パーサとパーサを組み合わせることのできるコンビネータを指す。
具体的には、Manyメソッド、Many1メソッド、ORメソッドが挙げられる。
これにより、EBNFの表現やLL(k)文法のパージングを可能にしている。
しかしながら、LL(k)文法を扱うため左再帰性の除去が必要である。

\subsubsection{NullObjectパターン}
インタフェースを実装しているが、何もしないクラスを用いるデザインパターン。
多態性を利用したもので、Nullかどうかを判別するコードを排除でき、処理の流れが明確になる。
今回、これを用いることでEBNFのような記述を実現している。
解析メソッドは、パーサクラスもしくはパーサクラス用のNullObjectを返すことで次の解析メソッドを実行するかを決定する。
すると、if分をはさまずにメソッドチェーンのみで生成規則を表現できるようになる。

他に、Nullによる問題(意図しないNull参照による例外発生など)を防止できるというメリットもある。

\subsection{基本メソッドの説明}\label{sec:ms}
\subsubsection{Beginメソッド}
解析メソッドの処理で最初に実行されるメソッド。

現在は、スタックへのパース結果およびポインタ
\footnote{解析しようとしている文字の位置を示すもの。}
の保存領域確保を行っている。

\subsubsection{Endメソッド}
解析メソッドの処理で最後に実行されるメソッド。
基本的に、パースを実行、つまり、生成規則を表すメソッドチェーンを実行して得られた戻り値
(パーサオブジェクトまたはNullObject)から呼ばれる。

現在は、スタックのポップ、直前のスタックにあるパース結果との結合、NullObjectのステータス初期化を行っている。
パーサクラスかNullObjectクラスかで動作が変わる。

\subsubsection{Resultメソッド}
パースを実行して得られた文字列を返すメソッド。

\subsubsection{ORメソッド}
EBNFの記号\verb!"|"!を表すメソッド。生成規則を表すメソッドチェーンで使用する。

このメソッドより前の生成規則に当てはまらなかった場合、このメソッド内でバックトラッキングして、
次の生成規則の適用を試みる。

\subsubsection{Manyメソッド}
EBNFの記号\verb!"*"!を表すメソッド。生成規則を表すメソッドチェーンで使用する。

引数に与えられた解析メソッドを0回以上適用させる。

\subsubsection{Many1メソッド}
EBNFの記号\verb!"+"!を表すメソッド。生成規則を表すメソッドチェーンで使用する。

引数に与えられた解析メソッドを1回以上適用させる。


\section{クラス設計}
リファクタリング後のクラス図を図\ref{class}に示す。
\verb!TraceLog!クラス以外のクラス群が、前章の図\ref{aclass}にあるサブシステムに相当する。

パーサは、基本的な機能を備えたクラスとパース対象に特化したクラスにわけることで、
基本的な機能を備えたクラスの再利用ができるようになっている。
そのため、それに該当するParserクラスおよびNullObjectForParserクラスを
継承する派生クラスを定義し、ITraceLogParserクラスのような特化したインタフェースを定義してそれぞれの
派生クラスが実装することで、様々なパーサが作成可能である。

次に、図\ref{class}にある各クラスの簡単な説明をする。

\begin{figure}[H]
\centering
\includegraphics[width=1.\hsize,bb=0 0 728 537]{class.png}
\caption{リファクタリング後のクラス構成}\label{class}
\end{figure}

\subsection{既設クラス}
\subsubsection{TraceLogクラス}
標準形式トレースログをコード上で扱うためのクラス。

今回、そのコンストラクタをリファクタリングし、可読性の向上を行った。
また、新たに\verb!TraceLogParser!オブジェクトを保持する静的フィールドを追加した。

\subsection{新設クラス}
\subsubsection{Parserクラス}
パーサを実現するための基本的な機能を備えたクラス。

これを継承し、解析メソッドを記述することで専用のパーサを作成する。
\ref{sec:ms}に示したメソッドの他に、アルファベットや数字の解析メソッドも有する。

\subsubsection{StackForParserクラス}
\verb!Parser!クラスが利用する専用スタック。

パーサが今までのパース結果やポインタを退避させるのに用い、できるだけ効率よく管理するために用意した。

\subsubsection{InputStreamForParserクラス}
パース対象を格納し、管理するクラス。

ポインタの制御やポインタの示す文字の提供などを行う。
\verb!.NET Framework!の標準ライブラリである\verb!StringReader!クラスは、
Readメソッドで文字を消費してしまって復元が難しいため、専用のクラスを用意した。

\subsubsection{NullObjectForParserクラス}
\verb!Parser!クラスのNullObjectを実現するための基本的な機能を備えたクラス。

これを継承し、解析メソッドを含むインタフェースを実装することで、専用のパーサ用NullObjectを作成する。


\subsubsection{TraceLogParserクラス}
標準形式トレースログ用のパーサクラス。

標準形式トレースログをパースするための解析メソッドや結果を取得するためのプロパティがある。

\subsubsection{NullObjectOfTraceLogParserクラス}
標準形式トレースログ用のパーサクラス用のNullObjectクラス。

メソッドは基本的に何もしないが、効率やアルゴリズム上の理由などで処理を行う場合がある。
ただし、NullObjectとしては異例なため、そのような場合は保守性が低下する恐れがある。

\subsubsection{IParserクラス}
\verb!Parser!クラスと\verb!NullObjectForParser!クラスを結ぶインタフェース。

これにより、メソッドチェーンによるEBNFのような表現を実現している。

\subsubsection{ITraceLogParserクラス}
\verb!TraceLogParser!クラスと\verb!NullObjectOfTraceLogParser!クラスを結ぶインタフェース。

これにより、メソッドチェーンによるEBNFのような表現を実現している。

\section{シーケンス}

\part{評価}
\section{他手法との比較}
\subsection{性能比較}



\end{document}
