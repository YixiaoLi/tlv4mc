% Sample file for the use of compsoft style file.
%
\documentclass[softwareronbun]{compsoft}
%
% optional argument としては
%       ronbun, Eronbun, softwareronbun, tutorial, kaisetsu, topics, 
%       softwareshokai, forum, zadankai, bookreview, pioneer, memoriam,
%       tokushuronbun, Etokushuronbun, tokushusoftwareronbun, 
%       tokushututorial, tokushukaisetsu, 
%       tokushutopics, tokushusoftwareshokai,
%       suisenronbun, Esuisenronbun, 
%       kantogen, tokushutobira, gakkaikiji, henshu
% などがある．default は ronbun になっている.
%
% 英語論文の場合は Eronbun, Etokushuronbun（特集号の場合）, 
% Esuisenronbun（ワークショップ推薦論文の場合）を選択する．
%
% tokushuronbun, Etokushuronbun, tokushusoftwareronbun,
% tokushututorial, tokushukaisetsu, tokushutobira, 
% suisenronbun, Esuisenronbun を optionとして選んだとき
% には，preambleの中で
%       \def\tokushutitle{...} または  \def\suisentitle{...}
% のようにして特集名またはワークショップ名を定義する．
%
% アブストラクトは，日本語の論文／解説／チュートリアルの場合は和文と英文
% の双方をつける．英語論文の場合は英文 (\Eabstract) だけでよい．
%
% 巻数，号数，page もpreambleの中でsetcounterすること．
% これらの番号は印刷所で最終調整される．
% 
% Preamble
\setcounter{巻数}{16}
\setcounter{号数}{5}
\setcounter{page}{1}

\usepackage[dvips]{graphics}

% ユーザが定義したマクロなどはここに置く．ただし学会誌のスタイルの
% 再定義は原則として避けること．
\usepackage{here}
\usepackage{morefloats}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage{mymacros}

\begin{document}
\title{トレースログ可視化ツール \\ TraceLogVisualizer（TLV）}
%
% 和文論文の場合，姓と名の間には半角スペースを入れ，
% 複数の著者の間は全角スペースで区切る
%
\author{後藤 隼弐　本田 晋也　長尾 卓哉　高田 広章%
%
% ここにタイトル英訳（英文の場合は和訳）を書く．
%
\thanks{Visualization Tool for Trace Log. TraceLogVisualizer（TLV）}
%
% ここに著者英文表記(英文の場合は和文表記）および所属(和文および英文) を書く．
% 複数著者の所属はまとめてよい．
%
\thanks{Junji Goto, Hiroaki Takada, 名古屋大学 大学院情報科学研究科, 
Graduate School of Information Science, Nagoya University.
Shinya Honda, Takuya Nagao, 名古屋大学 大学院情報科学研究科 附属組込みシステム研究センター,
Center for Embedded Computing Systems,
Graduate School of Information Science, Nagoya University
}
%
% 以下は出典情報．ページ番号は印刷所で入れます．
% 1行で収めるために文字間隔を少し詰めている．
%
\thanks{\kanjiskip 0pt minus 0.15zw
コンピュータソフトウェア, \kern-0.75pt Vol.16, \kern-0.75pt
No.5 \kern-1.25pt(1999), \kern-0.75pt pp.78--83.}
%
% 記事カテゴリと受付日．不明の場合はxxxx年yy月zz日などでよい．
%
\thanks{[ソフトウェア論文] xx年x月xx日受付.}}
%
% 和文アブストラクト
\Jabstract{%
マルチコア環境で動作するソフトウェアのデバッグには，トレースログの解析が
有効であるが，開発者がトレースログを直接扱うのは非効率的である．そのため，
トレースログを可視化することにより解析を支援するツールが存在するが，これ
らは汎用性や拡張性に乏しいという問題がある．そこで我々は，これらの問題を
解決したトレースログ可視化ツール（TLV）を開発した．TLVは，変換ルールによ
りトレースログを標準形式に変換することで汎用性を実現し，可視化ルールによ
り可視化表示項目の追加・変更を可能にすることで拡張性を実現している．TLV
を用いて形式の異なる3種類のトレースログを可視化し，汎用性と拡張性を確認
した．
}
%
% 英文アブストラクト（本サンプルの原論文にはなし）
\Eabstract{
It is effective to debug software executed in multi-core processors by 
analyzing a trace log, but it is inefficient that developers analyze the 
trace log directly. Therefore, some visualization tools for the trace 
log had been developed before now, but there are two problems, lacks of 
general versatility and expandability. To that end, we developed 
TraceLogVisualizer(TLV), a visualization tool for the trace log that 
solved those problems. In this paper, we will discuss requirements to 
achieve general versatility and expandability, and how we achieved them.
}
%
\maketitle

\section{はじめに}
\label{sec1}

近年，組込みシステムにおいても，マルチコアプロセッサの利用が進んでいる．
その背景には，シングルプロセッサの高クロック化による性能向上効果の限界や，
消費電力の増大がある．マルチコアプロセッサシステムでは，処理の並列性を高
めることにより性能向上を実現するため，消費電力の増加を抑えることができる．
しかし，マルチコアプロセッサ環境で動作するソフトウェアのデバッグを行うの
は，シングルプロセッサ環境に比べ困難であるという問題がある．これは，各コ
アが非同期的に並列動作するため，タイミングに依存した再現性の低いバグが発
生する可能性があることや，ハードウェアの制約からコア間の同期精度が低い場
合があり，ブレークポイントやステップ実行を用いた従来のデバッグ手法が有効
ではない場合があるからである．

一方，マルチコアプロセッサ環境で有効なデバッグ手法として，プログラム実行
履歴であるトレースログを解析する手法がある．この手法が有効である理由は，
並列プログラムのデバッグを行う際に必要な情報である，プロセスが，いつ，ど
のプロセッサで，どのように動作していたかを知ることができるからである．し
かしながら，開発者がトレースログを直接解析するのは効率が悪い．図
\ref{traceLogSample}に，2コア上で動作するRTOS（Real-Time Operating 
System）が出力するトレースログの例を示す．図\ref{traceLogSample}の例では，
約430$\mu$sの間に5行のトレースログが出力されており，トレースログを収集す
る時間が長くなれば膨大な量になることを示唆している．取得する情報の粒度を
細かくしたり，処理の複雑さが増すと，出力されるトレースログの量はさらに増
大するため，デバッグを行う際に必要な情報を探し出すのが困難となる．また，
各コアのトレースログは時系列に分散して記録されているため，コア毎の動作を
解析するのが困難である．

\begin{EBNFFileWithExample}{2コア上で動作するRTOSが出力するトレースログの例}
      {traceLogSample}
      {{\tt \ [}{\it time($\mu$s)}{\tt ]:[}{\it core\_id}{\tt ]: }{\it information}}
      {A sample of trace log dumped by RTOS running on dual-core}
[60692484]:[1]: task 4 becomes WAITING.
[60692586]:[2]: leave to sns_ctx state=0.
[60692708]:[1]: dispatch from task 4.
[60692798]:[2]: enter to get_pid p_prcid=304.
[60692914]:[1]: dispatch to task 1.
\end{EBNFFileWithExample}

トレースログの解析を支援する方法として，ツールによるトレースログの可視化
があり，これまでにいくつかのトレースログ可視化ツールが開発されている．具
体的には，組込みシステム向けデバッガソフトウェアや統合開発環境の一部
\cite{PARTNER-JET,watchpoint,QNXMomentics,eBinder}やUnix系OSのトレースロ
グプロファイラ\cite{LTTV,Chime}などが存在する．しかしながら，これら既存
のツールは，特定の環境（OSやデバッグハードウェア）を対象としているため，
可視化対象となるトレースログの形式が固定されている．そのため，他の環境が
出力するトレースログを可視化することができず，汎用性に乏しいという問題が
ある．また，可視化表示する項目やその表現方法が固定である場合が多く，拡張
性に乏しいという問題もある．

そこで我々は，これらの問題を解決し，汎用性と拡張性を備えたトレースログ可
視化ツールを開発することを目的とし，TraceLogVisualizer（TLV）を開発した．
開発にあたり，我々は，まず，TLV内部でトレースログを一般的に扱えるよう，
トレースログを一般化した標準形式トレースログを定めた．さらに，任意の形式
のトレースログを標準形式に変換するためのルールを変換ルールとして形式化し，
ユーザが外部から指定できる仕組みを提供した．次に，トレースログの可視化表
示項目やその表現方法を指示する仕組みの抽象化を行い，可視化ルールとして形
式化した．また，可視化ルールをユーザが外部から指定できる仕組みを提供した．
TLVでは，環境毎に変換ルールと可視化ルールを外部ファイルとして用意するこ
とで様々な環境に対応することが可能であり，これにより，汎用性と拡張性を実
現している．

本論文は次のように構成される．2章では，汎用性と拡張性を実現するためのト
レースログ可視化ツールの要件と，TLVでの実現方針について述べる．3章では，
要件と実現方針に基づくTLVの設計について述べ，4章では，その実装について述
べる．5章では，複数のトレースログの可視化表示や，可視化表示項目の変更，
追加を行い，TLVの汎用性と拡張性を示す．最後に，6章でまとめと今後の課題，
展望を述べる．

\section{要件と実現方針}
\label{sec2}

本章では，トレースログ可視化ツールが汎用性と拡張性を備えるための要件と，
TLVでの実現方針についてそれぞれ説明する．

まず，トレースログ可視化ツールの定義，ならびにその汎用性と拡張性を明確に
する．本研究では，トレースログ可視化ツールを，時系列に記録されたプログラ
ムの実行履歴をテキスト形式でファイル化したトレースログファイルを読み込み，
その内容をGUIを通じて時系列に可視化表示するツールとする．次に，トレース
ログ可視化ツールの汎用性を，入力するトレースログファイルの形式を制限しな
いこととする．これは，ユーザがツールのバイナリを変更することなく，様々な
形式のトレースログファイルを可視化表示できることを指す．また，拡張性を，
ユーザがツールのバイナリを変更することなく，容易に可視化表示項目の追加・
変更・削除ができることとする．可視化表示項目とは，トレースログの内容や出
力元の環境，解析の目的などに基づき区分される可視化表示する情報の単位であ
る．具体的には，出力元の環境がOSの場合，``タスクの状態遷移''や``タスクの
コア占有率''などが該当する．

\subsection{汎用性の実現}
\label{subsec2_1}

はじめに，本研究では，汎用性を実現するため，トレースログの標準形式を提案
する．そして，任意の形式のトレースログを，標準形式に変換するためのルール
を変換ルールとして形式化し，ユーザが外部から指定できる仕組みを提供する．

トレースログ可視化ツールが汎用性を実現するためには，可視化表示の仕組みが
特定のトレースログの形式に依存しないようにしなければならない．そのために
は，ツールがトレースログを一般的に扱えなければならず，トレースログの形式
を標準化する必要がある．標準化されたトレースログの形式を標準形式と呼ぶ．
つまり，汎用性を実現するためには，可視化表示の仕組みが標準形式にのみ依存
するようにし，任意の形式のトレースログを標準形式のトレースログに変換する
仕組みを提供すればよい．

標準形式への変換処理は，逐次的なテキストの置き換えといった，単純なテキス
ト処理では要件を満たせない場合がある．たとえば，変換元のトレースログが暗
に含む情報を，可視化のために標準形式として出力する必要がある場合，機能的
に不十分になる場合が考えられる．具体例として，RTOSが出力するトレースログ
を，標準形式に変換する場合を考えてみる．RTOSにおいては，「あるタスクがデ
ィスパッチされた」という情報（以下，Aとする）は，暗に，「実行中のタスク
がプリエンプトされた」という情報（以下，Bとする）を含んでいる．しかしな
がら，RTOSの実装によっては，トレースログを出力するコストを減らすため，A
のみをトレースログとして出力し，Bを出力しない場合がある．このとき，Bを標
準形式トレースログとして出力したい場合，Aのトレースログを変換する際に，A
が出力された時刻に実行状態であるタスクが存在するかどうか，また，存在する
場合はどのタスクであるのか，という情報が必要となる．そのため，これらの情
報を，変換元のトレースログファイルの内容から判断する必要がある．つまり，
標準形式への変換処理においては，変換元のトレースログが暗に含む情報を出力
するため，それを出力する条件の制御，また条件を制御するために必要な情報を
取得する手段が必要である．

\subsection{拡張性の実現}

拡張性を実現するためには，汎用的な可視化表示の仕組みを提供し，ユーザが可
視化表示項目に合わせてそれを制御できればよい．つまり，可視化表示項目毎に
可視化表示の仕組みを用意するのではなく，汎用的な可視化表示の仕組みに対し
て，可視化表示項目を実現するパラメータを指定することで可視化表示を行う．
そして，ユーザがパラメータを指定する手段を実現すればよい．その際，汎用性
の実現のため，汎用的な可視化表示の仕組みは，標準形式トレースログにのみ依
存するようにしなければならないことを前節で述べた．

また，指定するパラメータは，描画処理に必要なGUIフレームワークや表示デバ
イスに依存しないことが要求される．これは，プログラムの可搬性を損なわない
ためである．

本研究では，汎用的な可視化表示の仕組みを実現するために，まず，トレースロ
グの内容から可視化表現を決定し，それを表示するまでの流れを抽象化し，本質
的な処理を洗い出す．次に，ユーザが，どの処理に，どのようなパラメータを指
定できればよいかを判断し，可視化ルールとして形式化する．そして，ユーザが
外部から可視化ルールを指定できる仕組みを提供する．

\section{設計}
\label{sec3}

本章では，前章で汎用性を実現するための手段として挙げた標準形式と変換ルー
ルと，拡張性を実現するための手段である可視化表示の仕組みの設計について説
明する．

\subsection{標準形式}
\label{subsec3_1}

トレースログを一般化するため，RTOSやUnix系OS，ISS（Instruction Set 
Simulator）などのトレースログの形式の調査を行った．その結果から，次のよ
うにトレースログを一般化した．はじめに，トレースログを，時系列にイベント
を記録したものとした．イベントとはイベント発生源の事象であり，イベント発
生源の属性の変化，または振る舞いとした．ここで，イベント発生源をリソース
と呼称し，固有の識別子として名前をもつとした．つまり，リソースとは，イベ
ントの発生源であり，名前を持ち，固有の属性をもつものである．また，リソー
スは，型により属性，振る舞いを特徴付けられるとした．ここで，リソースの型
をリソースタイプと呼称し，固有の識別子として名前をもつとした．属性は，リ
ソースが固有にもつ文字列，数値，真偽値で表されるスカラーデータとし，振る
舞いはリソースの行為であるとした．それぞれは固有の識別子として名前をもつ．

例として，RTOSが出力する，「TASK1という名前のタスクの状態が，実行状態に
遷移した」という情報のトレースログを，一般化した方法で考えてみる．この場
合，TASK1がリソースであり，タスクがリソースタイプであると考えることがで
きる．また，タスクの状態は属性にあたり，その属性が実行状態という値に変化
したというイベントであると言える．

図\ref{standartFormat}に，一般化の結果を形式化したトレースログの標準形式
の定義を示す．定義には，EBNF（Extended Backus Naur Form），および終端記
号として正規表現を用いている．正規表現はスラッシュ記号（{\tt /}）で挟み
記述している．

\begin{EBNFFile}{標準形式の定義}{standartFormat}{A definition of the standard format}
TraceLog = { TraceLogLine,"\n" };
TraceLogLine = "[",Time,"]",Event;
Time = /[0-9a-zA-Z]+/;
Event = Res,".",(AttrChange|BhvrHappen);
Res = ResName|ResTypeName,"(",AttrCond,")";
ResName = Name;
ResTypeName = Name;
AttrCond = BoolExp;
BoolExp = Bool|CompExp
   |BoolExp,[{LogclOpe,BoolExp}]
   |"(",BoolExp,")";
CompExp = AttrName,CompOpe,Value;
Bool = "true"|"false";
LogclOpe = "&&"|"||";
CompOpe = "=="|"!="|"<"|">"|"<="|">=";
AttrName = Name;
AttrChange = AttrName,"=",Value;
Value = /[^"\\]+/;
BhvrHappen =  BhvrName,"(",Args,")";
BhvrName = Name;
Args = [{Arg,[","]}];
Arg = /[^"\\]*/;
Name = /[0-9a-zA-Z_]+/;
\end{EBNFFile}

標準形式において，リソースの記述方法（図\ref{standartFormat}：5行目）は，
リソースの名前（{\tt ResName}）による直接指定か，リソースタイプの名前と
属性の条件（{\tt ResTypeName(AttrCond)}）による条件指定の2通りの方法で指
定できるとした．条件指定では，リソースタイプとリソースの属性の値から，特
定のリソース，または複数のリソースを表現することができる．条件指定は，
2.1節で述べた，変換元のトレースログが暗に含む情報の表現を可能にするため
導入した．属性の値の変更と振る舞いの発生の記述方法は，JavaやC++などのオ
ブジェクト指向言語における，メンバ変数への代入と，メソッドの呼び出しの記
法と同様である．

図\ref{standartFormatTraceLogSample}に，RTOSが出力するトレースログを標準
形式に変換した標準形式トレースログの例を示す．1行目がリソースの振る舞い
イベントであり，2行目，3行目が属性の値の変化イベントである．

1行目は，時刻2403010に，{\tt MAIN\_TASK}という名前のリソースが{\tt 
leaveSVC}という振る舞いを，{\tt ena\_tex}と{\tt ercd=0}を引数として発生
したことを表現している．これは，タスクである{\tt MAIN\_TASK}が，{\tt 
ena\_tex}というシステムコールを，エラーコード{\tt 0}でリターンしたことを
意味している．

1行目，2行目はリソースを名前で直接指定しているが，3行目はリソースタイプ
と属性の条件によってリソースを特定している．3行目は，時刻4496802に，その
時点でリソースタイプが{\tt TASK}で属性{\tt state}が{\tt RUNNING}であるリ
ソースの，属性{\tt state}が{\tt READY}になったことを表現しており，実行状
態であるタスクが実行可能状態になった，というイベントを意味している．

\subsection{変換ルール}
\label{subsec3_2}

変換ルールは，任意の形式のトレースログを，標準形式トレースログに変換する
ためのルールであり，これらの対応関係を定義したものである．標準形式への変
換は，変換ルールに基づき，テキストの変換処理を行う処理である．

2.1節において，変換処理の要件として，変換元のトレースログが暗に含む情報
を出力するため，それを出力する条件の制御，また条件を制御するために必要な
情報を取得する手段が必要であることを述べた．TLVでは，出力する条件の制御
を，指定された時刻の特定リソースの有無や数，属性の値，属性値変更イベント
であれば変更後の値，振る舞いイベントであれば，その引数などを用いて論理式
を記述することで行う．論理式の記述は，それらの値を取得できるマクロを用い
て行い，その際の記法には標準形式を用いる．たとえば，図
\ref{standartFormatTraceLogSample}の3行目を出力する条件が，「時刻4496802
にリソースタイプが{\tt TASK}で属性{\tt state}が{\tt RUNNING}であるリソー
スが存在する場合に出力する」である場合，条件には，
\verb|$EXIST{[4496802]TASK(state==RUNNING)}|と記述すればよい．このとき，
\verb|$EXIST{|{\it resource}\verb|}|が，リソース{\it resource}の有無を真
偽値で取得するマクロである．

\begin{EBNFFile}{標準形式トレースログの例}{standartFormatTraceLogSample}{A sample of a standard format trace log}
[2403010]MAIN_TASK.leaveSVC(ena_tex,ercd=0)
[4496099]MAIN_TASK.state=READY
[4496802]TASK(state==RUNNING).state=READY
\end{EBNFFile}

\subsection{可視化表示の仕組み}
\label{subsec3_3}

可視化表示の仕組みは，汎用性の実現のため，標準形式にのみ依存するようにし
なければならない．また，拡張性の実現のためには，可視化表示の仕組みとして
汎用的なものを提供し，ユーザが可視化表示項目に依存するパラメータを指示で
きる仕組みを提供すればよい．

本節では，はじめに，トレースログの内容から可視化表現を決定し，それを表示
するまでの流れを抽象化し，可視化表示の仕組みとして本質的な処理を洗い出す．
そして，ユーザが，どの処理に，どのようなパラメータを指定すればよいかを判
断する．

トレースログ可視化ツールにおいて，可視化表示とは，可視化表示項目毎に要求
される表現（以下，可視化表現とする）を，トレースログの内容に従い時系列の
図として画面に描画する処理であると考えられる．ここで，画面への描画は，
GUIフレームワークに依存するため，可視化表示の仕組みとしては本質的ではな
い．そのため，可視化表示の仕組みは，可視化表現を，時間と高さを次元にもつ
仮想的な座標に割り当てる処理であると抽象化できる．ここで，可視化表現は，
複数の図形で構成されるものとする．図\ref{visualizing}に，抽象的な可視化
表示の仕組みを示す．

図形は，楕円や四角などの複数の基本図形で構成されるものと考えることができ
る．このとき，図形を定義する座標系をローカル座標系と呼称する．また，図形
をトレースログの内容に従い配置する座標である，時間と高さを次元にもつ仮想
的な座標をワールド座標系と呼称する．ワールド座標系へ割り当てられた図形は，
表示開始時刻と単位時間あたりのピクセル数により表示デバイスに表示される．
このとき，表示先の座標系をデバイス座標系と呼称する．単位時間あたりに，何
ピクセル数でワールド座標系をデバイス座標系に割り当てるかという処理が，表
示上の拡大，縮小の処理となる．

以上の，可視化表示の仕組みの抽象化から，ユーザが任意の可視化表示項目を実
現するために，汎用的な可視化表示の仕組みに対して与える指示としては，どの
ような図形を，どの時間領域に割り当てるかということであると考えられる．そ
の際，図形を定義するには，形状や大きさ，位置，色，透明度などが指示できれ
ばよい．一方，図形をどの時間領域に割り当てるか，つまり，図形をワールド座
標系のどの領域に割り当てるかの指示は，割り当て先の領域に対して一般的でな
ければならない．つまり，割り当て先の個々の領域をすべて指定するのではなく，
ルールに基づいて割り当てが行われるように指定されるべきである．このルール
を可視化ルールと呼称する．

TLVでは，可視化ルールとして，表示領域の時間をイベントを用いて指定するこ
ととした．その際，イベントの記述に標準形式を用いる．つまり，時間領域の指
定に，開始時刻と終了時刻ではなく，指定の開始イベントと終了イベントを記述
することで行う．標準形式トレースログに可視化ルールを適用する際に，指定さ
れたイベントに一致するイベントを標準形式トレースログから探し，そのイベン
トの時刻を割り当て先の時間領域として採用することで，ワールド座標系への割
り当てを行う．

\begin{figure}[t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/visualizing.eps}}
\caption{抽象的な可視化表示の仕組み}
\label{visualizing}
\end{center}
\end{figure}

\section{実装}
\label{sec4}

本章では，前章で行った設計を元に，TLVをどのように実装したかを述べる．具
体的には，全体の構成と処理の流れから，変換ルールや可視化ルールをどのよう
に形式化したか，また，それらをどの段階で適用するのかを説明する．TLVの実
装言語はC\#3.0であり，統合開発環境としてMicrosoft社のVisural Studio 2008 
Professional Editionを用いた．

TLVは，2つの主たる処理と6種の外部ファイルによって構成される．図
\ref{fig:tlv}にTLVの構成を示す．

トレースログを可視化表示する際，ユーザは，トレースログファイルとリソース
ファイルを用意する．トレースログファイルは，可視化対象となる環境が出力し
た，任意の形式のトレースログをファイル化したものである．また，リソースフ
ァイルは，トレースログの形式や，トレースログに登場するリソースの定義，ト
レースログの時刻の単位や基数，適用する変換ルールと可視化ルールの指定など
を記述したファイルである．リソースファイルの例を図\ref{resourceFile}に示
す．

リソースヘッダファイルと変換ルールファイルは，トレースログを出力する環境
毎に用意する．リソースヘッダファイルはリソースタイプの定義を記述したファ
イルであり，変換ルールファイルは，変換ルールを記述したファイルである．リ
ソースヘッダファイルの例を図\ref{resourceHeaderFile}に示す．変換ルールフ
ァイルの例を図\ref{convertRuleFile}に示す．

可視化ルールファイルは，可視化表示項目毎に図形と可視化ルールの定義を記述
したファイルであり，複数の可視化表示項目を一つのファイルでまとめて定義す
ることができる．可視化表示項目を追加したければ，新たな可視化ルールファイ
ルを用意すればよい．

TLVを構成する2つの主たる処理は，標準形式への変換と，図形データの生成であ
る．標準形式への変換は，任意の形式のトレースログに対して，変換ルールを適
用することで標準形式のトレースログに変換する処理である．この処理では，ユ
ーザがトレースログファイルとリソースファイルを入力し，リソースファイルの
定義によりリソースヘッダファイル，変換ルールファイルが自動で読み込まれる．

図形データの生成は，変換された標準形式トレースログに対して可視化ルールを
適用し図形データを生成する処理である．この処理には，外部ファイルとして，
可視化ルールファイルがリソースファイルの定義に従い読み込まれる．

それぞれの処理で生成された標準形式トレースログと図形データは，TLVデータ
としてまとめられ可視化表示の元データとして用いられる．TLVデータはTLVファ
イルとして外部ファイルに保存することが可能であり，TLVファイルを読み込む
ことで，2つの処理を省略して可視化表示することができる．

TLVが扱う6種のファイルのうち，トレースログファイル以外はJSON（JavaScript 
Object Notation）\cite{JSON}と呼ばれるデータ記述言語を用いて記述する．
JSONは，主にウェブブラウザなどで使用されるECMA-262，revision 3準拠の
JavaScript（ECMAScript）と呼ばれるスクリプト言語のオブジェクト表記法をベ
ースとしており，RFC 4627としてで仕様が規定されている．JSONの特徴は，構文
が単純であることである．これは，人間にとっても読み書きが容易であり，コン
ピュータにとっても解析が容易であることを意味する．これにより，ユーザの記
述コスト，習得コスト，またファイルの解析を行う実装コストを低減することが
できる．

\begin{figure}[!t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/tlv.eps}}
\caption{TLVの構成}
%\ecaption{A structure of TLV}
\label{fig:tlv}
\end{center}
\end{figure}

\subsection{標準形式変換}

標準形式への変換は，変換ルールを変換元のトレースログに適用することで行う．
このとき，変換ルールの定義は，変換ルールファイルに記述する．

標準形式へ変換する際，リソースファイルを読み込むことでトレースログの形式
や，扱うリソースの情報，適用するリソースヘッダや変換ルールなどを取得する．
また，扱うリソースのリソースタイプを定義したリソースヘッダファイルを読み
込み，リソースの属性の初期値や，属性の型などの情報を得る．

図\ref{resourceHeaderFile}に，RTOSにおけるタスクを，リソースタイプとして
定義しているリソースヘッダファイルの例の一部を示す．2行目から，タスクを
{\tt Task}という名前のリソースタイプとして定義している．4行目から属性の
定義をしており，13行目から振る舞いの定義を記述している．ここでは，数値型
の{\tt id}という属性とタスクが起動したことを表す{\tt start}，終了したこ
とを表す{\tt exit}，システムコールに入ったことを表す{\tt enterSVC}という
振る舞いが定義されていることがわかる．

図\ref{resourceFile}に，図\ref{resourceHeaderFile}で示される{\tt Task}と
いうリソースタイプのリソースを定義した，リソースファイルの例の一部を示す．
6行目に{\tt TASK1}という名前のリソースが定義されており，9行目から属性の
初期値の値が定義されている．

\begin{EBNFFile}{リソースファイルの例の一部}{resourceFile}{A sample of a resource file}
{ "TimeScale" :"us", "TimeRadix" :10,  /* 時刻の単位と基数 */
  "ConvertRules"   :["asp"],                 /* 変換ルール */
  "VisualizeRules" :["toppers","asp"],     /* 可視化ルール */
  "ResourceHeaders":["asp"],             /* リソースヘッダ */
  "Resources":{                    /* リソースの定義始まり */
    "TASK1":{           /* TASK1という名前のリソースを定義 */
      "Type":"Task",                     /* リソースタイプ */
      "Color":"ff0000",        /* リソース固有の色(GUI用) */
      "Attributes":{                 /* 属性の初期値を指定 */
        "id"    :1,
        "atr"   :"TA_NULL",
        "pri"   :10,
        /* ... 省略 ... */
        "state" :"DORMANT"
      }
    },
    /* ... 省略 ... */
\end{EBNFFile}

\begin{EBNFFile}{リソースヘッダファイルの例の一部}{resourceHeaderFile}{A sample of a resource-header file}
{ "asp":{
    "Task":{                        /* リソースタイプの名前 */
      "DisplayName":"タスク",       /* 表示名 */
      "Attributes":{                /* 属性の定義始まり */
        "id":{                      /* 属性名 */
          "VariableType"  :"Number",/* 属性の型 */
          "DisplayName"   :"ID",    /* 属性の表示名 */
          "AllocationType":"Static",/* 値は動的か静的か */
          "CanGrouping"  :false /* 同じ属性値同士でグループ */
        },                       /* を構成できるか(GUI用) */
        /* ... 省略 ... */
      },                              /* 属性の定義終わり */
      "Behaviors":{                   /* 振る舞いの定義開始 */
        "start":{"DisplayName":"起動"},/* タスクの起動 */
        "exit":{"DisplayName":"終了"}, /* タスクの終了 */
        /* ... 省略 ... */
        "enterSVC":{           /* システムコールの呼び出し */
          "DisplayName":"サービスコールに入る",
          "Arguments":{"name":"String","args":"String"}
        },
        /* ... 省略 ... */
\end{EBNFFile}

既存のテキスト処理するためのスクリプト言語として，awkなどがあるが，2.1節
で述べた要件を満たすためには，リソースヘッダファイルで定義されるリソース
の属性の初期値や型などの情報を参照したり，リソース毎に属性の値の遷移を監
視する必要があるなど，多くの複雑な記述をする必要があり，実用的ではない．
そのため，TLVでは，3.1節の設計で述べたとおり，特定リソースの有無や数，属
性の値の遷移などから標準形式トレースログの出力を制御する仕組みを変換ルー
ルに提供した．具体的には，指定された時刻の特定リソースの有無や数，属性の
値などを参照することができるマクロを提供した．このマクロを用いて標準形式
トレースログの出力を制御することで要件を満たすことができる．図
\ref{convertRuleFile}に変換ルールファイルの例の一部を示す．

図\ref{convertRuleFile}の2行目は，元のトレースログファイルから任意のトレ
ースログを検索するための正規表現であり，一致した場合に3〜6行目で指定され
る標準形式トレースログを出力する．3行目は，出力する条件であり，条件中に
\verb|$EXIST{|{\it resource}\verb|}|というマクロを用いてリソース{\it 
resource}の有無を判定している．条件が真の場合に4行目の標準形式トレースロ
グが出力される．5行目の標準形式トレースログは，2行目の正規表現に一致した
際に必ず出力される．

\begin{EBNFFile}{変換ルールファイルの例の一部}{convertRuleFile}{A sample of a convert-rule file}
{"asp":{
  "\[(?<t>\d+)\] dispatch to task (?<id>\d+)\.":[{
    "$EXIST{[${t}]Task(state==RUNNING)}":
      "[${t}]$RES_NAME{[${t}]Task(state==RUNNING)}.state=READY"
    },
    "[${t}]$RES_NAME{Task(id==${id})}.state=RUNNING"
  ],
  /* ... 省略 ... */
\end{EBNFFile}

\subsection{図形データ生成}

図形データの生成とは，3.2節で述べたとおり，標準形式トレースログの内容に
従い，ワールド座標系に図形を割り当てる処理である．図形データの生成は，図
形の定義と可視化ルールの定義に従い，標準形式トレースログに可視化ルールを
適用することで行う．

図形と可視化ルールの定義は可視化ルールファイルに記述する．図
\ref{visualizeRuleFile}に可視化ルールファイルの例の一部を示す．2行目から
10行目までが図形の定義であり，それ以降が可視化ルールの定義である．

\begin{EBNFFile}{可視化ルールファイルの例の一部}{visualizeRuleFile}{A sample of a visualize-rule file}
{ "toppers":{
    "Shapes":{                        /* 図形の定義始まり */
      "runningShapes":[{
          "Type":"Rectangle",         /* 形状の指定(長方形) */
          "Size":"100%,80%",          /* 大きさの指定 */
          "Pen":{"Color":"ff00ff00","Width":1},/* 線種の指定 */
          "Fill":"6600ff00"           /* 塗りつぶしの指定 */
        }],
      /* ... 省略 ... */
    },                                /* 図形の定義終わり */
    "VisualizeRules":{        /* 可視化ルールの定義始まり */
      "taskStateChange":{
        "DisplayName":"状態遷移", /* 可視化ルールの表示名 */
        "Target":"Task",        /* 適用するリソースタイプ */
        "Shapes":{                /* 表示項目の指定 */
          "stateChangeEvent":{
            "DisplayName":"状態", /* 表示項目の表示名 */
            "From":"${TARGET}.state", /* 開始イベント */
            "To"  :"${TARGET}.state", /* 終了イベント */
            "Figures":{               /* 表示する図形 */
              "${FROM_VAL}==RUNNING" :"runningShapes",
              "${FROM_VAL}==READY":"readyShapes"
              /* ... 省略 ... */
            }
          },
          /* ... 省略 ... */
        }
      },                      /* 可視化ルールの定義終わり */
      /* ... 省略 ... */
\end{EBNFFile}

図\ref{visualizeRuleFile}では，{\tt taskStateChange}という可視化ルールが
定義されており，開始イベントと終了イベントとして{\tt Target}で指定された
リソースタイプのリソースの属性の値変更イベントを指定している．そして，ワ
ールド座標系に割り当てる図形を，変更後の属性の値によって場合分けしている．

\section{評価}
\label{sec5}

図\ref{fig:aspTLVscreenShot}に，シングルプロセッサ用RTOSである
TOPPERS/ASPカーネル\cite{TOPPERS}が出力するトレースログを，TLVを用いて可
視化表示した結果のスクリーンショットを示す．タスクの状態遷移やシステムコ
ールの出入り，その際の引数，返値を可視化表示できていることがわかる．この
とき，変換ルールは約28行であり，可視化ルールは168行であった．また，リソ
ースヘッダファイルは44行であった．標準形式への変換処理に要した時間は，ト
レースログファイルが353行の場合で約2秒であった．

\begin{figure}[tb]
\begin{center}
\scalebox{0.4}{\includegraphics{img/aspTLVscreenShot.eps}}
\caption{TOPPERS/ASPカーネルが出力するトレースログを可視化表示したTLVの実行結果のスクリーンショット}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TOPPERS/ASP}
\label{fig:aspTLVscreenShot}
\end{center}
\end{figure}

次に，TOPPERS/ASPカーネルをマルチコアプロセッサ用に拡張したTOPPERS/FMPカ
ーネル\cite{TOPPERS}が出力するトレースログの可視化表示を行った．
TOPPERS/FMPカーネルが出力するトレースログの形式は，TOPPERS/ASPカーネルが
出力するトレースログの形式に，コアの番号を付加した形式になっている．また，
TOPPERS/FMPカーネルの可視化表示項目は，TOPPERS/ASPカーネルの可視化表示項
目に加え，実行コアを背景色で区別するように拡張したものが要求される．その
ため，TOPPERS/ASPカーネル用の変換ルールと可視化ルールをベースに拡張を行
った．その結果，変換ルールファイルは32行，可視化ルールファイルは232行，
リソースヘッダファイルは50行となった．図\ref{fig:fmpTLVscreenShot}に，
TOPPERS/FMPカーネルが出力するトレースログを，TLV用いて可視化表示した結果
のスクリーンショットを示す．タスクの状態遷移を表示している箇所に，背景色
で実行コアを区別し表現できていることがわかる．これにより，拡張性が確認で
きた．

\begin{figure}[t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/fmpTLVscreenShot.eps}}
\caption{TOPPERS/FMPカーネルが出力するトレースログを可視化表示したTLVの実行結果のスクリーンショット}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TOPPERS/FMP}
\label{fig:fmpTLVscreenShot}
\end{center}
\end{figure}

最後に，RTOSのトレースログとは形式の異なるトレースログの可視化を行い，汎
用性の確認を試みる．RTOSのトレースログとは形式の異なるトレースログとして，
ここでは，組込みコンポーネントシステムTECS（TOPPERS Embedded Component 
System）\cite{TECS}のトレースログを採用した．図
\ref{fig:tecsTLVscreenShot}に，組み込みコンポーネントシステムであるTECS
のトレースログをTLV用いて可視化表示した結果のスクリーンショットを示す．
図\ref{fig:tecsTLVscreenShot}より，コンポーネントの呼び出し関係が可視化
表示できていることがわかる．このとき，変換ルールは15行であり，可視化ルー
ルは88行であった．また，リソースヘッダファイルは47行であった．

\begin{figure}[t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/tecsTLVscreenShot.eps}}
\caption{TECSのトレースログを可視化表示したTLVの実行結果のスクリーンショット}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TECS}
\label{fig:tecsTLVscreenShot}
\end{center}
\end{figure}


\section{開発プロセス}

\subsection{OJL}

TLVは，OJL(On the Job Learning)の開発テーマとして開発された．OJLとは，企
業で行われているソフトウェア開発プロジェクトを教材とする実践教育であり，
製品レベルの実システムの開発を通じて創造的な思考力を身につけるとともに，
単なる例題にとどまらない，現実の開発作業を担うことにより，納期，予算とい
った実社会の制約を踏まえたソフトウェア開発の実際について学ぶことを目的と
している．

TLVはプロジェクトベースで開発が行われた．企業出身者2名と教員1名がプロジ
ェクトマネージャを務め，筆者を含む学生3名と企業出身者2名が開発実務を行っ
た．プロジェクトの進捗，成果物，情報の管理は，グループウェアやバグトラッ
キングシステム，ソースコードリポジトリ，Wikiといったネットワークアプリケ
ーションを用いて行われた．また，週に一度ミーティングを行い，開発実務者に
よる進捗の報告や，プロジェクトマネージャによる開発スケジュールの調整や指
導が行われた．

プロジェクトは約9ヶ月を通じて3フェーズに分けて実施された．フェーズを分割
した主な理由は，段階的な要求取得，目標設定や人員入れ替え時期，学期との同
期のためである．フェーズ1はプロトタイプの実装として約3ヶ月かけて行われ，
GUIの評価や要求の再取得，アプリケーションドメインを通じた設計方法の探索
を行うことを目的に行われた．

フェーズ1は，トレースログの対象をTOPPERS/ASPカーネルに絞り，可視化表示項
目もタスクの状態遷移のみとし，標準形式トレースログへの変換や，可視化ルー
ルの適用による可視化表示は行わないなど，目的の達成に必要な要件のみの実装
に努めた．フェーズ1での実装成果物の総行数は約9000行(有効行数5000行)であ
った．フェーズ1の成果物はTLVの開発関係者とRTOS開発者および利用者の数名に
利用され，意見や要求の収集を行った．その結果，ユーザインタフェース，追加
の機能要求，可視化表現項目について意見が得られた．フェーズ1では，プロト
タイプの実装という位置づけであったため，開発プロセスを設定せずに開発を行
った．その結果，実装中心の開発になってしまい，進捗管理が曖昧になってしま
った．

フェーズ2は約5ヶ月かけて行われ，標準形式変換ルールファイルによる標準形式
トレースログへの変換や，可視化ルールファイルによる可視化表現の外部プラグ
イン化の実装など，汎用性，拡張性を実現する主機能の実装を目的に行われた．
フェーズ2では，フェーズ1での反省を踏まえ，開発プロセスを導入した．導入し
た開発プロセスはユースケース駆動のアジャイルソフトウェア開発であり，詳細
は次節で後述する．

フェーズ3は約1ヶ月かけて行われ，リソースヘッダファイル，変換ルールファイ
ル，可視化ルールファイルの充実を図るとともに，TLVの汎用性，拡張性の確認
を行うことを目的として行われた．

\subsection{ユースケース駆動アジャイルソフトウェア開発}
\label{subsec6_2}

フェーズ2において，TLVの開発は，ユースケース駆動のアジャイルソフトウェア
開発プロセスを用いて行われた．

アジャイルソフトウェア開発では，反復(イテレーション)と呼ばれる短い期間を
単位に反復して開発を行い，計画ではなく状況において適応的に対応することを
重視してソフトウェア開発を行う．1つのイテレーション内では1つの機能に対し
て設計，実装，テスト，文書化といった工程を完結して行う．TLVの開発ではユ
ースケースを機能の単位としてイテレーションを反復して実施した．図
\ref{fig:agile}にユースケース駆動アジャイルソフトウェア開発の例を示す．

\begin{figure}[t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/agile.eps}}
\caption{ユースケース駆動アジャイルソフトウェア開発}
%\ecaption{An use case driven agile software development}
\label{fig:agile}
\end{center}
\end{figure}

ユースケース駆動アジャイルソフトウェア開発の工程は，機能要求からユースケ
ースを洗い出すことからはじまる．そして，ユースケース毎に外部設計としてユ
ースケース図，ユースケース内のクラス図，シーケンス図を作成する．次に，ク
ラス単位で内部設計，単体テスト，実装を行う．内部設計では，文書化せずに，
クラス図で定義したクラスに関してインタフェースのみを記述したソースコード
スケルトンを作成し，ソースコード内のコメントとして機能，入出力を記述する
ことで行った．TLVのアジャイル開発では，実装の前にテストケースを作成し，
それをパスするように実装を行うテストファースト方式を採用した．単体テスト
は，メソッド単位のユニットテストとし，統合開発環境に付属するユニットテス
トフレームワークを用いて実装，実施を行った．単体テストの実装はテストケー
スの記述であり，ユニットテストフレームワークが出力するテストコードのスケ
ルトンに必要な情報を追記することで行う．単体テストの実装が終わったらクラ
スの実装を行う．クラスの実装は，単体テストを実施しながら，テスト項目のを
すべてをパスするかどうかを試しながら行う．1つのクラスの実装が終わればユ
ースケース内の次のクラスの内部設計に移る．

このようにしてユースケース内のクラスをすべて実装したら，ユースケース内の
クラスを結合してユースケースとして駆動する形に実装する．この際も，テスト
ケースの実装を先に行ってから実装を開始する．結合テストのテスト項目をすべ
てをパスしたら，1つのイテレーションの完了であり，次のユースケースの外部
設計を開始する．

本節では，TLVの開発において，ユースケース駆動アジャイルソフトウェア開発
の各工程で実践した内容について詳述する．

\subsubsection{プロジェクト管理}

フェーズ2のはじめの作業として，フェーズ1で行った評価の結果と，フェーズ2
の実施概要について，プロジェクト計画書として文書化した．

次に，フェーズ2で実装するTLVの機能を，要求仕様書として文書化した．また，
機能をユースケースを単位に定義し，ユースケース図を作成した．図
\ref{fig:usecase}にTLVのユースケース図を示す．

\begin{figure}[t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/usecase.eps}}
\caption{TLVのユースケース図の例}
%\ecaption{An example of use case diagram of TLV}
\label{fig:usecase}
\end{center}
\end{figure}

TLVの機能をユースケースを単位に定義した結果，全ユースケース数は36個であ
った．これらのユースケースを工程毎に分けた進捗表を作成し，これを用いて進
捗管理を行い，複数のメンバーでユースケースや工程で分担して実施した．

\subsubsection{設計}

図\ref{fig:agile}に示すとおり，外部設計としては，ユースケース内のクラス
の定義をクラス図として，クラス間の連携の流れをシーケンス図として作成する
ことで行う．図\ref{fig:class}に作成したクラス図の例を示す．また，図
\ref{fig:sequence}に作成したシーケンス図の例を示す．

\begin{figure}[t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/class.eps}}
\caption{TLVのクラス図の例}
%\ecaption{An example of class diagram of TLV}
\label{fig:class}
\end{center}
\end{figure}

\begin{figure}[t]
\begin{center}
\scalebox{0.4}{\includegraphics{img/sequence.eps}}
\caption{TLVのシーケンス図の例}
%\ecaption{An example of sequence diagram of TLV}
\label{fig:sequence}
\end{center}
\end{figure}

内部設計は文書化せずに，ソースコードのコメントを記述することで行った．外
部設計で作成したクラス図を元に，インタフェースのみを記述したスケルトンク
ラスを記述し，メソッドのコメントとして，引数，返値の説明，どのような内部
実装を行うべきかといった説明を記述する．

\subsubsection{テスト}

TLVのテストは，統合開発環境に付属するユニットテストフレームワークを用い
て実装，実施した．ユニットテストフレームワークは，クラスのメソッドの定義
を元に，テストケースのスケルトンを自動生成する仕組みを搭載しており，テス
ト工程作業の大幅な省力化を図ることができる．スケルトンは，引数の組み合わ
せと期待値を開発者が入力するように生成されており，これらを入力する作業が
実質的なテストケースの実装作業となる．

ユニットテストの単位はメソッドだが，単純なアクセサメソッドはテストの対象
外とした．その結果，491メソッドがユニットテストの対象となった．

\subsubsection{実装}

TLVの実装言語は，C$\sharp$ 3.0である．統合開発環境として Microsoft 
Visual Studio 2008 Professional Edition を用いた．TLVの実行には .NET 
Framework 3.5 が必要である．

実装はクラス単位で行い，ユニットテストを全部パスすることを目標に行う．そ
の際，テストの実施とクラスの実装は反復して行う．テスト結果は記録されるた
め，文書化する必要がなく，素早くデバッグを行うことができる．

TLVのソースコードメトリクスを表\ref{sourceMetrics}に示す．

\begin{table}[htb]
\begin{center}
\caption{TLVのソースコードメトリクス}
%\ecaption{A source code metrics of TLV}
\label{sourceMetrics}
\begin{tabular}{l|l}
\hline
総行数              & 18497 \\
ファイル平均行数    & 94.38 \\
有効な行数          & 10332 \\
コメント行数        & 1432 \\
空行                & 2224 \\
その他の行数(中括弧など) & 4509 \\
ファイル数          & 196 \\
クラス数            & 186 \\
インタフェース数    & 22 \\
列挙体              & 15 \\
デリゲート          & 2 \\
\hline
\end{tabular}
\end{center}
\end{table}


\section{おわりに}
\label{sec7}

本論文では，トレースログ可視化ツールであるTLVについて，背景と既存ツール
の問題点，それを解決するための要件，要件を満たすための方法とその実装，評
価について述べた．

既存ツールの問題点としては汎用性と拡張性の欠如を挙げ，それを解決する要件
として，トレースログの標準化と標準形式への変換の仕組みの提供，また可視化
表示の仕組みの汎用化とパラメータ指示の形式化が必要であることを述べた．

そして，TLVにおける要件の実装方法として，標準形式変換と図形データの生成，
変換ルールファイル，可視化ルールファイル，リソースヘッダファイル，リソー
スファイルについて説明した．

最後にTLVを用いて，シングルコアプロセッサ用RTOSやマルチコアプロセッサ用
RTOS，組込みコンポーネントシステムなど，形式が異なる様々なトレースログの
可視化を試み汎用性の確認を行った．また，可視化表示項目の変更，追加を試み
拡張性の確認を行った．その結果，変換ルールファイルと可視化ルールファイル，
リソースヘッダファイルの拡張によりそれらが実現可能であることを示した．

今後の課題としては，現状の変換ルールや可視化ルールの記述では実現できない，
計算の必要な可視化表示項目について検討することが挙げられる．たとえば，
RTOSにおけるCPU使用率やタスクのコア占有率の可視化表示などがある．これに
は，可視化ルールを現状の単純なイベントの指定ではなく，イベントの状態遷移
で指定できるようにする方法や，変換ルールをスクリプト言語化する方法などが
考えられる．

\begin{adjustvboxheight} % needed only when Appendix follows
\begin{thebibliography}{99}
\bibitem{PARTNER-JET}
JTAG ICE PARTNER-Jet，\\
http://www.kmckk.co.jp/jet/.

\bibitem{watchpoint}
WatchPointデバッガ，\\
https://www.sophia-systems.co.jp/.

\bibitem{QNXMomentics}
QNX Momentics Tool Suite，\\
http://www.qnx.co.jp/products/tools/.

\bibitem{eBinder}
eBinder，\\
http://www.esol.co.jp/embedded/ebinder.html.

\bibitem{LTTV}
Mathieu Desnoyers and Michel Dagenais, "OS Tracing for Hardware, Driver 
and Binary Reverse Engineering in Linux," CodeBreakers Journal Article, 
vol.4, no.1, 2007.

\bibitem{Chime}
OpenSolaris Project: Chime Visualization Tool for DTrace，\\
http://opensolaris.org/os/project/dtrace-chime/.

\bibitem{RFC3164}
RFC3164 The BSD syslog Protocol，\\
http://www.ietf.org/rfc/rfc3164.txt.

\bibitem{JSON}
RFC4627 The application/json Media Type for JavaScript Object Notation (JSON)，\\
http://tools.ietf.org/html/rfc4627.

\bibitem{TOPPERS}
TOPPERS Project，\\
http://www.toppers.jp/.

\bibitem{TECS}

Takuya Azumi, Masanari Yamamoto, Yasuo Kominami, Nobuhisa Takagi, 
Hiroshi Oyama and Hiroaki Takada, "A New Specification of Software 
Components for Embedded Systems," Proceedings of the 10th IEEE 
International Symposium on Object and Component-Oriented Real-Time 
Distributed Computing (ISORC 2007), pp.45--50, 2007.

\end{thebibliography}
\end{adjustvboxheight} % needed only when Appendix follows

\end{document}
