\chapter{はじめに}

%% 背景
近年，PC，サーバ，組込みシステム等，用途を問わずマルチプロセッサの利用
が進んでいる．その背景として，シングルプロセッサの高クロック化による性能
向上の限界や，消費電力・発熱の増大があげられる．マルチプロセッサシステム
では処理の並列性を高めることにより性能向上を実現するため，消費電力の増
加を抑えられる．組込みシステムにおいては，機械制御とGUIなど要件
の異なるサブシステム毎にプロセッサを使用する例があるなど，従来から複数
のプロセッサを用いるマルチプロセッサシステムが存在していたが，部品点数
の増加によるコスト増を招くため避けらていた．しかし，近年は，
1つのプロセッサ上に複数の実行コアを搭載したマルチコアプロセッサの登場に
より低コストで利用することが可能になり，低消費電力要件の強い，組込みシ
ステムでの利用が増加している．

マルチプロセッサ環境では，処理の並列性からプログラムの挙動が非決定的に
なり，タイミングによってプログラムの挙動が異なる．そのため，ブレークポ
イントやステップ実行を用いたシングルプロセッサ環境で用いられているデバッ
グ手法を用いることができない．

そのため，マルチプロセッサ環境では，プログラム実行履歴であるトレースロ
グの解析によるデバッグ手法が主に用いられる．トレースログを解析すること
で，各プロセスが，いつ，どのプロセッサで，どのような動作したかというプ
ログラムのデバッグに必要な情報が全て記録される．しかし，膨大な量となる
トレースログから特定の情報を探し出すのが困難である．さらに，各プロセッ
サのログが時系列に分散して記録されるため，逐次的にトレースログを解析す
ることも困難である．そのため，開発者が直接トレースログを解析するのは効
率が悪い．

トレースログの解析を支援するために，多くのトレースログ可視化ツールが開
発されている．組込みシステム向けデバッガソフトウェアや統合開発環境の一
部，Unix系OSのトレースログプロファイラなどが存在する．しかし，これら既
存のツールが扱うトレースログは，OSやデバッグハードウェアごとに異なるた
め，可視化対象が限定されおり，汎用性に乏しい．さらに，可視化表示項目が
提供されているものに限られ，追加や変更が容易ではなく，拡張性に乏しい．

そこで後藤ら\cite{goto,ipsj}によって汎用性と拡張性を備えたトレースログ
可視化ツール\textbf{TraceLogVisualizer (TLV)}が開発された．TLV内部でト
レースログを抽象的に扱えるよう，トレースログを一般化した標準形式トレー
スログを定め，任意の形式のトレースログを標準形式トレースログに変換する
仕組みを変換ルールとして形式化した．標準形式トレースログから図形データ
を生成する仕組みを抽象化し，可視化ルールとして形式化した．TLVでは，変換
ルールと可視化ルールを外部ファイルとして与えることで，汎用性と拡張性を
実現している．


本OJLでは，TLVのリリースを複数回行ない，要求の収集を行なった．
収集した要求のうち``CPUごとのタスク表示''に対する要求が強かったため，
これらの実現を行なった．
また，ユーザアプリケーションのログ出力を可視化するための機能追加を行った．
特定のフォーマットに従ったログ出力を受理し，文字列やユーザ定義状態として
可視化することで，ユーザアプリケーションの様々な出力を可視化できるように
なった．
特に，文字列の可視化は汎用性が高く，システムのメッセージや変数値の変化など
様々な出力が可能である．

また，TLVの高速化に対する要求も多かったので，第一段階として
プロファイリングによりボトルネックを調査した．
今回は標準形式トレースログへの変換部分を対象とし，
どのクラスや処理に時間がかかるかを明らかにした．

%% 構成
最後に，本報告書の構成を述べる．
2章では，TLVの設計について述べる．
3章では，TLVの開発プロセスや発表実績などについて述べる．
4章では，ユーザアプリケーションからのログ出力を可視化する
機能追加について述べる．
5章では，ボトルネックを調査したプロファイリングについて述べる．
最後に6章で本論文のまとめと今後の展望と課題について述べる．

