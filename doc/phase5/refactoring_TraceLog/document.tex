\documentclass[a4j]{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{listings}
\usepackage{here}
\newcommand{\figref}[1]{図\ref{#1}}

\lstset{language=C,%
        basicstyle=\footnotesize,%
        commentstyle=\textit,%
        classoffset=1,%
        keywordstyle=\bfseries,%
	frame=tRBl,framesep=5pt,%
	showstringspaces=false,%
        numbers=left,stepnumber=1,numberstyle=\footnotesize%
	}%


\title{組込みRTOS向けアプリケーション開発支援ツール\\
TLV（トレース ログ ヴィジュアライザー）\\
フェーズ5 リファクタリング仕様書}
\begin{document}
\maketitle
\titlepage

\section*{改訂履歴}
\begin{table}[h]
 \centering
 \begin{tabular}{|c|c|c|c|} \hline
  版番& 日付&    更新内容& 更新者\\ \hline\hline
%  1.0 & 10/4/23& 新規作成& 市原大輔\\ \hline
 \end{tabular}
\end{table}
\clearpage

\tableofcontents
\clearpage

\section{はじめに}
\subsection{本書の目的}
本書の目的は、文部科学省先導的ITスペシャリスト育成推進プログラム「OJLに
  よる最先端技術適応能力を持つIT人材育成拠点の形成」プロジェクトにおけ
る、OJL科目ソフトウェア工学実践研究の研究テーマである「組込みRTOS向けア
  プリケーション開発支援ツールの開発」に対して、その開発するソフトウェ
アに対する設計を記述することである。

本書は特に、フェーズ5におけるリファクタリング作業に関する記述を行う。

\subsection{本書の適用範囲}
本書は、組込みMPRTOS向けアプリケーション開発支援ツールの開発プロジェク
ト（以下本プロジェクト）のフェーズ5におけるリファクタリング作業に関する
記述を行う。

\subsection{用語の定義/略語の説明}

\begin{table}[h]
 \centering
 \caption{用語定義}
 \begin{tabular}{|p{8em}|p{36em}|} \hline
  用語・略語& 定義・説明\\ \hline \hline
  TLV& Trace Log Visualizer\\ \hline
  MPRTOS& マルチプロセッサ対応リアルタイムオペレーティングシステム\\
  \hline
  トレースログファイル&
      RTOSのトレースログ機能を用いて出力したトレースログや、
      シミュレータなどが出力するトレースログをファイルにしたもの\\
  \hline
  標準形式トレースログファイル&
      本ソフトウェアが扱うことの出来る形式をもつトレースログファイル。
      各種トレースログファイルは、この共通形式トレースログファイルに
      変換することにより本ソフトウェアで扱うことが出来るようになる。 \\
  \hline
  変換ルール  &
  トレースログファイルを標準形式トレースログファイルに変換する際に用いられるルール。
  \\
  \hline
  可視化ルール  &
  標準形式トレースログファイルを可視化する際に用いられるルール。
  \\
  \hline
  TLVファイル &
      本ソフトウェアが中間形式として用いるファイル。
      前述の標準形式トレースログファイルは、このTLVファイルの一部である。 \\
  \hline
  EBNF &
      Extended Backus?Naur Formの略。 \\
  \hline
　　Parsec &
  関数型言語Haskellのパーサ・コンビネータライブラリ。\\
  \hline

 \end{tabular}
\end{table}

\subsection{概要}
本書では、組込みMPRTOS向けアプリケーション開発支援ツールの
ソフトウェアの仕様を記述する。
本書は特に、フェーズ5におけるリファクタリング作業に関する記述を行う。

\part{リファクタリング概要}
\section{実施理由}
現状の\verb!TraceLog!クラス(クラス概要は\ref{sec:tl}参照)では、標準形式トレースログのパースにおいて、
Listing\ref{rex}のような複雑な正規表現を計8回適用している。これは、Objectなどの要素1つにつき1行の正規表現で
取得するためである。こうすることで、TimeやValue等の有無に関わらず
\footnote{可視化ルールファイルには、Timeがない、Valueがない、AttributeNameがない等といった
不完全な標準形式トレースログが記述されている。}
パースできるようにしている。
しかし、このような複雑な正規表現は、可読性が低く保守が難しいため、リファクタリングを実施する。

リファクタリング後のTLVは、標準形式トレースログのパースを専用のパーサに任せる。
パーサは、TLV変換ルール・可視化ルールマニュアル(rule-maual.pdf)の「2.1.2標準形式トレースログの定義」
にあるEBNFのようにコードを記述することで、構文を直感的に理解できるようになる。
コード例をListing\ref{refacted}に示す。

また、重複したコードおよび生成規則変更時の変更箇所も減らすことができるため、保守性も向上する。
例えば、Timeを囲む記号\verb!"[","]"!を\verb!"<",">"!にするとき、従来の正規表現を用いた
方法では、8行すべての正規表現を変更する必要があるが、リファクタリング後は1箇所で済むようになる。
生成規則を追加する場合でも、従来の方法では8行の正規表現の中から変更箇所を探さねばならないが、
リファクタリング後は、EBNFのように記述されているため、変更箇所が明確であるので見落としを減らせる。
しかしながら、このような構文の変更は稀であるため、一番のメリットは構文を直感的に理解できるようになる
ことである。

\begin{lstlisting}[caption=リファクタリング前のコード例,label=rex]
m = Regex.Match(_log, @"^(\[[^\]]+\])?(?<objectType>[^\[\]\(\)\.]+)\([^\)]+\)(\.[^\s]+)?$");
	if (m.Success)
		ObjectType = m.Groups["objectType"].Value;
	HasObjectType = m.Success;
\end{lstlisting}

\begin{lstlisting}[caption=リファクタリング後に表現したいコード例,label=refacted]
var object_ = 
	ObjectTypeName().Char('(').AttributeCondition().Char(')')
	.OR().
	ObjectName();
\end{lstlisting}



\section{対象}\label{sec:tl}
リファクタリング対象は、\verb!TraceLog!クラス、特にそのコンストラクタである。
この\verb!TraceLog!クラスは、標準形式トレースログを構成するトークンを保持し、
標準形式トレースログを用いた処理(可視化表示など)を容易にする。

現在、標準形式トレースログのパースに正規表現を用いている箇所を
パーサを用いるように、\verb!TraceLog!コンストラクタを変更する。


\newpage
\section{変更内容}
\subsection{クラス構成}
正規表現によるパース(\verb!Regex!クラスおよび\verb!Match!クラス)を廃止し、
標準形式トレースログ用のパーサを作成して、\verb!TraceLog!クラスはそのパーサへパース処理を委譲する。
これにより、現在はパースの実装が\verb!TraceLog!クラスに直書きされているため
パースの実装方法を変更するのが困難であるのが、
\verb!TraceLog!クラスとパースの実装を分離することでパーサの交換が容易になり、
パーサの実装方法変更が容易になる。

今回の変更に伴う影響範囲は、\verb!TraceLog!クラス以外に存在しない。
リファクタリング前後のクラス図を図\ref{bclass},\ref{aclass}に示す。

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 500]{bclass.png}
\caption{リファクタリング前のクラス構成}\label{bclass}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 500]{aclass.png}
\caption{リファクタリング後のクラス構成}\label{aclass}
\end{figure}


% \subsection{処理の流れ}
% リファクタリング前の処理の流れは、図\ref{before}のように、
% \verb!TraceLog!コンストラクタにて正規表現を用いたパースを行っている。

% リファクタリング後の処理の流れは、図\ref{after}のように、
% \verb!TraceLog!コンストラクタでパーサクラスのメソッドを呼び、
% パーサクラスにて標準形式トレースログのパースを行う。
% パースが終了したら、パーサクラスから結果を受け取り、各値を設定する。

% \begin{figure}[H]
% \centering
% \includegraphics[width=0.8\hsize,bb=0 0 660 512]{before.png}
% \caption{リファクタリング前の標準ログ変換処理}\label{before}
% \end{figure}

% \begin{figure}[H]
% \centering
% \includegraphics[width=0.8\hsize,bb=0 0 660 500]{after.png}
% \caption{リファクタリング後の標準ログ変換処理}\label{after}
% \end{figure}


\subsection{パーサの構成}\label{sec:parsec}
パーサの実装は、コードでEBNFを表現し、直感的に理解できるようにする。

例として、HaskellのパーサコンビネータライブラリParsecを参考にしたパーサ\cite{parsec}が挙げられる。
このコードを使用するか、自作など他の実装方法を用いるかは、
デバッグの容易さ、実装のしやすさ、可読性、実行速度などの要素により決定する。


\newpage
\part{詳細仕様}
本章は、Phase5で行ったリファクタリングにより変更・追加された箇所、および、
リファクタリング後のシーケンスを説明し、今回採用しなかった手法との比較や今回の実装の採用理由を記述する。


\section{コード設計}
ここでは、リファクタリングの目標であった「EBNFを表現し、直感的に理解できる」コードの紹介と、
小節にて実装に用いた手法・概念および主要メソッドの説明をする。

まず、「EBNFを表現」したコードの例をListing\ref{code1}に示す。

\begin{lstlisting}[caption=「コードでEBNFを表現」したコード例(最終更新日現在),label=code1]
var line = Char('[').Time().Char(']').Event();
...
var object_ = 
	ObjectTypeName().Char('(').AttributeCondition().Char(')')
	.OR().
	ObjectName();
...			
var typeName = Many1(() => AnyCharOtherThan('(', ')', '.'));
\end{lstlisting}


これは、次のEBNFをパースすることを示している(rule-manual.pdfの2．1.2参照)。


\begin{lstlisting}[caption=Listing\ref{code1}が表す実際のEBNF,label=ebnf1]
TraceLogLine = "[", Time, "]", Event;

Resource = ResourceTypeName, "(", AttributeCondition, ")"
	 | ResourceName;

ResourceTypeName = /[0-9a-Z_]+/;
\end{lstlisting}



このように、Listing\ref{code1}はEBNFを表現しており、正規表現によるパージングより可読性が
向上している。Listing\ref{code1}は完全なものではなく、実際にはListing\ref{code2}
のような解析メソッド内に記述され、それを組み合わせることでListing\ref{code1}を実現している。

\begin{lstlisting}[caption=解析メソッド例,label=code2]
public ITraceLogParser ObjectTypeName()
{
	Begin();

	var typeName = Many1(() => AnyCharOtherThan('(', ')', '.'));

	typeName.ObjectTypeValue = Result();
	return (ITraceLogParser)typeName.End();
}
\end{lstlisting}

\subsection{利用した概念・手法}
\subsubsection{再帰下降パーサ}
今回、実装したパーサは、スタックを利用した再帰下降パーサであり、バックトラッキングを用いている。
これは、EBNFのようにトップダウンに記述されているものを表現するのに適しているが、
バックトラッキングによる処理効率低下が懸念される。

\subsubsection{パーサ・コンビネータ}
パーサ・コンビネータとは、パーサとパーサを組み合わせることのできるコンビネータを指す。
具体的には、Manyメソッド、Many1メソッド、ORメソッドが挙げられる。
これにより、EBNFの表現やLL(k)文法のパージングを可能にしている。
しかしながら、LL(k)文法を扱うため生成規則から左再帰性の除去が必要である。

\subsubsection{NullObjectパターン}
インタフェースを実装しているが、何もしないクラスを用いるデザインパターン。
多態性を利用したもので、Nullかどうかを判別するコードを排除でき、処理の流れが明確になる。
今回、これを用いることでEBNFのような記述を実現している。
解析メソッドは、パーサクラスもしくはパーサクラス用のNullObjectを返すことで次の解析メソッドを実行するかを決定する。
すると、if分をはさまずにメソッドチェーンのみで生成規則を表現できるようになる。

他に、Nullによる問題(意図しないNull参照による例外発生など)を防止できるというメリットもある。

\subsection{基本メソッドの説明}\label{sec:ms}
\subsubsection{Beginメソッド}
解析メソッドの処理で最初に実行されるメソッド。

現在は、スタックへのパース結果およびポインタ
\footnote{パージング中の文字列の、解析の現在位置(文字)を示すもの。}
の保存領域確保を行っている。

\subsubsection{Endメソッド}
解析メソッドの処理で最後に実行されるメソッド。
基本的に、パースを実行、つまり、生成規則を表すメソッドチェーンを実行して得られた戻り値
(パーサオブジェクトまたはNullObject)から呼ばれる。

現在は、スタックのポップ、直前のスタックにあるパース結果との結合、NullObjectのステータス初期化を行っている。
パーサクラスかNullObjectクラスかで動作が変わる。

\subsubsection{Resultメソッド}
パースを実行して得られた文字列を返すメソッド。

\subsubsection{ORメソッド}
EBNFの記号\verb!"|"!を表すメソッド。生成規則を表すメソッドチェーンで使用する。

このメソッドより前の生成規則に当てはまらなかった場合、このメソッド内でバックトラッキングして、
次の生成規則の適用を試みる。

\subsubsection{Manyメソッド}
EBNFの記号\verb!"*"!を表すメソッド。生成規則を表すメソッドチェーンで使用する。

引数に与えられた解析メソッドを0回以上適用させる。

\subsubsection{Many1メソッド}
EBNFの記号\verb!"+"!を表すメソッド。生成規則を表すメソッドチェーンで使用する。

引数に与えられた解析メソッドを1回以上適用させる。


\section{クラス設計}
リファクタリング後のクラス図を図\ref{class}に示す。
\verb!TraceLog!クラス以外のクラス群が、前章の図\ref{aclass}にあるサブシステムに相当する。

パーサは、基本的な機能を備えたクラスとパース対象に特化したクラスにわけることで、
基本的な機能を備えたクラスの再利用ができるようになっている。
そのため、それに該当するParserクラスおよびNullObjectForParserクラスを
継承する派生クラスを定義し、ITraceLogParserクラスのような特化したインタフェースを定義してそれぞれの
派生クラスが実装することで、様々なパーサが作成可能である。

次に、図\ref{class}にある各クラスの簡単な説明をする。

\begin{figure}[H]
\centering
\includegraphics[width=1.\hsize,bb=0 0 728 537]{class.png}
\caption{リファクタリング後のクラス構成}\label{class}
\end{figure}

\subsection{既設クラス}
\subsubsection{TraceLogクラス}
標準形式トレースログをコード上で扱うためのクラス。

今回、そのコンストラクタをリファクタリングし、可読性の向上を行った。
また、新たに\verb!TraceLogParser!オブジェクトを保持する静的フィールドを追加し、
パーサの生成を一回で済むようにした。

\subsection{新設クラス}
\subsubsection{Parserクラス}
パーサを実現するための基本的な機能を備えたクラス。

これを継承し、解析メソッドを記述することで専用のパーサを作成する。
\ref{sec:ms}に示したメソッドの他に、アルファベットや数字の解析メソッドも有する。
これらのメソッドは、単純に継承しただけでは戻り値の型が合わず、使用できない。
よって、派生クラスに、処理を\verb!Parser!クラスに委譲し、その結果を使用するインタフェース型にキャストして\verb!return!する
同名(もしくは、それとわかる名前)のメソッドを用意して使用する。

\subsubsection{StackForParserクラス}
\verb!Parser!クラスが利用する専用スタック。

パーサが今までのパース結果やポインタを退避させるのに用いる。できるだけ効率よく管理するために用意した。

\subsubsection{InputStreamForParserクラス}
パース対象を格納し、管理するクラス。

ポインタの制御やポインタの示す文字の提供などを行う。
\verb!.NET Framework!の標準ライブラリである\verb!StringReader!クラスは、
Readメソッドで文字を消費してしまって復元が難しいため、専用のクラスを用意した。

\subsubsection{NullObjectForParserクラス}
\verb!Parser!クラスのNullObjectを実現するための基本的な機能を備えたクラス。

これを継承し、解析メソッドを含むインタフェースを実装することで、専用のパーサ用NullObjectを作成する。


\subsubsection{TraceLogParserクラス}
標準形式トレースログ用のパーサクラス。

標準形式トレースログをパースするための解析メソッドや結果を取得するためのプロパティがある。

\subsubsection{NullObjectOfTraceLogParserクラス}\label{sec:nullobj}
標準形式トレースログ用のパーサクラス用のNullObjectクラス。

メソッドは基本的に何もしないが、効率やアルゴリズム上の理由などで処理を行う場合がある。
ただし、NullObjectとしては異例なため、そのような場合は保守性が低下する恐れがある。

\subsubsection{IParserクラス}
\verb!Parser!クラスと\verb!NullObjectForParser!クラスを結ぶインタフェース。

これにより、メソッドチェーンによるEBNFのような表現を実現している。

\subsubsection{ITraceLogParserクラス}
\verb!TraceLogParser!クラスと\verb!NullObjectOfTraceLogParser!クラスを結ぶインタフェース。

これにより、メソッドチェーンによるEBNFのような表現を実現している。

\section{シーケンス}
例として、\verb!" [.]Task.state=="RUNNING" "!という誤ったログをパースする
シーケンスを、途中までだが、図\ref{sequence}に示す。解析メソッドの適用に成功すれば次の解析メソッドを試み、
失敗すれば以降の解析メソッドはNullObjectのものを呼ぶことでパーサの解析メソッドを適用しないようになっている。

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 679]{sequence.png}
\caption{パージング時のシーケンス例(途中まで)}\label{sequence}
\end{figure}

また、失敗した状態でORメソッドが呼ばれるとバックトラックし、ORメソッド以降の解析メソッドにより再度パースが行われる。
その他の状態で呼ばれた時のORメソッドの処理を図\ref{orsequence}に示す。
3つ目の場合は、例えば\verb!hoge().OR().fuga().OR().piyo()!という生成規則があった場合、
\verb!hoge()!が成功した時の\verb!fuga()!と\verb!piyo()!の間にある\verb!OR()!の挙動を
示している。

また、\verb!Reset()!がバックトラッキングの役割を果たしている。

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 518]{orsequence.png}
\caption{各状態でのORメソッドの処理}\label{orsequence}
\end{figure}


\newpage
\part{評価}
本章は、\ref{sec:parsec}で紹介した\cite{parsec}を用いたパーサ(以降、C\#版Parsec)、前章で紹介したパーサ(以降、自作パーサ)を比較し、
前章のパーサを選択した理由を記述する。
また、それら二つのパーサおよび従来のパース方法で性能比較を示す。

\section{他手法との比較}
\subsection{可読性}
まず、C\#版Parsecのコードを次に示す。
このパーサは、HaskellのParsecを模したコードになっており、例えばListing\ref{haskellcode}のように置き換えることができる。
すなわち、\ref{codeparsec}では、\verb!in!より右の解析メソッドを上から順に見たものが生成規則を表している。
しかしながら、この記述は、コード上でクエリ式を記述できるLINQを利用しているため、
初見では理解しにくいということが現在の開発メンバとのレビューで出てきた。また、
「右の解析メソッドを上から順に見たものが生成規則を表している」ことがわかったとしても、
\verb!select!が何をするのか、何が記述されているのかが理解しにくい。
そのため、Haskell経験者であればよいとは思われるが、そうでない者にとっては可読性が従来のものより低くなってしまう
可能性がある。

自作パーサは、生成規則を表す解析メソッドのチェーンがEBNFに近いため、自作パーサの方が可読性が高いというレビュー結果
が得られた。

\begin{lstlisting}[caption=\cite{parsec}を用いたパーサのコード例,label=codeparsec]
OBject = (from otn in ObjectTypeName
          from u1 in Char('(')
		  from ac in AttributeCondition
		  from u2 in Char(')')
		  select Base(otn).Append(u1).Append(ac).Append(u2).ToString())
		 .OR(
		 (from on in ObjectName
		  select Base(on).ToString()));
		  
// Baseメソッドは、引数に基づいてStringBuilderクラスを新規作成して返すメソッド
// StringBuilderクラスに関しては、.NET Framework ライブラリを参照
\end{lstlisting}

\begin{lstlisting}[caption=Listing\ref{codeparsec}をHaskellに置き換えたコード例,label=haskellcode]
OBject = do{ otn <- objectTypeName
           ; u1 <- char '('
		   ; ac <- attributeCondition
		   ; u2 <- char ')'
		   ; return otn ++ u1 ++ ac ++ u2
           }		   
		 <|>
		 do{ on <- objectName
		   ; return on
		   }
\end{lstlisting}

\subsection{保守性}
C\#版Parsecのクラス構造は、機能ごとによく分割・整理されており、また、文字列以外にも対応できるように
設計されているため汎用性が高い。
このC\#版Parsecおよびパーサを変更するには、Parsecの実装に関する知識が必要になる。
それに伴い、Haskellの知識が必要になる場合がある。
よって、チューニングまで行おうとすると、事前知識がなければ学習コストがかかってしまう。

自作パーサは、文字列のパージングに特化したものであり、文字列化できないもののパージングはほぼ不可能に近い。
しかしながら、TLVで用いる場合、文字列以外は現状では考えられないため、あまり問題にならない。
変更の際のコストに関しては、自作パーサでも、NullObjectとの連携や解析メソッドのチェーンの理解に学習コストがかかる。

\subsection{デバッグの容易性}
C\#版Parsecは、かなりの割合をデリゲートが占める。そのため、デバッガによるステップ実行では、どのデリゲートが
適用されているのかがわかりづらく、結果、処理の流れが把握しづらいため難しい。また、流れ自体も実装と関わっているため
やはりParsecなどの知識が必要となる。

自作パーサは、コードを見るよりもデバッガによるステップ実行を行った方が分かりやすい。
特に、取得したいパース結果の格納時の、次のコードの※1、2である。

\begin{lstlisting}
var object_ =
	ObjectTypeName().Char('(').AttributeCondition().Char(')')
	.OR().
	ObjectName();

object_.ObjectValue = Result();    // ※1

// HasObjectTypeValueは、ObjectTypeName()が真でも、ほかで失敗すれば偽である。
object_.HasObjectTypeValue = false;  // ※2
\end{lstlisting}

例えばこの2行は、\verb!object_!が何を指すのかを推測して理解・記述する必要がある。
デバッガによるステップ実行を行うことで、\verb!object_!が明確となり、処理が間違っていないか確認できる。
また、C\#版Parsecのようにデリゲートを多用しておらず、使用していてもシンプルなシーケンスであるため、
どのメソッドまたはデリゲートを適用させているのかがC\#版Parsecより把握しやすい。

\subsection{性能比較}


\begin{thebibliography}{9}
\bibitem{parsec}
LukeH's WebLog : Monadic Parser Combinators using C\# 3.0,\\
URL:\\
http://blogs.msdn.com/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
\end{thebibliography}
\end{document}
