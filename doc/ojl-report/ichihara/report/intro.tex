\chapter{はじめに}

%% 背景
近年，プロセッサにおけるクロック周波数が実質上限に達し，これ以上の
高速化は難しくなってきた．また，高クロックによる高消費電力，高発熱
により，バッテリの消費速度やマシンへの影響も懸念される．そこで，
マルチプロセッサシステム
による処理の並列化により，1つ1つのプロセッサのクロック周波数を抑え，
消費電力や発熱を抑えつつ，処理の高速化を実現する動きが活発になっている．

こうしたマルチコアプロセッサが代表するマルチプロセッサ環境では，処理の
並列性からプログラムの挙動が非決定的に
なり，プログラムの挙動が実行する毎に異なる．そのため，ブレークポ
イントやステップ実行を用いたシングルプロセッサ環境で用いられているデバッ
グ手法を用いることができない．

このような理由から，マルチプロセッサ環境では，プログラム実行履歴であるトレースロ
グの解析を解析することでデバッグを行う．しかしながら，トレースログは
量が膨大な上に，マルチプロセッサ環境ではプロセッサ毎にログが分散し，
そのテキストを直接目で追うなどしてデバッグを行うのは困難である．

この解析作業を支援するために，トレースログを可視化するツールが開発された．
しかしながら，このツールは，デバッグのターゲットとなるシステム毎に用意される事が多く，
ターゲットシステムに対する汎用性に乏しい．
また，可視化する情報や方法がツールで限定されてしまい，ユーザが望む
情報の可視化を実現することが難しく，拡張性に乏しい．

これらを解決すべく，OJL(On the Job Learning)\cite{itsp,ojl}の開発テーマとして
OJL1期生により，
トレースログ可視化ツール\textbf{TraceLogVisualizer (TLV)}が開発された．
TLVは，汎用性を実現するために，入力されたトレースログを自身が可視化処理で
扱う形式のトレースログへ変換する仕組みがある．また，拡張性を実現するために，
可視化の際に用いられる図形データをユーザが定義できる仕組みがある．
これらの仕組みを形式化したのが，変換ルール，可視化ルールである．

このTLVの開発は，OJL2期生，3期生，4期生と続けて行われている．
OJL2期生は，OJL1期生が作り上げたTLVに対する単体テストとシステムテストを実施し，
問題解決を行った．また，ユーザから要求を収集し，
複雑な処理を実現するスクリプト拡張機能と，アプリケーションが出力したメッセージを
トレースログと同様に可視化するアプリログ機能を追加した．
その後，TLV1.1が一般向けに公開された．

%%自分のことここから
そしてOJL3期生である筆者は，TLVに対する要求に対応した．収集した要求のうち，``CPU利用率な
どの統計情報のグラフ表示''と``TLVの高速化''に対する要求が強かったので，これ
らの実現を試みた．

トレースログの解析において、あるイベントが何回行われたのか，
ある状態がどれほど続いたのか，といったトレースログの統計情報が必要になる．
TLVでは，トレースログの時系列情報を扱うツールであり，こうした統計情報は，
手作業や独自に開発したスクリプトなどで得る必要がある．手作業で行う場合，
トレースログを可視化したとしてもコストがかかり，また，見落としなどで
正確性に欠ける．さらに，得た統計情報をグラフ化するためにグラフ作成ツールを
使用する必要があり，解析作業が非効率である．

こういった背景から，``CPU利用率などの統計情報のグラフ表示''する機能が求められた．
これを実現するため，統計情報の生成とそれをグラフ表示する仕組みとして，
新たに統計情報の生成とグラフの設定を行うルールを追加し，グラフを描画する
ウィンドウを実装した．統計情報の生成方法を複数用意することで，様々なユースケース，様々
な統計情報に対応した．


また，TLVの保守に支障をきたすコードのリファクタリングを行った．対象コー
ドは，複雑な正規表現である．それをパーサ・コンビネータという技法を用いて
作成したパーサでリファクタリングを行った結果，可読性の向上の他に，微少な
がら高速化に成功した．

%% 構成
最後に，本報告書の構成を述べる．\\
2章では，TLVの設計について述べる．\\
3章では，ユーザから得られたTLVに対する要求について述べる．\\
4章では，統計情報を生成してグラフ表示する機能について述べる．\\
5章では，高速化と保守性向上のためのリファクタリングについて述べる．\\
6章では，第3期OJLにおける筆者の実績について述べる．\\
最後に7章で所感と本報告書のまとめ，今後の課題について述べる．\\

