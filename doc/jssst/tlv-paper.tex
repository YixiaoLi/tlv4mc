% Sample file for the use of compsoft style file.
%
\documentclass[tokushusoftwareronbun]{compsoft}
%
% optional argument としては
%       ronbun, Eronbun, softwareronbun, tutorial, kaisetsu, topics, 
%       softwareshokai, forum, zadankai, bookreview, pioneer, memoriam,
%       tokushuronbun, Etokushuronbun, tokushusoftwareronbun, 
%       tokushututorial, tokushukaisetsu, 
%       tokushutopics, tokushusoftwareshokai,
%       suisenronbun, Esuisenronbun, 
%       kantogen, tokushutobira, gakkaikiji, henshu
% などがある．default は ronbun になっている.
%
% 英語論文の場合は Eronbun, Etokushuronbun（特集号の場合）, 
% Esuisenronbun（ワークショップ推薦論文の場合）を選択する．
%
% tokushuronbun, Etokushuronbun, tokushusoftwareronbun,
% tokushututorial, tokushukaisetsu, tokushutobira, 
% suisenronbun, Esuisenronbun を optionとして選んだとき
% には，preambleの中で
%       \def\tokushutitle{...} または  \def\suisentitle{...}
% のようにして特集名またはワークショップ名を定義する．
%
% アブストラクトは，日本語の論文／解説／チュートリアルの場合は和文と英文
% の双方をつける．英語論文の場合は英文 (\Eabstract) だけでよい．
%
% 巻数，号数，page もpreambleの中でsetcounterすること．
% これらの番号は印刷所で最終調整される．
% 
% Preamble
\setcounter{巻数}{16}
\setcounter{号数}{5}
\setcounter{page}{1}

\usepackage[dvips]{graphics}

% ユーザが定義したマクロなどはここに置く．ただし学会誌のスタイルの
% 再定義は原則として避けること．
\usepackage{here}
\usepackage{morefloats}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage{mymacros}

\begin{document}
\title{トレースログ可視化ツール \\ TraceLogVisualizer(TLV)}
%
% 和文論文の場合，姓と名の間には半角スペースを入れ，
% 複数の著者の間は全角スペースで区切る
%
\author{後藤 隼弐　本田 晋也　長尾 卓哉　高田 広章%
%
% ここにタイトル英訳（英文の場合は和訳）を書く．
%
\thanks{Visualization Tool for Trace Log. TraceLogVisualizer (TLV)}
%
% ここに著者英文表記(英文の場合は和文表記）および所属(和文および英文) を書く．
% 複数著者の所属はまとめてよい．
%
\thanks{Junji Goto, 名古屋大学大学院情報科学研究科 現在 ソニー株式会社, 
Graduate School of Information Science, Nagoya University. Presently 
with Sony Corporation.}
\thanks{Hiroaki Takada, 名古屋大学大学院情報科学研究科, 
Graduate School of Information Science, Nagoya University.}
\thanks{Shinya Honda, Takuya Nagao, 名古屋大学大学院情報科学研究科 附属組込みシステム研究センター,
Center for Embedded Computing Systems,
Graduate School of Information Science, Nagoya University
}
%
% 以下は出典情報．ページ番号は印刷所で入れます．
% 1行で収めるために文字間隔を少し詰めている．
%
\thanks{}
%
% 記事カテゴリと受付日．不明の場合はxxxx年yy月zz日などでよい．
%
\thanks{[ソフトウェア論文] xx年x月xx日受付.}}
%
% 和文アブストラクト
\Jabstract{%
マルチプロセッサ環境で動作するソフトウェアのデバッグには，トレースログの
解析が有効であるが，開発者がトレースログを直接扱うのは非効率的である．そ
のため，トレースログを可視化することにより解析を支援するツールが存在する
が，これらは汎用性や拡張性に乏しいという問題がある．そこで我々は，これら
の問題を解決したトレースログ可視化ツール(TLV)を開発した．TLVは，変換ルー
ルによりトレースログを標準形式に変換することで汎用性を実現し，可視化ルー
ルにより可視化表示項目の追加・変更を可能にすることで拡張性を実現している．
TLVを用いて形式の異なる3種類のトレースログを可視化し，汎用性と拡張性を確
認した．
}
%
% 英文アブストラクト（本サンプルの原論文にはなし）
\Eabstract{
It is effective to debug software executed in multi processors by 
analyzing a trace log, but it is inefficient that developers analyze the 
trace log directly. Therefore, some visualization tools for the trace 
log had been developed before now, but there are two problems, lacks of 
general versatility and expandability. To that end, we developed 
TraceLogVisualizer(TLV), a visualization tool for the trace log that 
solved those problems. In this paper, we will discuss requirements to 
achieve general versatility and expandability, and how we achieved them.
}
%
\maketitle

\section{はじめに}
\label{sec1}

近年，組込みシステムにおいても，マルチプロセッサの利用が進んでいる．その
背景には，シングルプロセッサの高クロック化による性能向上効果の限界や，消
費電力の増大がある．マルチプロセッサシステムでは，処理の並列性を高めるこ
とにより性能向上を実現するため，消費電力の増加を抑えることができる．しか
し，マルチプロセッサ環境で動作するソフトウェアのデバッグを行うのは，シン
グルプロセッサ環境に比べ困難であるという問題がある．これは，各プロセッサ
が非同期的に並列動作するため，タイミングに依存した再現性の低いバグが発生
する可能性があることや，ハードウェアの制約からプロセッサ間の同期精度が低
い場合があり，ブレークポイントやステップ実行を用いた従来のデバッグ手法が
有効ではない場合があるからである．

一方，マルチプロセッサ環境で有効なデバッグ手法として，プログラム実行履歴
であるトレースログを解析する手法が挙げられる．この手法が有効である理由は，
並列プログラムのデバッグを行う際に必要な情報である，プロセスが，いつ，ど
のプロセッサで，どのように動作していたかを知ることができるからである．し
かしながら，開発者がトレースログを直接解析するのは効率が悪い．図
\ref{traceLogSample}に，マルチプロセッサ対応のRTOSである，TOPPERS/FMPカ
ーネル(以下，FMPカーネル)\cite{FMP}が2プロセッサで動作した場合のトレース
ログの例を示す．約430$\mu$sの間に5行のトレースログが出力されており，トレ
ースログを収集する時間が長くなれば膨大な量になることを示唆している．取得
する情報の粒度を細かくしたり，処理の複雑さが増すと，出力されるトレースロ
グの量はさらに増大するため，デバッグを行う際に必要な情報を探し出すのが困
難となる．また，各プロセッサのトレースログは時系列に分散して記録されてい
るため，プロセッサ毎の動作を解析するのが困難である．

\begin{EBNFFileWithExample}{2プロセッサ上で動作するTOPPERS/FMPカーネルが出力するトレースログの例}
      {traceLogSample}
      {{\tt \ [}{\it time($\mu$s)}{\tt ]:[}{\it core\_id}{\tt ]: }{\it information}}
      {A sample of trace log dumped by RTOS running on dual-core}
1 [60692484]:[1]: task 4 becomes WAITING.
2 [60692586]:[2]: leave to sns_ctx state=0.
3 [60692708]:[1]: dispatch from task 4.
4 [60692798]:[2]: enter to get_pid p_prcid=304.
5 [60692914]:[1]: dispatch to task 1.
\end{EBNFFileWithExample}

トレースログの解析を支援する方法として，ツールによるトレースログの可視化
があり，これまでに幾つかのツールが開発されている．具体的には，組込みシス
テム向けデバッガソフトウェアや統合開発環境の一部
\cite{PARTNER-JET,watchpoint,QNXMomentics,eBinder}やUnix系OSのトレースロ
グプロファイラ\cite{LTTV,Chime}などが存在する．しかしながら，これら既存
のツールは，特定の環境(OSやデバッグハードウェア)を対象としているため，可
視化対象となるトレースログの形式が固定されている．そのため，他の環境が出
力するトレースログを可視化することができず，汎用性に乏しいという問題があ
る．また，可視化表示する項目やその表現方法が固定である場合が多く，拡張性
に乏しいという問題もある．

そこで我々は，これらの問題を解決し，汎用性と拡張性を備えたトレースログ可
視化ツールを開発することを目的とし，TraceLogVisualizer(TLV)を開発した．
TLVは，「OJL による最先端技術適応能力を持つIT人材育成拠点の形成」
\cite{OJL_URL}\cite{OJL_PAPER}のOJL(On the Job Learning)の開発テーマとし
て開発し，オープンソースソフトウェアとして公開している\cite{TLV}．

開発にあたり，我々は，まず，TLV内部でトレースログを一般的に扱えるよう，
トレースログを一般化した標準形式を定めた．さらに，任意の形式のトレースロ
グを標準形式に変換するためのルールを変換ルールとして形式化し，ユーザがツ
ールの外部から指定できる仕組みを提供した．次に，トレースログの可視化表示
項目やその表現方法を指示する仕組みの抽象化を行い，可視化ルールとして形式
化した．また，可視化ルールをユーザが外部から指定できる仕組みを提供した．
これにより，TLVでは，トレースログの形式毎に変換ルールと可視化ルールを外
部ファイルとして用意することで可視化が可能であり，汎用性と拡張性を実現し
ている．

本論文は次のように構成される．まず，2章で既存のトレースログ可視化ツール
とその問題点について述べる．3章では，汎用性と拡張性を実現するためのトレ
ースログ可視化ツールの要件と，TLVでの実現方針について述べる．4章では，要
件と実現方針に基づくTLVの設計について述べ，5章では，その実装について述べ
る．6章ではTLVのユーザーインタフェースについて述べ，7章では，複数のトレ
ースログの可視化表示や，可視化表示項目の変更，追加を行い，TLVの汎用性と
拡張性を示す．最後に，8章でまとめと今後の課題，展望を述べる．

\section{既存のトレースログ可視化ツールと問題点}

\subsection{既存のトレースログ可視化ツール}

\label{sec:previous}既存のトレースログ可視化表示ツールとしては，組込みシ
ステム向けデバッガソフトウェアや統合開発環境の一部，Unix系OSの可視化ツー
ル，VCD形式の可視化ツールなどがある．

組込みシステム向けデバッガソフトウェアには，トレースログを可視化する機能
を持つものがある．PARTNER\cite{PARTNER-JET}はイベントトラッカー，
WatchPoint\cite{watchpoint}はOSアナライザというトレースログを可視化する
機能を提供している．
%
%これら組込みシステム向けデバッガソフトウェアの一機能としての可視化ツール
%は，その性質からターゲットとなるOSやプロセッサが限定される．これは，組込
%みシステム向けデバッガは，通常，ターゲットとなるプロセッサが限られており，
%デバッガソフトウェアが対応するOSも限られているからである．また，可視化表
%示したい情報も提供されているものに限られるなど，可視化ツールとしては汎用
%性，拡張性に乏しい．
%
%\subsection{組込みOS向けの統合開発環境}
%
また，組込みOS向けの統合開発環境にもOSのトレースログを可視化するツールが
含まれている．QNX用の統合開発環境であるQNX MomenticsにはQNX System 
Profiler\cite{QNXMomentics}が，T-Kernel用の統合開発環境である
eBinder\cite{eBinder}にはEvenTrekが付属しており，システムコール，タスク
スイッチ，タスク状態遷移などを可視化可能である．

%このように，商用の組込みOS向けの統合開発環境にはOSの実行履歴を可視化表示
%する機能が搭載されている場合がある．しかしながら，これらは，各ベンダーが
%自社OSの競争力を高めるために提供しているものであり，当然ながら可視化表示
%に対応するOSは自社提供のものに限られている．また，可視化表示する情報も提
%供するものに限られており，表示のカスタマイズ機能もそれほど自由度は高くは
%ない．

%\subsection{Unix系OSのトレースログプロファイラ}

Unix系OSでは，パフォーマンスチューニングや障害解析を目的として，カーネル
の実行トレースを取得して，可視化するソフトウェアがいくつか開発されている．
Linuxの実行トレースを取得するLTTng\cite{LTTng}には，LTTV\cite{LTTV}が，
Solarisの実行トレースを取得するDtrace\cite{Dtrace}には，Chime\cite{Chime}
が可視化ツールとして提供されている．

%これらの可視化ツールは，サポートするOSがのログ形式をのみをサポートするこ
%とや，可視化表示する項目やその表現方法が固定である．


%\subsection{波形表示ツールの流用}

%任意のOS，アプリケーションのトレースログを可視化表示する手段として，波形
%表示ツールを流用する方法がある．波形表示ツールとは，Verilog等のデジタル
%回路設計用論理シミュレータの実行ログを波形で表示するソフトウェアのことを
%指す．

また，デジタル回路設計用論理シミュレータ用に，VCD(Value Change Dump)形式
というオープンなトレースログの形式が存在する．VCD形式を可視化するツール
として，GTKWaveが存在する．

\subsection{既存のトレースログ可視化ツールの問題点}

1点目の問題として，扱えるトレースログの形式が限定されていることが挙げら
れる．これは，既存のトレースログ可視化ツールの多くは，可視化ツールとして
単体で存在しているわけではなく，開発環境やトレースログを出力するソフトウ
ェアの一部として提供されているためである．

一方，任意の形式のトレースログをVCD形式に変換することにより，GTKWave等の
VCDに対応した可視化ツールを利用できる．図\ref{fig:GTKWave}に，RTOSのトレ
ースログをVCD形式に変換して，GTKWaveで可視化したスクリーンショットを示す．
VCD形式はデジタル回路設計用の形式であるため，表示能力に乏しく，複雑な可
視化表現は不可能である．

\begin{figure}[tb]
\begin{center}
\scalebox{0.35}{\includegraphics{img/GTKWave_fdmp.eps}}
\caption{GTKWaveによるRTOSのトレースログの可視化}
\label{fig:GTKWave}
\end{center}
\end{figure}


扱うトレースログの形式を制限しないためには，VCD形式のようにトレースログ
可視化ツール用に標準化されたトレースログ形式を定める必要がある．しかしな
がら，現状，公表されているものではそのようなものは確認できていない．

2点目の問題として，既存のトレースログ可視化ツールは，可視化表示の項目や
形式が，提供されているものに限られているということが挙げられる．可視化表
示の項目を追加，変更したり，可視化表現をカスタマイズする機能を持つツール
は確認できていない．


\section{要件と実現方針}
\label{sec2}

本章では，トレースログ可視化ツールが汎用性と拡張性を備えるための要件と，
TLVでの実現方針についてそれぞれ説明する．

\subsection{要件}
\label{requirement}

まず，トレースログ可視化ツールの定義，ならびにその汎用性と拡張性の要件を
明確にする．

トレースログ可視化ツールを，時系列に記録されたプログラムの実行履歴をテキ
スト形式でファイル化したトレースログファイルを読み込み，その内容をGUIを
通じて時系列に可視化表示するツールとする．

可視化表示項目とは，トレースログの内容や出力元の環境，解析の目的などに基
づき区分される可視化表示する情報の単位である．具体的には，RTOSのトレース
ログの場合，``タスクの状態遷移''や``システムコール呼び出し''などが該当す
る．

汎用性は，ユーザがツールのバイナリを変更することなく，様々な形式のトレー
スログを可視化表示できることとする．すなわち，入力するトレースログの形式
を制限しない．

拡張性は，ユーザがツールのバイナリを変更することなく，容易に可視化表示項
目の追加・変更・削除ができることとする．


\subsection{汎用性の実現方針}
\label{versatillity_policy}

汎用性を実現するために，トレースログの標準形式を定め，可視化表示の仕組み
が標準形式にのみ依存するようにする．そして，任意の形式のトレースログを，
標準形式に変換するためのルールを変換ルールとして形式化し，ユーザが外部か
ら指定できる仕組みを提供する．

トレースログ可視化ツールが汎用性を実現するためには，可視化表示の仕組みが
特定のトレースログの形式に依存しないようにしなければならない．そのため，
様々なトレースログ形式を一般化したトレースログ形式を定め，トレースログ可
視化ツールはこの形式を扱うこととする．一般化したトレースログの形式を標準
形式と呼ぶ．

%標準形式への変換の議論
標準形式への変換は，逐次的なテキストの置き換えといった，単純なテキスト処
理では要件を満たせない場合がある．
%
例として，図\ref{fig:log_ASP}に示す，ITRON仕様\cite{ITRON4}のRTOSである
TOPPERS/ASPカーネル(以下，ASPカーネル)\cite{ASP}のトレースログを標準形式
に変換する場合を考える．このログは，1行目で実行状態(RUUNABLE)のタスクが
act\_tsk()というシステムコールで，タスクID(tskid)が1のタスクを起動する．
2行目で起動されたタスクIDが1のタスクの状態が実行可能状態(READY)となる．
次に，タスクIDが1のタスクは，実行状態のタスクより優先度が高いため，3行目
でディスパッチが発生する．

%1行目と2行目は変換元と標準形式が1対1に対応するので，逐次的なテキストの置
%き換えで変換可能である．

3行目には，実行状態(RUUNABLE)のタスクの状態が実行可能状態(READY)となり，
代わりに，タスクIDが1のタスクの状態が実行状態(RUUNABLE)となったという情
報が暗に含まれている．ASPカーネルがこのログを出力しないのは，トレースロ
グを出力するコストを減らすためである．
%
一方，標準形式のトレースログでは，可視化のために，タスク状態の変更箇所を
明確に出力する必要がある．
%
その際，実行状態(RUUNABLE)のタスクが存在しないケースもあるため
\footnote{実行中のタスクが存在しない状態で，ハンドラからタスクが起動され
た場合．}，標準形式に変換する際には，この時点で実行状態であるタスクが存
在するかどうか，また，存在する場合はどのタスクであるのか，という情報が必
要となる．そのため，これらの情報を，変換元のトレースログファイルの内容か
ら判断する必要がある．

このように，標準形式への変換処理においては，変換元のトレースログが暗に含
む情報を出力するため，それを出力する条件の制御，また条件を制御するために
必要な情報を取得する手段が必要である．


\begin{EBNFFile}{TOPPERS/ASPカーネルのトレースログの例}{fig:log_ASP}{aspLogSample}
1 [1000]enter to act_tsk tskid=1
2 [1005]task 1 becomes READY
3 [1010]dispatch to task 1.
\end{EBNFFile}


\subsection{拡張性の実現方針}
\label{extendability_policy}

拡張性を実現するためには，汎用的な可視化表示の仕組みを提供し，ユーザが可
視化表示項目に合わせてそれを制御できればよい．つまり，可視化表示項目毎に
可視化表示の仕組みを用意するのではなく，汎用的な可視化表示の仕組みに対し
て，可視化表示項目を実現するパラメータを指定することで可視化表示を行う．
そして，ユーザがツールの外部からパラメータを指定する手段を実現すればよい．
その際，汎用性の実現のため，可視化表示の仕組みは，標準形式のトレースログ
にのみ依存するようにしなければならない．また，指定するパラメータは，描画
処理に必要なGUIフレームワークや表示デバイスに依存しないことが要求される．
これは，プログラムの可搬性を損なわないためである．

汎用的な可視化表示の仕組みを実現するために，まず，トレースログの内容から
可視化表現を決定して表示するまでの流れを抽象化し，本質的な処理を洗い出す．
次に，ユーザが，どの処理に，どのようなパラメータを指定できればよいかを判
断し，可視化ルールとして形式化する．そして，ユーザがツールの外部から可視
化ルールを指定できる仕組みを提供する．

\section{設計}
\label{sec3}

本章では，汎用性を実現するための標準形式と変換ルールと，拡張性を実現する
ための可視化表示の仕組みと可視化ルールの設計について説明する．

\subsection{標準形式}
\label{sub:standartFormat}

トレースログを一般化するため，RTOSやUnix系OS，プロセッサシミュレータなど
のトレースログの形式の調査を行った．その結果から，次のようにトレースログ
を一般化した．

トレースログは，時系列にイベントを記録したものとした．イベントとはイベン
ト発生源の事象であり，イベント発生源の``属性の変化''，または``振る舞い''
とした．ここで，イベント発生源をリソースと呼称し，固有の識別子として名前
を持つとした．つまり，リソースとは，イベントの発生源であり，名前を持ち，
固有の属性を持つ．固有の属性としては，``属性''と``振る舞い''があり，型に
より定義される．型は，リソースタイプと呼称して固有の識別子として名前をも
つとした．属性は，リソースが固有にもつ文字列，数値，真偽値で表されるスカ
ラーデータとし，振る舞いは，リソースの行為であるとする．それぞれは固有の
識別子として名前をもつ．

例として，RTOSが出力する，「TASK1という名前のタスクの状態が実行状態に遷
移した」という情報のトレースログを，一般化した方法で考えてみる．この場合，
TASK1がリソースであり，タスクがリソースタイプである．また，タスクの状態
は属性にあたり，その属性が実行状態という値に変化したというイベントである
と言える．また，「TASK1という名前のタスクがセマフォを取得するシステムコ
ールを呼び出した」という情報のトレースログでは，``システムコール呼び出し
''が振る舞いとなる．

図\ref{standartFormat}に，一般化の結果を形式化したトレースログの標準形式
の定義を示す．定義には，EBNF(Extended Backus Naur Form)，および終端記
号として正規表現を用いている．正規表現はスラッシュ記号({\tt /})で挟み
記述している．

\begin{EBNFFile}{標準形式の定義}{standartFormat}{A definition of the standard format}
1 TraceLog = { TraceLogLine,"\n" };
2 TraceLogLine = "[",Time,"]",Event;
3 Time = /[0-9a-zA-Z]+/;
4 Event = Res,".",(AttrChange|BhvrHappen);
5 Res = ResName|ResTypeName,"(",AttrCond,")";
6 ResName = Name;
7 ResTypeName = Name;
8 AttrCond = BoolExp;
9 BoolExp = Bool|CompExp
10    |BoolExp,[{LogclOpe,BoolExp}]
11    |"(",BoolExp,")";
12 CompExp = AttrName,CompOpe,Value;
13 Bool = "true"|"false";
14 LogclOpe = "&&"|"||";
15 CompOpe = "=="|"!="|"<"|">"|"<="|">=";
16 AttrName = Name;
17 AttrChange = AttrName,"=",Value;
18 Value = /[^"\\]+/;
19 BhvrHappen =  BhvrName,"(",Args,")";
20 BhvrName = Name;
21 Args = [{Arg,[","]}];
22 Arg = /[^"\\]*/;
23 Name = /[0-9a-zA-Z_]+/;
\end{EBNFFile}

トレースログが記録されたファイルのデータを TraceLog，TraceLog を改行記号
で区切った１行を TraceLogLine とする．TraceLogLine は``['',``]''で時刻を
囲み，その後ろにイベント(Event)を記述するものとする．
%
時刻はTime として定義され，数値とアルファベットで構成される．アルファベ
ットが含まれるのは，10 進数以外の時刻を表現できるようにするためである．
これは，時刻の単位として「秒」以外のもの，たとえば「実行命令数」などを表
現できるように考慮したためである．この定義から，時刻には，2 進数から36 
進数までを指定できる．

イベント(Event)は，リソース(Res)と，属性の値の変化イベント
(AttributeChange)もしくは，振る舞いイベント(BehaviorHappen)をドッド``.''
で繋げることで，どのリソースの属性の値の変化もしくは振る舞いのイベントが
発生したかを表す．

リソースの記述方法(5行目)は，リソースの名前({\tt ResName})による直接指定
か，リソースタイプの名前と属性の条件({\tt ResTypeName(AttrCond)})による
条件指定の2通りの方法で指定できるとした．条件指定では，リソースタイプと
リソースの属性の値から，特定のリソース，または複数のリソースを表現するこ
とができる（8〜15行目）．条件指定は，\ref{versatillity_policy}節で述べた，
変換元のトレースログが暗に含む情報の表現を可能にするため導入した．

属性の値の変化イベント(17行目)と振る舞いのイベント(19行目)の記述方法は，
JavaやC++などのオブジェクト指向言語における，メンバ変数への代入と，メソ
ッドの呼び出しの記法と同様である．

\subsubsection{標準形式の例}
\label{sub:standartFormat_exp}

図\ref{fig:log_ASP}のASPカーネルトレースログを標準形式とした例を図
\ref{standartFormatTraceLogSample}に示す．タスクIDが1のタスクはTASK1とい
う名前のリソースとする\footnote{図\ref{standartFormatTraceLogSample}標準
形式は変換ルールによる変換結果ではなく，標準形式の説明のための人手による
変換結果である．}．

1行目が振る舞いのイベントであり，2〜4行目が属性の値の変化イベントである．
%
1行目は，実行状態(RUNNING)のリソースが{\tt leaveSVC}という振る舞いを，
{\tt act\_tsk}と{\tt tskid=1}を引数として発生したことを表現している．2〜
3行目は各リソースの属性であるタスク状態({\tt state})の値が変化したことを
表現している．
%
2行目と4行目はリソースを名前で直接指定している．一方，1行目と3行目はリソ
ースタイプの名前(TASK)と属性の条件(state==RUNNING)によってリソースを指定
しており，それぞれ，その時点でリソースタイプの名前が{\tt TASK}のリソース
のうち，属性のタスク状態({\tt state})が実行状態(RUNNING)であるリソースを
指定している．

\begin{EBNFFile}{図\ref{fig:log_ASP}のASPカーネルのトレースログの標準形
 式による表現}{standartFormatTraceLogSample}{A sample of a standard format trace log}
[1000]TASK(state==RUNNING).enterSVC(act_tsk, tskid=1)
[1005]TASK1.state=READY
[1010]TASK(state==RUNNING).state=READY
[1010]TASK1.state=RUNNING
\end{EBNFFile}

\subsection{変換ルール}
\label{sub:conv_rule}

変換ルールは，任意の形式のトレースログを，標準形式トレースログに変換する
ためのルールであり，これらの対応関係を定義したものである．具体的には，変
換対象となる変換元のトレースログを正規表現として記述し，その正規表現にマ
ッチした場合に標準形式のトレースログに出力する内容を指定したルールの集合
である．標準形式への変換は，変換ルールに基づき，テキストの変換処理を行う
処理である．

標準形式への変換処理に，awkなどの既存のテキスト処理用スクリプト言語を使
用する方法がある．しかしながら，\ref{versatillity_policy}節で述べたよう
に，変換元のトレースログが暗に含む情報を出力するために，リソースの属性の
初期値や型などの情報を参照したり，リソース毎に属性の値の遷移を監視する必
要があるため，実用的ではない．

そこで，TLVでは，出力する条件の制御を，指定された時刻での特定リソースの
有無や数や属性の値，属性値変更イベントであれば変更後の値を，振る舞いイベ
ントであればその引数などを用いて論理式を記述することで行う．論理式の記述
は，それらの値を取得できる置換マクロを用いて行い，その際の記法には標準形
式を用いる．

変換ルールを\ref{versatillity_policy}節で述べた，図\ref{fig:log_ASP}の3
行目の「あるタスクにディスパッチした」というトレースログを標準形式に変換
する例で説明する．出力したい標準形式のトレースログは図
\ref{standartFormatTraceLogSample}の3〜4行目である．4行目はディスパッチ
先のタスクを実行状態(RUNNING)とすればよいため，単純な置換で実現可能であ
る．3行目は，置換マクロを用いて，実行状態(RUNNING)のタスクが存在するかチ
ェックして，存在すれば，そのタスクの状態が実行可能状態(READY)となったこ
とを標準形式のトレースログとして生成する．

\subsection{可視化表示の仕組み}
\label{sub:visualize_rule}

\ref{extendability_policy}節の方針に従い，トレースログの内容から可視化表
現を決定して表示するまでの流れを抽象化し，可視化表示の仕組みとして本質的
な処理を洗い出す．そして，ユーザが，どの処理に，どのようなパラメータを指
定すればよいかを判断する．

\subsubsection{可視化表示の抽象化}

トレースログ可視化ツールにおいて，可視化表示とは，可視化表示項目毎に要求
される表現(以下，可視化表現)を，トレースログの内容に従い時系列の図として
画面に描画する処理であると考えられる．ここで，画面への描画は，GUIフレー
ムワークに依存するため，可視化表示の仕組みとしては本質的ではない．そのた
め，可視化表示の仕組みは，可視化表現を，時間と高さを次元にもつ仮想的な座
標に割り当てる処理であると抽象化できる．ここで，可視化表現は，複数の図形
で構成されるものとする．図\ref{visualizing}に，抽象的な可視化表示の仕組
みを示す．

図形は，楕円や四角などの複数の基本図形で構成されていると考えることができ
る．このとき，図形を定義する座標系をローカル座標系と呼称する．
%
次に，図形をトレースログの内容に従い配置する座標である，時間と高さを次元
にもつ仮想的な座標をワールド座標系と呼称する．
%
ワールド座標系へ割り当てられた図形は，表示開始時刻と単位時間あたりのピク
セル数により表示デバイスに表示される．このとき，表示先の座標系をデバイス
座標系と呼称する．単位時間あたりに，何ピクセル数でワールド座標系をデバイ
ス座標系に割り当てるかという処理が，表示上の拡大，縮小の処理となる．

\begin{figure}[tb]
\begin{center}
\scalebox{0.45}{\includegraphics{img/visualizing.eps}}
\caption{抽象的な可視化表示の仕組み}
\label{visualizing}
\end{center}
\end{figure}

以上の可視化表示の仕組みの抽象化から，ユーザが任意の可視化表示項目を実現
するために，汎用的な可視化表示の仕組みに対して与える指示としては，どのよ
うな図形を，どの時間領域に割り当てるかということであると考えられる．

時間領域の開始時刻と終了時刻は，イベントを用いて指定することとした．つま
り，指定されたイベントが発生する時刻をトレースログより抽出することにより
表示期間を決定する．このようにして，トレースログのイベントと可視化表現を
対応付ける．ここで，開始時刻に対応するイベントを開始イベント，終了時刻に
対応するイベントを終了イベントと呼称し，表示期間をイベントで表現したもの
をイベント期間と呼称する．


\subsubsection{図形の定義と可視化ルール}

図形は楕円，多角形，四角形，線分，矢印，扇形，文字列の7種類を用意する．
図形は，形状や大きさ，位置，塗りつぶしの色，線の色，線種，透明度などの属
性を指示することができる．

どの図形をどの時間領域に割り当てるか，つまり，図形をワールド座標系のどの
領域に割り当てるかの指示は，割り当て先の領域に対して一般的でなければなら
ない．つまり，割り当て先の個々の領域をすべて指定するのではなく，ルールに
基づいて割り当てが行われるように指定されるべきである．このルールを可視化
ルールと呼称する．

すなわち，可視化は，標準形式トレースログに対して，可視化ルールを適用して，
指定された開始イベントと終了イベントに一致するイベントを標準形式トレース
ログから探し，そのイベントの時刻を割り当て先の時間領域として採用すること
で，ワールド座標系への割り当てを行う．
%ToDo実装かな?
%可視化ルールにおける，開始イベントと終了イベントの記述には標準形式を用い
%る．

\subsubsection{図形の定義と可視化ルールの例}

図\ref{fig:timeShape}に図形の定義と可視化ルールの例を示す．

図形は，位置がローカル座標の原点，大きさがワールド座標系のマッピング領域
に対して横幅100\%，縦幅80\%の長方形で色が緑色の図形をrunningShapeとして
定義している．

可視化ルール(taskBecomeRunning)では，この図形を，開始イベント
\verb|MAIN_TASK.state=RUNNING|，終了イベント\verb|MAIN_TASK.state|となる
イベント期間で表示するよう指定している．開始イベント
\verb|MAIN_TASK.state=RUNNING|は，リソース\verb|MAIN_TASK|の属性
\verb|state|の値が\verb|RUNNING|になったことを表し，終了イベント
\verb|MAIN_TASK.state|は，リソース\verb|MAIN_TASK|の属性\verb|state|の値
が単に変わったことを表している．

この可視ルールを図\ref{fig:timeShape}右側中央のトレースログに適応すると，
トレースログからイベントを抽出して時間領域を決定して，図形をワールド座標
にマッピングする．

\begin{figure}[tb]
\begin{center}
\scalebox{0.42}{\includegraphics{img/timeShape.eps}}
\caption{図形の定義と可視化ルールの例}
\label{fig:timeShape}
\end{center}
\end{figure}


\section{実装}
\label{sec:implementation}

本章では，前章で行った設計を基にしたTLVの実装について述べる．まず全体の
構成について説明する．次に変換ルールや可視化ルールをどのように形式化した
か，また，それらをどのように用いて可視化を行うのかを説明する．

TLVの実装言語はC\#3.0であり，統合開発環境としてMicrosoft社のVisural 
Studio 2008 Professional Editionを用いた．

%TLVのソースコードメトリクスを表\ref{sourceMetrics}に示す．

%\begin{table}[htb]
%\begin{center}
%\caption{TLVのソースコードメトリクス}
%%\ecaption{A source code metrics of TLV}
%\label{sourceMetrics}
%\begin{tabular}{l|l}
%\hline
%総行数              & 18497 \\
%ファイル平均行数    & 94.38 \\
%有効な行数          & 10332 \\
%コメント行数        & 1432 \\
%空行                & 2224 \\
%その他の行数(中括弧など) & 4509 \\
%ファイル数          & 196 \\
%クラス数            & 186 \\
%インタフェース数    & 22 \\
%列挙体              & 15 \\
%デリゲート          & 2 \\
%\hline
%\end{tabular}
%\end{center}
%\end{table}



\subsection{構成}
図\ref{fig:tlv}にTLVの構成を示す．TLVは，6種の入出力ファイルと2つの主た
る処理によって構成される．

トレースログをTLVにより可視化表示する際，ユーザは，トレースログファイル
とリソースファイルを用意する．また，対応する変換ルールファイルとリソース
ヘッダファイル及び可視化ルールファイルを用意する．

標準形式変換は，トレースログとリソースファイルを読み込み，トレースログで
指定されたリソースヘッダファイルと変換ルールファイルの定義に従い，標準形
式のトレースログを生成する．

図形データ生成は，生成された標準形式のトレースログに可視化ルールファイル
で定義される可視化ルールを適用し図形データを生成した後，画面に表示する．

それぞれの処理で生成された標準形式のトレースログと図形データは，TLVデー
タとしてまとめられ可視化表示の元データとして用いられる．TLVデータはTLVフ
ァイルとして外部ファイルに保存することが可能であり，TLVファイルを読み込
むことで，2つの処理を省略して可視化表示することができる．

TLVが扱う6種のファイルのうち，トレースログファイル以外はJSON(JavaScript 
Object Notation)\cite{JSON}と呼ばれるデータ記述言語を用いて記述する．
JSONは，主にウェブブラウザなどで使用されるECMA-262，revision 3準拠の
JavaScript(ECMAScript)と呼ばれるスクリプト言語のオブジェクト表記法をベー
スとしており，RFC 4627として仕様が規定されている．JSONの特徴は，構文が単
純であることである．そのため，人間にとっても読み書きが容易であり，コンピ
ュータにとっても解析が容易であるため，ユーザの記述コスト，習得コスト，ま
たファイルの解析を行う実装コストを低減することができる．

\begin{figure}[tb]
\begin{center}
\scalebox{0.4}{\includegraphics{img/tlv.eps}}
\caption{TLVの構成}
%\ecaption{A structure of TLV}
\label{fig:tlv}
\end{center}
\end{figure}


\subsection{トレースログファイル}

トレースログファイルは，可視化対象となる環境が出力した，任意の形式のトレ
ースログをファイル化したものである．トレースログファイルはテキストファイ
ルであり，行単位でトレースログが記述されていなければならない．これ以外の
シンタックス，セマンティクスに関する制限はない．


\subsection{リソースヘッダファイル}

リソースヘッダファイルにはリソースタイプの定義を記述する．リソースタイプ
の定義には，リソースタイプの名前，表示名，属性，振る舞いを記述する．

図\ref{resourceHeaderFile}に，ASPカーネルのリソースタイプ\verb|Task|を定
義したリソースヘッダファイルの例を示す．属性(Attribute)としては，ID番号
(\verb|id|)と状態(\verb|state|)が定義されている．属性には，型
(VariableType)，表示名(DisplayName)，値が動的か静的か(AllocationType)，
グループ化可能か(CanGrouping)を指定可能である．ID番号は実行中に変化しな
いため，AllocationTypeは``Static''に，状態は実行中に変化するため，
``Dynamic''が指定されている．

振る舞い(Behaviors)としては，システムコール呼び出し(\verb|enterSVC|)が定
義されている．振る舞いは，表示名(DisplayName)，引数(Arguments)を指定可能
である．

\begin{EBNFFile}{ASPカーネルのリソースヘッダファイルの一部}{resourceHeaderFile}{A sample of a resource-header file}
 1 "Task":{                        /* リソースタイプの名前 */
 2    "DisplayName":"タスク",       /* 表示名 */
 3    "Attributes":{                /* 属性の定義始まり */
 4      "id":{                      /* 属性名 */
 5        "VariableType"  :"Number",/* 属性の型 */
 6        "DisplayName"   :"ID",    /* 属性の表示名 */
 7        "AllocationType":"Static",/* 値は動的か静的か */
 8        "CanGrouping"   :false /* 同じ属性値同士でグループ */
 8      },                       /* を構成できるか(GUI用) */
10      "state":{
11        "VariableType"   :"String",
12        "DisplayName"    :"状態",
13        "AllocationType" :"Dynamic",
14        "CanGrouping"    :false,
15        "Default"        :"DORMANT"
16      }
17      /* ... 省略 ... */
18    },                              /* 属性の定義終わり */
19    "Behaviors":{                   /* 振る舞いの定義開始 */
20      /* ... 省略 ... */
21      "enterSVC":{           /* システムコールの呼び出し */
22        "DisplayName":"サービスコールに入る",
23        "Arguments":{"name":"String","args":"String"}
24      },
25      /* ... 省略 ... */
26    }
27 }
\end{EBNFFile}


\subsection{リソースファイル}

リソースファイルには，主にトレースログに登場するリソースの定義を記述する．
他にも，時間の単位や時間の基数，適用する変換ルール，リソースヘッダ，可視
化ルールを定義する．リソースの定義には，名前とリソースタイプ，属性の初期
値を記述する．

ASPカーネルのリソースファイルの例を図\ref{resourceFile}に示す．図
\ref{resourceHeaderFile}のリソースヘッダファイルを適用するよう指定してい
る．リソースとしては，リソースタイプ\verb|Task|の\verb|TASK1|を定義して，
属性の初期値を指定している．\verb|TASK1|は，id番号が1であり，初期状態が
休止状態(DORMANT)である．

\begin{EBNFFile}{ASPカーネルのリソースファイルの一部}{resourceFile}{A sample of a resource file}
 1 "TimeScale" :"us", "TimeRadix" :10,  /* 時刻の単位と基数 */
 2 "ConvertRules"   :["asp"],             /* 変換ルール指定 */
 3 "VisualizeRules" :["toppers","asp"], /* 可視化ルール指定 */
 4 "ResourceHeaders":["asp"],         /* リソースヘッダ指定 */
 5 "Resources":{                    /* リソースの定義始まり */
 6   "TASK1":{           /* TASK1という名前のリソースを定義 */
 7     "Type":"Task",                     /* リソースタイプ */
 8     "Color":"ff0000",        /* リソース固有の色(GUI用) */
 9     "Attributes":{                 /* 属性の初期値を指定 */
10       "id"    :1,
11       "state" :"DORMANT",
12       /* ... 省略 ... */
13     }
14   },
15   /* ... 省略 ... */
\end{EBNFFile}


\subsection{変換ルールファイルと標準形式変換}

変換ルールファイルには，ターゲットとなるトレースログを標準形式のトレース
ログに変換するためのルールが記述される．

図\ref{convertRuleFile}に，\ref{sub:conv_rule}節で述べた変換ルールの例を
形式化したものを示す．1行目は，元のトレースログファイルから「あるタスク
にディスパッチされた(図\ref{fig:log_ASP}の3行目)」というトレースログを検
索するための正規表現であり，マッチした場合に2〜7行目で指定される標準形式
のトレースログを出力する．3行目は，出力する条件の制御であり，条件中に
\verb|$EXIST{|{\it resource}\verb|}|という置換マクロを用いてリソース{\it 
resource}の有無を判定している．ここでは，実行状態(RUNNING)のタスクが存在
するかチェックして，存在すれば，そのタスクが実行可能状態(READY)となる標
準形式のトレースログ(4行目)を出力する．一方，7行目は，1行目のマッチによ
り無条件に出力され，ディスパッチ先のタスクの状態を実行状態(RUNNING)とす
る標準形式トレースログを出力する．9〜13行目は，システムコール呼び出しを
変換するための変換ルールである．


\begin{EBNFFile}{ASPカーネルの変換ルールファイルの一部}{convertRuleFile}{A sample of a convert-rule file}
 1 "\[(?<t>\d+)\] dispatch to task (?<id>\d+)\.":[
 2   {
 3     "$EXIST{Task(state==RUNNING)}":[
 4       "[${t}]$RES_NAME{Task(state==RUNNING)}.state=READY",
 5     ]
 6   },
 7   "[${t}]$RES_NAME{Task(id==${id})}.state=RUNNING",
 8 ],
 9 "\[(?<time>\d+)\] enter to (?<name>(i\w+[_]\w+)) \
10                          ( (?<args>.+))?\.?" :[
11     "[${time}]$ATTR{CurrentContext.name}.enterSVC( \
12                                        ${name}, ${args})"
13 ],
\end{EBNFFile}

置換マクロは6種類用意されており，特定リソースの有無や数，属性の値を得る
ことができる．また，置換マクロは，条件判定のときだけでなく，出力する標準
形式トレースログの記述にも用いることができる．

\begin{itemize}
 \item \verb|$EXIST{|\textit{resource}\verb|}| \\
  指定されたリソースが存在すれば{\tt true}，存在しなければ
       {\tt false}に置換する．
 \item \verb|$COUNT{|\textit{resource}\verb|}| \\
  指定されたリソースの数に置換する．
 \item \verb|$ATTR{|\textit{attribute}\verb|}| \\
  指定された属性の値に置換する．
 \item \verb|$RES_NAME{|\textit{resource}\verb|}|  \\
  指定されたリソースの名前に置換する
 \item \verb|$RES_DISPLAYNAME{|\textit{resource}\verb|}|  \\
   指定されたリソースの表示名に置換する．
 \item \verb|$RES_COLOR{|\textit{resource}\verb|}| \\
   指定されたリソースの色に置換する．
\end{itemize}


標準形式変換は，トレースログファイルを先頭から行単位で読み込み，変換ルー
ルファイルで定義される置換ルールに従い標準形式のトレースログに置換するこ
とで行われる．図\ref{fig:log_ASP_STD}に図\ref{fig:log_ASP}とトレースログ
を図\ref{convertRuleFile}の変換ルールを用いて標準形式のトレースログに変
換した例を示す．

\begin{EBNFFile}{図\ref{fig:log_ASP}のトレースログの図\ref{convertRuleFile}の変換ルー
 ルによる標準形式への変換結果}{fig:log_ASP_STD}{aspStandartLogSample}
1 [1000]TASK(state==RUNNING).enterSVC(act_tsk, tskid=1)
2 [1005]TASK(id==1).state=READY
3 [1010]TASK(state==RUNNING).state=READY
4 [1010]TASK(id==1).state=RUNNING
\end{EBNFFile}

\subsection{可視化ルールと図形データ作成}

図形と可視化ルールの定義は可視化ルールファイルに記述する．図
\ref{visualizeRuleFile}にASPカーネルの可視化ルールファイルの一部を示す．
2行目から10行目までが図形の定義であり，それ以降が可視化ルールの定義であ
る．

図形としては，長方形の{\tt runningShapes}が定義されている．可視化ルール
は，RTOSのタスクの状態表示のための{\tt taskStateChange}が定義されている．
このルールでは，リソースタイプであるタスク({\tt Task})を対象とすることを，
{\tt Target}で指定している．
%
開始イベント({\tt From})と終了イベント({\tt To})として，タスクの属性であ
るタスクの状態の値の変更イベントを用いることを指定している．そして，{\tt 
Figures}で，ワールド座標系に割り当てる図形を指定している．このルールでは，
変更後の属性の値（タスクの状態）によって可視化方法を着替えており，実行状
態(RUNNING)の場合は，{\tt runningShapes}を用いる．

\begin{EBNFFile}{ASPカーネルの可視化ルールファイルの一部}{visualizeRuleFile}{A sample of a visualize-rule file}
 1 "toppers":{
 2   "Shapes":{                        /* 図形の定義始まり */
 3     "runningShapes":[{
 4         "Type":"Rectangle",         /* 形状の指定(長方形) */
 5         "Size":"100%,80%",          /* 大きさの指定 */
 6         "Pen":{"Color":"ff00ff00","Width":1},/* 線種の指定 */
 7         "Fill":"6600ff00"           /* 塗りつぶしの指定 */
 8       }],
 9     /* ... 省略 ... */
10   },                                /* 図形の定義終わり */
11   "VisualizeRules":{        /* 可視化ルールの定義始まり */
12     "taskStateChange":{
13       "DisplayName":"状態遷移", /* 可視化ルールの表示名 */
14       "Target":"Task",        /* 適用するリソースタイプ */
15       "Shapes":{                /* 表示項目の指定 */
16         "stateChangeEvent":{
17           "DisplayName":"状態", /* 表示項目の表示名 */
18           "From":"${TARGET}.state", /* 開始イベント */
19           "To"  :"${TARGET}.state", /* 終了イベント */
20           "Figures":{               /* 表示する図形 */
21             "${FROM_VAL}==RUNNING" :"runningShapes",
22             "${FROM_VAL}==READY":"readyShapes"
23             /* ... 省略 ... */
24           }
25         },
26         /* ... 省略 ... */
27       }
28     },                      /* 可視化ルールの定義終わり */
29     /* ... 省略 ... */
\end{EBNFFile}

図形データ生成は，\ref{sub:visualize_rule}節で述べたとおり，標準形式トレ
ースログの内容と図形と可視化ルールの定義に従い，ワールド座標系に図形を割
り当てる．


\section{TLVのユーザーインタフェース}

TLVのユーザーインタフェースについて解説する．図\ref{fig:aspTLVscreenShot}
に，ASPカーネルが出力したトレースログを，TLVを用いて可視化表示した結果を
示す．

\begin{figure*}[tb]
\begin{center}
%\scalebox{0.7}{\includegraphics{img/aspTLVscreenShot_1_1.eps}}
\scalebox{0.7}{\includegraphics{img/aspTLVscreenShot_1_1_1.eps}}
\caption{TOPPERS/ASPカーネルのトレースログの可視化表示}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TOPPERS/ASP}
\label{fig:aspTLVscreenShot}
\end{center}
\end{figure*}

\begin{figure*}[t]
\begin{center}
\scalebox{0.78}{\includegraphics{img/tecsTLVscreenShot.eps}}
\caption{ソフトウェアコンポーネント（TECS）のトレースログの可視化表示}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TECS}
\label{fig:tecsTLVscreenShot}
\end{center}
\end{figure*}

\begin{figure*}[tb]
\begin{center}
\scalebox{0.7}{\includegraphics{img/fmpTLVscreenShot_1_1.eps}}
\caption{マルチプロセッサ対応RTOS(TOPPERS/FMPカーネル)のトレースログの
 可視化表示}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TOPPERS/FMP}
\label{fig:fmpTLVscreenShot}
\end{center}
\end{figure*}


\subsection{可視化表示部の制御}

可視化表示ツールでは，可視化表示部（図中の中央上側のペイン）を制御する操
作性が使い勝手に大きく影響するため，TLVでは目的や好みに合わせて様々な操
作で制御を行えるようにした．TLVでは，可視化表示部の制御として，表示領域
の拡大縮小，移動を行うことができる．これらの操作方法として，キーボードに
よる操作，マウスによる操作，値の入力による操作の3つの方法を提供した．

マウスによる操作は，ドラッグによる操作，ホイールによる操作がある．ドラッ
グによる操作は，直接可視化表示部をドラッグして，表示領域を移動させる．ホ
イールによる操作は，コントロールキーを押しながらホイールすることで移動を
行い，シフトキーを押しながら上へホイールすることでカーソル位置を中心に拡
大，下へスクロールすることで縮小する．

キーボードによる操作は，可視化表示部において方向キーを押すことで行い，微
調整に適している．左キーで表示領域を左に移動し，右キーで右に移動する．上
キーでカーソル位置，または選択されたマーカーを中心に表示領域を縮小し，下
キーで拡大する．

値の入力による操作では，より詳細な制御を行うことができる．可視化表示部の
上部にはツールバーが用意されており，そこで表示領域の開始時刻と終了時刻を
直接入力することができる．


%\subsection{マーカー}
%
%TLVでは，可視化表示部にマーカーと呼ぶ印を指定の時刻に配置することができ
%る注目するべきイベントの発生時刻にマーカーを配置することで，可視化表示内
%容の理解を補助することができる．
%
%マーカーとマーカーの間には，その間の時間が表示されるので，ソフトウェアの
%計測を行うことができる．マーカーには名前を付けることができ，色の指定が可
%能である．また，マーカーはマウス操作で選択することができ，拡大縮小などの
%各種操作に利用される．マーカーは階層構造で管理し，階層ごとに表示の切り替
%え，マーカー間時間の表示などを行うことができる．


\subsection{マクロ表示}

可視化表示部で拡大した場合にログ全体のどの部分を表示しているのかを知るた
めに，マクロビューア（図中の一番下のペイン）を用意した．

マクロビューアでは，トレースログに含まれるイベントの最小時刻から最大時刻
までを常に可視化表示しているウィンドウで，可視化表示部で表示している時間
を半透明の色で塗りつぶして表示する．塗りつぶし領域のサイズをマウスで変更
することができ，それに対応して可視化表示部の表示領域を変更することができ
る．

マクロビューアでは可視化表示部と同じように，キーボード，マウスにより拡大
縮小，移動の制御を行うことができる．

\subsubsection{トレースログのテキスト表示}

標準形式のトレースログをテキストで表示するウィンドウを用意した（図中の右
側のペイン）．ここでは，トレースログの内容を確認することができる．

可視化表示部とテキスト表示ウィンドウは連携しており，テキスト表示ウィンド
ウでマウスを移動すると，カーソル位置にあるトレースログの時刻にあわせて可
視化表示部のカーソルが表示されたり，ダブルクリックすることで対応する時刻
に可視化表示部を移動することができる．また，可視化表示部でダブルクリック
することで，ダブルクリック位置にある図形に対応したトレースログが，テキス
ト表示ウィンドウの先頭に表示されるようになっている．

\subsubsection{可視化表示項目の表示非表示切り替え}

TLVでは，可視化表示する項目を可視化ルールにより変更，追加することができ
るが，それらの表示を可視化ルールやリソースを単位で切り替えることができる．
これらの操作は，リソースウィンドウと可視化ルールウィンドウで行う（図中の
左側のペイン）．

リソースウィンドウではリソースファイルで定義されたリソースを，リソースタ
イプやグループ化可能な属性毎にツリービュー形式で表示しており，チェックの
有無でリソース毎に表示の切り替えを行える．同じように，可視化ルールウィン
ドウでは，可視化ルールごとに表示の切り替えを行える．



\section{評価}
\label{evaluation}

汎用性の評価として，トレースログの形式が異なるRTOS(ASPカーネル)及びソフ
トウェアコンポーネント(TECS)\cite{TECS}のトレースログを可視化する．次に，
拡張性の評価として，ASPカーネルをマルチプロセッサ拡張したFMPカーネルの可
視化をASPカーネル用のファイルをベースに拡張して可視化表示する．

\subsection{ASPカーネルの可視化表示}

図\ref{fig:aspTLVscreenShot}に，ASPカーネルが出力するトレースログを，TLV
を用いて可視化表示した結果を示す．緑色の長方形がタスクが実行状態であるこ
とを示している．MAIN\_TASKはシステムコール(act\_tsk(1))を呼び出して，タ
スクIDが1のTASK1を起動(上矢印)して実行可能状態(平行ライン)としている．起
動の結果，TASK1はMAIN\_TASKより優先度が高いため，ディスパッチが発生して，
TASK1が実行状態MAIN\_TASKが実行可能状態に遷移し，TASK1にディスパッチして
いる．このように，タスクの状態遷移やシステムコールの出入り，その際の引数，
返値を可視化表示できていることがわかる．

変換ルールファイルは136行であり，可視化ルールファイルは可視化ルールが346
行，図形の定義が198行であった．また，リソースヘッダファイルは412行であっ
た．

%標準形式への変換処理に要した時間は，トレースログファイルが353行の場合で
%約2秒であった．

\subsection{ソフトウェアコンポーネント(TECS)の可視化表示}

組込みコンポーネントシステムTECS(TOPPERS Embedded Component System)のト
レースログを用いた．TECSとは，組込みに適したソフトウェアの部品化の仕組み
で，セルと呼ばれるコンポーネントのインスタンス同士を接続することでソフト
ウェアを構築する．
%
セルは呼び口，受け口を持ち，それぞれシグニチャを持つ．同じシグニチャ同士
の呼び口と受け口を接続することができる．シグニチャは関数ヘッダの集合で，
複数の関数インタフェースを持つ．

TECSのトレースログを可視化表示する項目として，セルの呼び出し関係を採用し
た．簡略化のため，セルがシグニチャのどの関数を呼んだかどうかは可視化せず，
どのセルが，どのセルを，どのくらいの期間呼び出していたかを可視化表示する
とする．セルの呼び出しのトレースログの形式を図\ref{fig:log_TECS}に示す．

{\it time}は時間であり，時間の単位はマイクロ秒である．{\it caller}は呼び
出しセルを，{\it callee}は呼び出されるセルを表している．{\it ...}には，
シグニチャの名前や引数，返値が入るが，今回の可視化には必要がないので省略
した．{\tt .enter(}{\it ...}{\tt )}がセルの呼び出しを，{\tt .leave(}{\it 
...}{\tt )}が呼び出し先からのリターンを表している．


\begin{figure}[tb]
\begin{quote}
%\bkcounttrue
\begin{breakbox}
\begin{flushleft}
\scriptsize
1 {\tt time=}{\it time}{\tt us }{\it caller}{\tt ->}{\it callee}{\tt .enter(}{\it ...}{\tt )}

2 {\tt time=}{\it time}{\tt us }{\it caller}{\tt ->}{\it callee}{\tt .leave(}{\it ...}{\tt )}
\end{flushleft}
\end{breakbox}
\caption{TECSのセルの呼び出しのトレースログの形式}
\label{fig:log_TECS}
\end{quote}
\end{figure}

図\ref{fig:tecsTLVscreenShot}に，TLV用いて可視化表示した結果を示す．セル
の呼び出し関係が可視化表示できていることがわかる．これにより，TLVを用い
ることで形式の異なるトレースログを可視化できることが示せた．このとき，変
換ルールは15行であり，可視化ルールは88行であった．また，リソースヘッダフ
ァイルは47行であった．


\subsection{FMPカーネルの可視化表示}

次に，ASPカーネルをマルチプロセッサ用に拡張したFMPカーネルが出力するトレ
ースログの可視化表示をASPカーネル用のファイルを拡張することで行った．FMP
カーネルが出力するトレースログの形式は，図\ref{traceLogSample}に示すよう
に，ASPカーネルが出力するトレースログの形式に，プロセッサの番号を付加し
た形式になっている．また，FMPカーネルの可視化表示項目は，ASPカーネルの可
視化表示項目に加え，そのタスクを実行しているプロセッサを背景色で区別する
ように拡張したものとする．

図\ref{fig:fmpTLVscreenShot}に，FMPカーネルが出力するトレースログを，TLV
用いて可視化表示した結果を示す．タスクの状態遷移を表示している箇所に，背
景色で実行プロセッサを区別し表現している．薄赤はプロセッサ1を薄青はプロ
セッサ2を示している．FMPカーネルでは，mig\_tsk()と呼ばれるシステムコール
を呼び出すことで，実行するプロセッサを変更することができる(タスクマイグ
レーション)．図\ref{fig:fmpTLVscreenShot}を見ると，TASK1\_1からTASK1\_3
がそれぞれ，mig\_tsk()を呼び出すと，背景の色が変化し，タスクマイグ
レーションが発生していることが分かる．

変換ルールファイルは160行，可視化ルールファイルは可視化ルールが250行，図
形定義が30行，リソースヘッダファイルは439行となった．可視化ルールファイ
ルはASPカーネル用のファイルに対する追加ルールとなっている．以上により，
拡張性が確認できた．



\section{おわりに}
\label{sec7}

本論文では，トレースログ可視化ツールであるTLVについて，背景と既存ツール
の問題点，それを解決するための要件，要件を満たすための方法とその実装，評
価について述べた．

今後の課題としては，現状の変換ルールや可視化ルールの記述では実現できない，
計算の必要な可視化表示項目について検討することが挙げられる．例えば，RTOS
におけるCPU使用率等の可視化表示等である．これらの可視化項目を扱うには，
可視化ルールを現状の単純なイベントの指定ではなく，イベントの状態遷移で指
定できるようにする方法や，変換ルールをスクリプト言語化する方法などが考え
られる．

%\begin{adjustvboxheight} % needed only when Appendix follows
\begin{thebibliography}{99}
\bibitem{TLV} TraceLogVisualizer(TLV)\\
http://www.toppers.jp/tlv.html.

\bibitem{OJL_URL} OJL による最先端技術適応能力を持つIT人材育成拠点の形成, \\
http://www.ocean.is.nagoya-u.ac.jp/

\bibitem{OJL_PAPER} 
小林隆志, 沢田篤史, 山本晋一郎, 野呂昌満, 阿草清滋:
On the Job Learning: 産学連携による新しいソフトウェア工学教育手法,
電子情報通信学会 信学技報 SS2009-28, (Vol.109, No.170, pp.95-100), 2009.

\bibitem{FMP}
TOPPERS/FMP kernel，\\
http://www.toppers.jp/fmp-kernel.html.

\bibitem{PARTNER-JET}
JTAG ICE PARTNER-Jet，\\
http://www.kmckk.co.jp/jet/.

\bibitem{watchpoint}
WatchPointデバッガ，\\
https://www.sophia-systems.co.jp/.

\bibitem{QNXMomentics}
QNX Momentics Tool Suite，\\
http://www.qnx.co.jp/products/tools/.

\bibitem{eBinder}
eBinder，\\
http://www.esol.co.jp/embedded/ebinder.html.

\bibitem{LTTng}

Mathieu Desnoyers and Michel Dagenais.: The lttng tracer : A low impact 
performance and behavior monitor for gnu/linux. In OLS (Ottawa Linux 
Symposium) 2006, pp.209--224, 2006.

\bibitem{LTTV}
Mathieu Desnoyers and Michel Dagenais, "OS Tracing for Hardware, Driver 
and Binary Reverse Engineering in Linux," CodeBreakers Journal Article, 
vol.4, no.1, 2007.

\bibitem{Dtrace}
R. McDougall, J. Mauro, and B. Gregg.: Solaris(TM) Performance and Tools: 
DTrace and MDB Techniques for Solaris 10 and OpenSolaris. Pearson 
Professional, 2006.

\bibitem{Chime}
OpenSolaris Project: Chime Visualization Tool for DTrace，\\
http://opensolaris.org/os/project/dtrace-chime/.

\bibitem{RFC3164}
RFC3164 The BSD syslog Protocol，\\
http://www.ietf.org/rfc/rfc3164.txt.

\bibitem{JSON}
RFC4627 The application/json Media Type for JavaScript Object Notation (JSON)，\\
http://tools.ietf.org/html/rfc4627.

\bibitem{ASP}
TOPPERS ASP Kernel，\\
http://www.toppers.jp/asp-kernel.html.

\bibitem{ITRON4}
        坂村健監修, 高田広章編，``$\mu$ITRON4.0 仕様 Ver.4.02.00,'' トロン
        協会, 2004.

\bibitem{TECS}

Takuya Azumi, Masanari Yamamoto, Yasuo Kominami, Nobuhisa Takagi, 
Hiroshi Oyama and Hiroaki Takada, "A New Specification of Software 
Components for Embedded Systems," Proceedings of the 10th IEEE 
International Symposium on Object and Component-Oriented Real-Time 
Distributed Computing (ISORC 2007), pp.45--50, 2007.

\end{thebibliography}
%\end{adjustvboxheight} % needed only when Appendix follows

\end{document}
