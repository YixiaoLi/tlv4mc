\chapter{トレースログ可視化ツール TraceLogVisualizer の実装}

\section{TraceLogVisualizerの全体像}

TLVの主機能は，2つの主たるプロセスと6種の外部ファイルによって実現される．
図\ref{fig:tlv}にTLVの全体像を示す．

2つの主たるプロセスとは，標準形式への変換と，図形データの生成である．
標準形式への変換は，任意の形式をもつトレースログを標準形式トレースログに変換する処理である．
この処理には，外部ファイルとして変換元のトレースログファイル，リソースを定義したリソースファイル，リソースタイプを定義したリソースヘッダファイル，標準形式トレースログへの変換ルールを定義した変換ルールファイルが読み込まれる．

また，図形データの生成は，変換した標準形式トレースログに対して可視化ルールを適用し図形データを生成する処理である．
この処理には外部ファイルとして可視化ルールファイルが読み込まれる．
可視化ルールファイルとは図形と可視化ルールの定義を記述したファイルである．

TLVは，トレースログとリソースファイルを読み込み，トレースログの対象に対応したリソースヘッダファイル，変換ルールファイルの定義に従い，標準形式トレースログを生成する．
生成された標準形式トレースログに可視化ルールファイルで定義される可視化ルールを適用し図形データを生成した後，画面に表示する．

生成された標準形式トレースログと図形データは，TLVデータとしてまとめられ可視化表示の元データとして用いられる．
TLVデータはTLVファイルとして外部ファイルに保存することが可能であり，TLVファイルを読み込むことで，標準形式変換と図形データ生成の処理を行わなくても可視化表示できるようになる．

図\ref{fig:TLVscreenshot}に，TLVのスクリーンショットを示す．

\begin{figure}[!t]
\begin{center}
\includegraphics[scale=0.7]{img/tlv.eps}
\caption{TLVの全体像}
\label{fig:tlv}
\end{center}
\end{figure}

\begin{figure}[!t]
\begin{center}
\includegraphics[scale=0.7]{img/TLVscreenshot.eps}
\caption{TLVのスクリーンショット}
\label{fig:TLVscreenshot}
\end{center}
\end{figure}

\subsection{Json}

リソースファイル，リソースヘッダファイル，変換ルールファイル，可視化ルールファイルは，Json(JavaScript Object Notation)\cite{Json}と呼ばれるデータ記述言語を用いて記述する．

Jsonは，主にウェブブラウザなどで使用されるECMA-262，revision 3準拠のJavaScript（ECMAScript）と呼ばれるスクリプト言語のオブジェクト表記法をベースとしており，RFC 4627としてで仕様が規定されている．
JsonはUnicodeのテキストデータで構成され，バイナリデータを扱うことはできない．
また，Jsonではシンタックスのみの規定がなされ，セマンティクスは規定されていない．

Jsonの特徴は，シンタックスが単純であることである．
これは，人間にとっても読み書きし易く，コンピュータにとっても解析し易いことを意味する．
また，複数のプログラミング言語でJsonファイルを扱うライブラリが実装されており，異なる言語間のデータ受け渡しに最適である．
Jsonが利用可能なプログラミング言語としては，ActionScript, C, C++, C\#, ColdFusion, Common Lisp, Curl, D言語, Delphi, E, Erlang, Haskell, Java, JavaScript (ECMAScript), Lisp, Lua, ML, Objective CAML, Perl, PHP, Python, Rebol, Ruby, Scala, Squeakなどがある．

TLVの各ファイルのフォーマットにJsonを採用した理由はこれらの特徴による．
シンタックスが単純であることにより，ユーザの記述コスト，習得コストを低減させることができ，また，複数のプログラミング言語でパース可能であることによりファイルに可搬性を持たせることができるからである．

Jsonで表現するデータ型は以下のとおりであり，これらを組み合わせることでデータを記述する．
\begin{itemize}
\setlength{\itemsep}{0.5\itemsep}
\item 数値(整数，浮動小数点)
\item 文字列(Unicode)
\item 真偽値(true，false)
\item 配列(順序付きリスト)
\item オブジェクト(ディクショナリ，ハッシュテーブル)
\item null
\end{itemize}

Jsonの文法をEBNFと正規表現を用いて説明する．

Jsonは，次に示すようにオブジェクトか配列で構成される．

\begin{EBNF}
JsonText = Object | Array;
\end{EBNF}

オブジェクトは複数のメンバをカンマで区切り，中括弧で囲んで表現する．
メンバは名前と値で構成され，名前のあとにはセミコロンが付く．
メンバの名前は値であり，データ型は文字列である．
オブジェクトの定義を次に示す．

\begin{EBNF}
Object = "{",Member,[{",",Member}],"}";
Member = String,":",Value;
\end{EBNF}

配列は複数の値を持つ順序付きリストであり，値をコンマで区切り，角括弧で囲んで表現する．
次に配列の定義を示す．

\begin{EBNF}
Array = "[",Value,[{",",Value}],"]";
\end{EBNF}

値は，文字列，数値，オブジェクト，配列，真偽値，nullのいずれかである．
文字列はダブルクオーテーションで囲まれたUnicode列である．
数値は10進法表記であり，指数表記も可能である．
値の定義を次に示す．

\begin{EBNF}
Value = String|Number|Object|Array|Boolean|"null";
String = /"([^"\]|\n|\"|\\|\b|\f|\r|\t|\u[0-9a-fA-F]{4})*"/;
Boolean = "true"|"false";
Number = ["-"],("0"|Digit1-9,[Digit]),[".",Digit],Exp;
Exp = ["e",[("+"|"-")],Digit];
Digit = /[0-9]+/;
Digit1-9 = /[1-9]/;
\end{EBNF}

表\ref{JsonObject}にJsonにおけるオブジェクトを定義した例を示す．

\begin{FileToPage}{Jsonにおけるオブジェクトを定義した例}{JsonObject}
{
  "Image":{
    "Width":  800,
    "Height": 600,
    "Title":  "View from 15th Floor",
    "Thumbnail":{
      "Url":    "http://www.example.com/image/481989943",
      "Height": 125,
      "Width":  "100"
    },
    "IDs": [116, 943, 234, 38793]
  }
}
\end{FileToPage}

表\ref{JsonArray}にJsonにおける配列を定義した例を示す．

\begin{FileToPage}{Jsonにおける配列を定義した例}{JsonArray}
[
  {
    "City":      "SAN FRANCISCO",
    "State":     "CA",
    "Zip":       "94107",
    "Country":   "US"
  },
  {
    "City":      "SUNNYVALE",
    "State":     "CA",
    "Zip":       "94085",
    "Country":   "US"
  },
  {
    "City":      "HEMET",
    "State":     "CA",
    "Zip":       "92544",
    "Country":   "US"
  }
]
\end{FileToPage}

\section{標準形式への変換}

標準形式トレースログへの変換は，トレースログファイルを先頭から行単位で読み込み，変換ルールファイルで定義される置換ルールに従い標準形式トレースログに置換していくことで行われる．変換ルールファイルの詳細は\ref{subsec:cnvFile}小節で説明する．

１つの置換ルールに対して複数の標準形式トレースログを出力可能である．
しかし，所望の標準形式トレースログに変換する際，トレースログファイルの情報だけでは足りない場合がある．
例として，TOPPERS/ASPカーネル\cite{TOPPERS}というRTOSのトレースログを標準形式トレースログに変換することを考えてみる．
TOPPERS/ASPカーネルのトレースログの例を表\ref{aspLogSample}に示す．

\begin{File}{変換元となるTOPPERS/ASPカーネルのトレースログの例}{aspLogSample}
[1000]task 1 becomes RUNNABLE
[1005]dispatch to task 1.
[1100]task 1 becomes WAITING
\end{File}

表\ref{aspLogSample}のトレースログの内容を簡単に説明すると，時刻1000にタスクIDが1のタスクの状態がRUNNABLEになり，時刻1005に同タスクがディスパッチされ，時刻1100に同タスクの状態がWAITINGになったことを示している．
この場合，標準形式トレースログは表\ref{aspStandartLogSample}のように出力されることが要求される．
なお，説明のため簡略化しており，実際の変換結果とは異なる．

\begin{File}{表\ref{aspLogSample}を標準形式トレースログで表現した例}{aspStandartLogSample}
[1000]Task(id==1).activate()
[1000]Task(id==1).state = RUNNABLE
[1005]Task(state==RUNNING).state=RUNNABLE
[1005]Task(id==1).state = RUNNING
[1100]Task(id==1).state = WAITING
\end{File}

表\ref{aspLogSample}で示す元のトレースログが3行なのに対し，表\ref{aspStandartLogSample}で示す要求される標準形式トレースログは５行となっている．
これは，表\ref{aspStandartLogSample}の1行目と3行目が状況により追加されるからである．
表\ref{aspStandartLogSample}の1行目は，表\ref{aspLogSample}の1行目に対応しており，起動(\verb|activate()|)というタスクの振る舞いを可視化したいという要求があるため追加される必要がある．
また，表\ref{aspStandartLogSample}の3行目は，表\ref{aspLogSample}の2行目に対応しており，すでに起動しているタスクが横取りされて状態がRUNNABLEになる，という情報が元のトレースログに存在しないため，追加される必要がある．

しかしながら，これら標準形式トレースログの追加が必要になるのは一定の条件下のみである．
表\ref{aspStandartLogSample}の1行目は，タスクIDが1のタスクの状態が，時刻1000未満のときにDORMANTである場合だけである．
これは，起動という状態遷移を行うのが状態がDORMANTからRUNNABLEに遷移するときだけであり，状態がDORMANTになっただけでは起動であるのかどうか判断できないためである．
また，表\ref{aspStandartLogSample}の3行目が必要なときは，時刻1005のときに状態がRUNNINGのタスクが存在する場合だけである．

このように，リソース属性の遷移に伴うイベントや，元のトレースログに欠落している情報を補うイベントなど，元のトレースログの情報だけでは判断できないイベントを出力するには，特定時刻における特定リソースの有無やその数，特定リソースの属性の値などの条件で出力を制御できる必要がある．
そのため，TLVの変換ルールでは，置換する条件の指定と，条件指定の際に用いる情報を置換マクロを用いて取得できる仕組みを提供した．
具体的な記述例は\ref{subsec:cnvFile}小節で述べる．

標準形式トレースログに含まれるリソースは，リソースファイルで定義されていなければならない．
リソースファイルには，各リソースについて，その名前とリソースタイプ，必要であれば各属性の初期値を定義する．
リソースファイルの詳細については\ref{subsec:resFile}小節で述べる．
また，その際に使用されるリソースタイプはリソースヘッダファイルで定義されていなければならない．
リソースヘッダファイルには各リソースタイプについて，その名前と属性，振る舞いの定義を記述する．
リソースヘッダファイルの詳細については\ref{subsec:reshFile}小節で述べる．

リソースヘッダ，変換ルール，可視化ルールは可視化するターゲット毎に用意する．
その際のターゲットはリソースファイルに記述する．

\subsection{トレースログファイル}

標準形式トレースログに変換する元となるトレースログは，トレースログファイルとして読み込む．
トレースログファイルはテキストファイルであり，行単位でトレースログが記述されていなければならない．
これ以外のシンタックス，セマンティクスに関する制限はない．

任意のトレースログファイルを標準形式トレースログに変換するには，ターゲットとなるトレースログの形式毎に変換ルールファイルを用意する必要がある．

表\ref{aspTraceLog}に，RTOSであるTOPPERS/ASPカーネルのトレースログの例を示す．

\begin{File}{TOPPERS/ASPカーネルのトレースログの例}{aspTraceLog}
[11005239]: task 4 becomes RUNNABLE.
[11005778]: dispatch from task 2.
[11005954]: dispatch to task 4.
[11006160]: leave to dly_tsk ercd=0.
[11006347]: enter to dly_tsk dlytim=10.
[11006836]: task 4 becomes WAITING.
[11007050]: dispatch from task 4.
[11007226]: dispatch to task 2.
[11007758]: enter to sns_ctx.
[11007934]: leave to sns_ctx state=0.
[11008656]: enter to sns_ctx.
[11008832]: leave to sns_ctx state=0.
\end{File}

\subsection{リソースヘッダファイル}
\label{subsec:reshFile}

リソースヘッダファイルにはリソースタイプの定義を記述する．
リソースタイプの定義には，リソースタイプの名前，表示名，リソースタイプがもつ属性，振る舞いを記述する．

リソースヘッダは可視化するターゲット毎にリソースタイプを定義することができる．
つまり，タスクを表すリソースタイプ\verb|Task|を定義する際に，ターゲットとなるRTOS毎に属性の内容を変えたい場合，RTOS毎にリソースタイプ\verb|Task|を定義することができる．

表\ref{resourceHeaderSample}に，ターゲット\verb|asp|のリソースタイプ\verb|Task|を定義したリソースヘッダファイルの例を示す．
リソースヘッダファイルは，1つのオブジェクトで構成され，各メンバにターゲット毎のリソースタイプの定義を記述する．
メンバ名にターゲット名を記述し，値としてそのターゲットに属する複数のリソースタイプを定義したオブジェクトを記述する．
そのオブジェクトには，メンバ名にリソースタイプ名を，値にリソースタイプを定義したオブジェクトを記述する．
以下に，リソースタイプを定義するオブジェクトのメンバの説明と値について説明する．

\begin{File}{リソースヘッダファイルの例}{resourceHeaderSample}
{
  "asp":{
    "Task":{
      "DisplayName":"タスク",
      "Attributes":{
        "id":{
          "VariableType":"Number",
          "DisplayName":"ID",
          "AllocationType":"Static",
          "CanGrouping":false
        },
        "atr":{
          "VariableType":"String",
          "DisplayName":"属性",
          "AllocationType":"Static",
          "CanGrouping":false
        },
        /* 省略 */
        "state":{
          "VariableType":"String",
          "DisplayName":"状態",
          "AllocationType":"Dynamic",
          "CanGrouping":false,
          "Default":"DORMANT"
        }
      },
      "Behaviors":{
        "preempt":{"DisplayName":"プリエンプト"},
        "dispatch":{"DisplayName":"ディスパッチ"},
        "activate":{"DisplayName":"起動"},
        "exit":{"DisplayName":"終了"},
        /* 省略 */
        "enterSVC":{
          "DisplayName":"サービスコールに入る",
          "Arguments":{"name":"String","args":"String"}
        },
        "leaveSVC":{
          "DisplayName":"サービスコールから出る",
          "Arguments":{"name":"String","args":"String"}
        }
      }
    }
  }
}
\end{File}

\begin{description}
{\nopagebreak
\item[\texttt{DisplayName}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] リソースタイプの表示名．主にGUI表示の際に用いられる
    \item[値] 文字列
    \end{description}
}
\clearpage
\item[\texttt{Attributes}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 属性の定義
    \item[値] オブジェクト．メンバ名に属性名，値に属性の定義をオブジェクトで記述する．その際のオブジェクトのメンバの説明は以下の通りである．
    
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            {\nopagebreak
            \item[\texttt{VariableType}] \mbox{}
            \vspace{-0.25zw}
                \begin{description}
                \item[説明] 属性値の型
                \item[値] 文字列(\verb|"Number"|：数値，\verb|"Boolean"|：真偽値，\verb|"String"|：文字列のいずれか)
                \end{description}
            }{\nopagebreak
            \item[\texttt{DisplayName}] \mbox{}
            \vspace{-0.25zw}
                \begin{description}
                \item[説明] 属性の表示名．主にGUI表示の際に用いられる
                \item[値] 文字列
                \end{description}
            }{\nopagebreak
            \item[\texttt{AllocationType}] \mbox{}
            \vspace{-0.25zw}
                \begin{description}
                \item[説明] 属性の値が動的か静的かの指定．ここで動的とは，属性値変更イベントが発生すること指し，静的とは発生しないことを指す．
                \item[値] 文字列(\verb|"Static"|，\verb|"Dynamic"|のいずれか)
                \end{description}
            }{\nopagebreak
            \item[\texttt{CanGrouping}] \mbox{}
            \vspace{-0.25zw}
                \begin{description}
                \item[説明] リソースをグループ化できるかどうか．ここで\verb|true|を指定された場合，GUIでリソースの一覧を表示する際に初期値でグループ化され表示することができる．
                \item[値] 真偽値
                \end{description}
            }
            \end{description}
    \end{description}
\item[\texttt{Behaviors}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 振る舞いの定義
    \item[値] オブジェクト．メンバ名に振る舞い名，値に振る舞いの定義をオブジェクトで記述する．その際のオブジェクトのメンバの説明は以下の通りである．
    
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            {\nopagebreak
            \item[\texttt{DisplayName}] \mbox{}
            \vspace{-0.25zw}
                \begin{description}
                \item[説明] 振る舞いの表示名．主にGUI表示の際に用いられる
                \item[値] 文字列
                \end{description}
            }{\nopagebreak
            \item[\texttt{Arguments}] \mbox{}
            \vspace{-0.25zw}
                \begin{description}
                \item[説明] 振る舞いの引数
                \item[値] オブジェクト．メンバ名に引数名，値に引数の型を記述する．
                \end{description}
            }
            \end{description}
    \end{description}
\end{description}

\subsection{リソースファイル}
\label{subsec:resFile}

リソースファイルには，主に，標準形式トレースログに登場するリソースの定義を記述する．
他にも，時間の単位や時間の基数，適用する変換ルール，リソースヘッダ，可視化ルールを定義する．
リソースの定義には，名前とリソースタイプ，必要があれば属性の初期値を記述する．

表\ref{resourceSample}にリソースファイルの例を示す．
リソースファイルは1つのオブジェクトで構成され，\verb|TimeScale|，\verb|TimeRadix|，\verb|ConvertRules|，\verb|VisualizeRules|，\verb|ResourceHeaders|，\verb|Resources|の6つのメンバを持つ．
以下にそれぞれのメンバについて説明する．

\begin{FileHere}{リソースファイルの例}{resourceSample}
{
  "TimeScale" :"us",
  "TimeRadix" :10,
  "ConvertRules"   :["asp"],
  "VisualizeRules" :["toppers","asp"],
  "ResourceHeaders":["asp"],
  "Resources":{
    "TASK1":{
      "Type":"Task",
      "Color":"ff0000",
      "Attributes":{
        "id"    :1,
        "atr"   :"TA_NULL",
        "pri"   :10,
        "exinf" :1,
        "task"  :"task",
        "stksz" :4096,
        "state" :"DORMANT"
      }
    },
    "TASK2":{
      "Type":"Task",
      "Color":"00ff00",
      "Attributes":{
        "id"    :4,
        "atr"   :"TA_ACT",
        "pri"   :5,
        "exinf" :0,
        "task"  :"task",
        "stksz" :4096,
        "state" :"RUNNABLE"
      }
    }
  }
}
\end{FileHere}

\begin{description}
{\nopagebreak
\item[\texttt{TimeScale}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 時間の単位
    \item[値] 文字列
    \end{description}
}{\nopagebreak
\item[\texttt{TimeRadix}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 時間の基数
    \item[値] 数値
    \end{description}
}{\nopagebreak
\item[\texttt{ConvertRules}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 適用する変換ルールのターゲット．複数のターゲットを指定可能
    \item[値] 文字列の配列
    \end{description}
}
{\nopagebreak
\item[\texttt{VisualizeRules}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 適用する可視化ルール．複数のターゲットを指定可能
    \item[値] 文字列の配列
    \end{description}
}{\nopagebreak
\item[\texttt{ResourceHeaders}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] \verb|Resources|で定義されるリソースのリソースタイプを定義しているターゲット．複数のターゲットを指定可能
    \item[値] 文字列の配列
    \end{description}
}
\item[\texttt{Resources}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] リソースを定義
    \item[値] オブジェクト．メンバ名にリソースの名前，値にリソースの定義をオブジェクトで記述．値として与えるオブジェクトで使えるメンバは以下のとおりである．
    
        \begin{description}
        {\nopagebreak
        \item[\texttt{Type}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 必須項目である．リソースタイプ名を記述
            \item[値] 文字列
            \end{description}
        }{\nopagebreak
        \item[\texttt{Color}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] リソース固有の色を指定．可視化表示の際に用いられる
            \item[値] 文字列．RGBを各8bitで表現したものを16進法表記で記述
            \end{description}
        }{\nopagebreak
        \item[\texttt{Attributes}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 属性の初期値．指定できる属性はリソースタイプで定義されているものに限る
            \item[値] オブジェクト．メンバ名に属性名，値に属性の初期値を記述
            \end{description}
        }
        \end{description}
    \end{description}
\end{description}

\subsection{変換ルールファイル}
\label{subsec:cnvFile}

変換ルールファイルには，ターゲットとなるトレースログを標準形式トレースログに変換するためのルールが記述される．
表\ref{convertRuleFileSample}に，変換ルールファイルの例を示す．

\begin{table}[h]
{\scriptsize
\begin{quote}
\bkcounttrue
\begin{breakbox}
\setlength{\baselineskip}{0.8\normalbaselineskip}
\begin{verbatim}
{
  "asp":{
    "\[(?<time>\d+)\] dispatch to task (?<id>\d+)\.":[
      {
        "$EXIST{[${time}]Task(state==RUNNING)}":[
          "[${time}]$RES_NAME{[${time}]Task(state==RUNNING)}.preempt()",
          "[${time}]$RES_NAME{[${time}]Task(state==RUNNING)}.state=RUNNABLE"
        ]
      },
      "[${time}]$RES_NAME{Task(id==${id})}.dispatch()",
      "[${time}]$RES_NAME{Task(id==${id})}.state=RUNNING"
    ],
    "\[(?<time>\d+)\] task (?<id>\d+) becomes (?<state>[^\.]+)\.":[
      {
        "$ATTR{[${time}]Task(id==${id}).state}==DORMANT && ${state}==RUNNABLE"
          :"[${time}]$RES_NAME{Task(id==${id})}.activate()",
        "$ATTR{[${time}]Task(id==${id}).state}==RUNNING && ${state}==DORMANT"
          :"[${time}]$RES_NAME{Task(id==${id})}.exit()",
      },
      "[${time}]$RES_NAME{Task(id==${id})}.state=${state}"
    ],
    "\[(?<time>\d+)\] enter to (?<name>\w+)( (?<args>.+))?\.?":{
      "$EXIST{[${time}]Task(state==RUNNING)}"
        :"[${time}][${time}]Task(state==RUNNING).enterSVC(${name},${args})"
    },
    "\[(?<time>\d+)\] leave to (?<name>\w+)( (?<args>.+))?\.?":{
      "$EXIST{[${time}]Task(state==RUNNING)}"
        :"[${time}][${time}]Task(state==RUNNING).leaveSVC(${name},${args})"
    }
  }
}
\end{verbatim}
\end{breakbox}
\caption{変換ルールファイルの例}
\label{convertRuleFileSample}
\end{quote}
}
\end{table}

変換ルールファイルは，1つのオブジェクトで構成され，各メンバにターゲット毎の変換ルールを記述する．
メンバ名にターゲット名を記述し，値としてそのターゲットが出力するトレースログを標準形式へ変換するためのルールをオブジェクトとして記述する．
そのオブジェクトのメンバ名には，標準形式へ変換される対象となるトレースログを正規表現を用いて記述し，値には出力する標準形式トレースログを記述する．
この際，値を文字列として記述すれば1行を，文字列の配列として記述すれば複数行を出力することができる．
また，値としてオブジェクトを記述することで，そのメンバ名に出力する条件を記述し，値に出力する標準形式トレースログを記述すれば，条件が真のときのみ出力するように定義できる．
また，このときの配列やオブジェクトはネストして記述することができる．

表\ref{convertRuleFileSample}の例を用いて具体的な説明を行う．
3行目，13行目，22行目，26行目が検索するトレースログの正規表現である．
これらの正規表現に一致するトレースログが見つかったとき，対応する値の標準形式トレースログが出力される．
3行目，13行目の正規表現に一致した場合は，標準形式トレースログが配列として与えられていて，複数の標準形式トレースログを出力する可能性がある．
3行目の正規表現に一致した場合は，10行目，11行目は必ず出力され，6行目，7行目の標準形式トレースログは5行目の条件が真の場合に出力される．
13行目の正規表現に一致した場合は，18行目は必ず出力され，16行目，18行目の標準形式トレースログはそれぞれ15行目，17行目の条件が真の場合に出力される．
22行目，26行目の正規表現に一致した場合は，標準形式トレースログがオブジェクトとして与えられていて，それぞれ23行目，27行目の条件が真の場合のみ標準形式トレースログを出力する．

検索するトレースログの正規表現において，名前付きグループ化構成体を用いると，入力文字列中の部分文字列をキャプチャすることができ，標準形式トレースログの出力や条件判定の際に使用できるようになる．名前付きグループ化構成体は"\texttt{(?<}\textit{name}\texttt{>}\textit{regexp}\texttt{)}"と記述する．このとき，\textit{regexp}で表現される正規表現にマッチする部分文字列が\textit{name}をキーとしてキャプチャされる．キャプチャされた文字列は，キーを用いて"\verb|${|\textit{name}\verb|}|"と記述することで呼び出せる．
また，名前付きでないグループ化構成体"\texttt{(}\textit{regexp}\texttt{)}"を用いることもでき，その際は"\texttt{\$}\textit{n}"で呼び出せる．\textit{regexp}に一致した部分文字列に1から順に番号がつけられ，これを呼び出す際の番号\textit{n}として用いる．

\subsubsection{置換マクロ}

標準形式トレースログをオブジェクトとして記述することで出力を条件で制御できることを上記で述べたが，条件判定の際に置換マクロを用いることで特定リソースの有無や数，属性の値を得ることができる．
また，置換マクロは，条件判定のときだけでなく，出力する標準形式トレースログの記述にも用いることができる．
置換マクロは"\verb|$|{\it name}\verb|{|{\it common-tracelog-syntax}\verb|}|"という形式で記述する．{\it name}は置換マクロ名であり，{\it common-tracelog-syntax}は標準形式トレースログの文字列である．{\it common-tracelog-syntax}にはリソースや属性が指定され，時刻の指定も可能である．
利用できる置換マクロは以下の通りである．

\vspace{1zw}
{\nopagebreak
\noindent
\verb|$EXIST{|\textit{resource}\verb|}|
\vspace{-0.75zw}
\begin{quote}
指定されたリソース{\it resource}が存在すれば{\tt true}，存在しなければ{\tt false}に置換される．
リソースがリソース名ではなく，リソースタイプと属性の条件で記述されることを想定している．

\vspace{-1zw}
\begin{description}
\item[例] 時刻1000に属性{\tt state}の値が{\tt RUNNING}であるリソースタイプ{\tt Task}のリソースが存在する場合

\hspace*{-1zw}入力\vspace{-1.75zw}
\begin{EBNF}
$EXIST{[1000]Task(state==RUNNING)}
\end{EBNF}
\hspace*{-1zw}出力\vspace{-1.75zw}
\begin{EBNF}
true
\end{EBNF}
\end{description}

\end{quote}
}
{\nopagebreak
\noindent
\verb|$COUNT{|\textit{resource}\verb|}|
\vspace{-0.75zw}
\begin{quote}
指定されたリソース{\it resource}の数に置換される．
リソースがリソース名ではなく，リソースタイプと属性の条件で記述されることを想定している．

\vspace{-1zw}
\begin{description}
\item[例] 時刻1000に属性{\tt state}の値が{\tt WAITING}であるリソースタイプ{\tt Task}のリソースが3つ存在する場合

\hspace*{-1zw}入力\vspace{-1.75zw}
\begin{EBNF}
$COUNT{[1000]Task(state==WAITING)}
\end{EBNF}
\hspace*{-1zw}出力\vspace{-1.75zw}
\begin{EBNF}
3
\end{EBNF}
\end{description}

\end{quote}
}
{\nopagebreak
\noindent
\verb|$ATTR{|\textit{attribute}\verb|}|
\vspace{-0.75zw}
\begin{quote}
指定された属性{\it attribute}の値に置換される．
リソースをリソースタイプと属性の条件で記述する場合は，条件に一致するリソースが1つになるようにしなければならない．

\vspace{-1zw}
\begin{description}
\item[例] 時刻1000にリソース{\tt MAIN\_TASK}の属性{\tt state}の値が{\tt WAITING}である場合

\hspace*{-1zw}入力\vspace{-1.75zw}
\begin{EBNF}
$ATTR{[1000]MAIN_TASK.state}
\end{EBNF}
\hspace*{-1zw}出力\vspace{-1.75zw}
\begin{EBNF}
WAITING
\end{EBNF}
\end{description}

\end{quote}
}
{\nopagebreak
\noindent
\verb|$RES_NAME{|\textit{resource}\verb|}|
\vspace{-0.5zw}
\begin{quote}
指定されたリソース{\it resource}の名前に置換される．
リソースをリソースタイプと属性の条件で記述する場合は，条件に一致するリソースが1つになるようにしなければならない．

\begin{description}
\item[例] 属性{\tt id}の値が{\tt 1}であるリソースタイプ{\tt Task}のリソースの名前がMAIN\_TASKのとき

\hspace*{-1zw}入力\vspace{-1.75zw}
\begin{EBNF}
$RES_NAME{Task(id==1)}
\end{EBNF}
\hspace*{-1zw}出力\vspace{-1.75zw}
\begin{EBNF}
MAIN_TASK
\end{EBNF}
\end{description}

\end{quote}
}
{\nopagebreak
\noindent
\verb|$RES_DISPLAYNAME{|\textit{resource}\verb|}|
\vspace{-0.5zw}
\begin{quote}
指定されたリソース{\it resource}の表示名に置換される．
リソースの表示名はリソースファイルで定義される．
リソースをリソースタイプと属性の条件で記述する場合は，条件に一致するリソースが1つになるようにしなければならない．

\begin{description}
\item[例] 属性{\tt id}の値が{\tt 1}であるリソースタイプ{\tt Task}のリソースの表示名が"メインタスク"のとき

\hspace*{-1zw}入力\vspace{-1.75zw}
\begin{EBNF}
$RES_DISPLAYNAME{Task(id==1)}
\end{EBNF}
\hspace*{-1zw}出力\vspace{-1.75zw}
\begin{EBNF}
メインタスク
\end{EBNF}
\end{description}

\end{quote}
}
{\nopagebreak
\noindent
\verb|$RES_COLOR{|\textit{resource}\verb|}|
\vspace{-0.5zw}
\begin{quote}
指定されたリソース{\it resource}の色に置換される．
リソースの色はリソースファイルで定義される．
リソースをリソースタイプと属性の条件で記述する場合は，条件に一致するリソースが1つになるようにしなければならない．

\begin{description}
\item[例] 属性{\tt id}の値が{\tt 1}であるリソースタイプ{\tt Task}のリソースの色が赤(ff0000)のとき

\hspace*{-1zw}入力\vspace{-1.75zw}
\begin{EBNF}
$RES_COLOR{Task(id==1)}
\end{EBNF}
\hspace*{-1zw}出力\vspace{-1.75zw}
\begin{EBNF}
ff0000
\end{EBNF}
\end{description}

\end{quote}
}

\section{図形データの生成}

標準形式変換プロセスを経て得られた標準形式トレースログは，可視化ルールを適用され図形データを生成する．
ここで，図形データとは，ワールド変換が行われた全図形のデータを指す．
可視化ルールは可視化ルールファイルとして与えられ，適用する可視化ルールはリソースファイルに記述する．

図形データの生成方法は，標準形式トレースログを一行ずつ可視化ルールのイベント期間と一致するか判断し，一致した場合にその可視化ルールの表示期間をワールド変換先の領域として採用しワールド変換することで行われる．

\subsection{可視化ルールファイル}
\label{visualizeRuleSection}
可視化ルールファイルには，可視化ルールと，図形の定義を記述する．
可視化ルールファイルは，1つのオブジェクトで構成され，オブジェクトのメンバにターゲット毎の変換ルールを記述する．
メンバ名にターゲット名を記述し，値としてオブジェクトを与え，そのオブジェクトに可視化ルールと図形の定義を記述する．

\subsubsection{図形の定義}

図形の定義は，\ref{subsec:visualization}小節にて述べた抽象化した図形を形式化したものである．

図形の定義は{\tt Shapes}というメンバ名の値にオブジェクトとして記述する．
このオブジェクトのメンバ名には図形の名前を記述する．
そして，その値に図形の定義を基本図形の定義の配列として与える．

表\ref{shapeSample}に{\tt toppers}をターゲットとする図形を定義した例を示す．
例では，{\tt runningShapes}と{\tt runnableShapes}，{\tt svcShapes}の3つの図形を定義している．
{\tt runningShapes}と{\tt runnableShapes}は1つの基本図形で構成され，{\tt svcShapes}は3つの基本図形から構成される．

\begin{File}{可視化ルールファイルで図形を定義した例}{shapeSample}
{
  "toppers":{
    "Shapes":{
      "runningShapes":[
        {
          "Type":"Rectangle",
          "Size":"100%,80%",
          "Pen":{"Color":"ff00ff00","Width":1},
          "Fill":"6600ff00"
        }
      ],
      "runnableShapes":[
        {
          "Type":"Line",
          "Points":["l(0),80%","r(0),80%"],
          "Pen":{"Color":"ffffaa00","Width":1}
        }
      ],
      "svcShapes":[
        {
          "Type":"Rectangle",
          "Size":"100%,40%",
          "Pen":{"Color":"${ARG0}","Width":1, "DashStyle":"Dash"},
          "Fill":"${ARG0}",
          "Alpha":100
        },
        {
          "Type":"Text",
          "Size":"100%,40%",
          "Font":{"Align":"TopLeft", "Size":7},
          "Text":"${ARG1}"
        },
        {
          "Type":"Text",
          "Size":"100%,40%",
          "Font":{"Align":"BottomRight", "Size":7},
          "Text":"return ${ARG2}"
        }
      ]
    }
  }
}
\end{File}

基本図形の定義に用いるメンバは，基本図形の形状により異なる．
すべての形状に共通なメンバの説明を以下に示す．

\begin{description}
{\nopagebreak
\item[\texttt{Type}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 図形の形状．必須である．
    \item[値] 文字列（"{\tt Rectangle}"：長方形，"{\tt Line}"：線分，"{\tt Arrow}"：矢印，"{\tt Polygon}"：多角形，"{\tt Pie}"：扇形，"{\tt Ellipse}"：楕円形，"{\tt Text}"：文字列のいずれか）
    \end{description}
}{\nopagebreak
\item[\texttt{Size}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 図形のサイズ．省略した場合，値は"\verb|100%,100%|"となる
    \item[値] サイズ指定形式の文字列
    \end{description}
}{\samepage
\item[\texttt{Location}] \mbox{} 
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 図形の位置．省略した場合，値は"\verb|0,0|"となる
    \item[値] 位置指定形式の文字列
    \end{description}
}
\clearpage
{\nopagebreak
\item[\texttt{Area}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 図形の表示領域．サイズと位置を同時に指定する．省略した場合は，サイズに{\tt Size}の値が，位置に{\tt Location}の値が設定される．
    \item[値] 文字列2つの配列．1つ目の要素は位置指定形式，2つ目の要素はサイズ指定形式を記述する
    \end{description}
}{\nopagebreak
\item[\texttt{Offset}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 図形のオフセット．省略した場合，値は"\verb|0,0|"となる
    \item[値] 位置指定形式の文字列
    \end{description}
}
\end{description}

図形のサイズを指定する形式として，サイズ指定形式（{\tt ShapeSize}）を次のように定めた．

\begin{EBNF}
ShapeSize = Width,",",Height
Width = /-?([1-9][0-9]*)?[0-9](\.[0-9]*)?(%|px)?/
Height = /-?([1-9][0-9]*)?[0-9](\.[0-9]*)?(%|px)?/
\end{EBNF}

\ref{subsec:visualization}小節において，図形の大きさの指定方法として，絶対指定と相対指定の2つの方法を用いることができるとした．
これらは{\tt px}と{\tt \%}という単位を用いることで指定する．
{\tt px}が絶対指定であり，{\tt \%}が相対指定である．
単位を省略した場合は絶対指定されたものとして解釈される．

また，図形の位置を指定する形式として，位置指定形式({\tt ShapeLocation})を次のように定めた．

\begin{EBNF}
ShapeLocation = X,",",Y
X = ("l"|"c"|"r"),"(",Value,")"|Value;
Y = ("t"|"m"|"b"),"(",Value,")"|Value;
Value = /-?([1-9][0-9]*)?[0-9](\.[0-9]*)?(%|px)?/
\end{EBNF}

図形の位置も，サイズと同じように絶対指定と相対指定の両方で指定することができる．
また，指定する際に基準とする位置を"{\it base}\verb|(|{\it value}\verb|)|"として指定できるようにした．
この指定を基準指定と呼ぶ．
ここで，{\it base}は，{\tt X}の指定の場合，{\tt l}か{\tt c}か{\tt r}であり，それぞれ領域の左端，横方向の中央，右端を指す．
また，{\tt Y}の指定の場合は，{\tt t}か{\tt m}か{\tt b}であり，それぞれ領域の上端，縦方向の中央，下端を指す．

相対指定の際に基準指定することにより，同じ位置を様々な記述方法を用いて指定できる．
例えば，{\tt l(100\%)}と{\tt r(0\%)}，{\tt c(50\%)}は領域の右端を指定し，{\tt l(50\%)}と{\tt r(-50\%)}，{\tt c(0\%)}は領域の横方向の中央を指す．
同じように{\tt b(100\%)}と{\tt t(0\%)}，{\tt m(50\%)}は下端を指定し，{\tt b(50\%)}と{\tt t(-50\%)}，{\tt m(50\%)}は縦方向の中央を指す．

基準指定は，原点を基準とした指定しか行えない絶対指定のために導入した．
基準指定が行えない場合，"右端から5ピクセル"という指定ができなくなってしまう．
これは，図形をデバイス座標系へマッピングしない限り，図形の大きさをピクセル単位で知ることができないからである．
基準指定を行えば"右端から5ピクセル"という指定は{\tt r(5px)}と記述することで行える．

図形の位置とサイズは描画領域を表し，この描画領域に内接するように図形が描画される．
楕円形や扇形はこの描画領域の中心を円の中心として描かれる．

図の形状が線分({\tt Line})，矢印({\tt Arrow})のときは始点と終点，多角形({\tt Polygon})は各頂点を{\tt Points}というメンバを用い座標を指定する．
{\tt Points}の説明を以下に述べる．

\begin{description}
{\nopagebreak
\item[\texttt{Points}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 線分({\tt Line})，矢印({\tt Arrow})は始点と終点，多角形({\tt Polygon})は各頂点を指定する．これらの形状の時は必須である
    \item[値] 位置指定形式の文字列の配列
    \end{description}
}
\end{description}

図の形状が扇形({\tt Pie})のとき，扇形の開始角度，開口角度を{\tt Arc}というメンバを用いて定義する．
{\tt Arc}の説明を以下に述べる．

\begin{description}
{\nopagebreak
\item[\texttt{Arc}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 扇形の開始角度，開口角度を指定する．省略した場合は"{\tt 0,90}"となる
    \item[値] 数値2つの配列．1つ目の要素が開始角度，2つ目の要素が開口角度である
    \end{description}
}
\end{description}

図の形状が文字列({\tt Text})の場合，{\tt Text}というメンバで描画する文字列を，{\tt Font}でフォントの設定を指定できる．
{\tt Text}の説明を以下に述べる．

\begin{description}
{\nopagebreak
\item[\texttt{Text}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 描画する文字列を指定する．省略した場合は文字列を描画しない
    \item[値] 文字列．
    \end{description}
}
\item[\texttt{Font}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 描画する文字列の色，透明度，フォント，サイズ，スタイル，領域内での位置を指定する．
    \item[値] オブジェクト．オブジェクトのメンバとして以下が使える
    
        \begin{description}
        {\nopagebreak
        \item[\texttt{Color}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 文字列の色．省略した場合，"{\tt 000000}"となる
            \item[値] 文字列．ARGBあるいはRGBを各8bitで表現したものを16進法表記で記述する．Aは透明度である．
            \end{description}
        }
        \vspace{-0.5zw}
        {\nopagebreak
        \item[\texttt{Family}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 文字のフォントを指定する．省略した場合，システムでSansSerifとして設定してあるフォント名になる
            \item[値] 文字列．システムにインストールされているフォント名でなければならない．
            \end{description}
        }
        \vspace{-0.5zw}
        {\nopagebreak
        \item[\texttt{Style}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 文字列のスタイルを指定する．
            \item[値] 文字列．{\tt "Bold"}：太字，{\tt "Italic"}：斜体，{\tt "Regular"}：標準，{\tt "Strikeout"}：中央線付き，{\tt "Underline"}：下線付きのいずれか
            \end{description}
        }{\nopagebreak
        \item[\texttt{Alpha}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 文字列の透明度．省略した場合，255になる
            \item[値] 数値．0～255の値
            \end{description}
        }{\nopagebreak
        \item[\texttt{Size}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 文字列のサイズ
            \item[値] 数値．単位はポイントである
            \end{description}
        }{\nopagebreak
        \item[\texttt{Align}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 文字列の領域内での位置
            \item[値] 文字列．{\tt "BottomCenter"}：下端中央，{\tt "BottomLeft"}：下端左寄せ，{\tt "BottomRight"}：下端右寄せ，{\tt "MiddleCenter"}：中段中央，{\tt "MiddleLeft"}：中段左寄せ，{\tt "MiddleRight"}：中段右寄せ，{\tt "TopCenter"}：上端中央，{\tt "TopLeft"}：上端左寄せ，{\tt "TopRight"}：上端右寄せのいずれか
            \end{description}
        }
        \end{description}
    \end{description}
\end{description}

図の形状が文字列({\tt Text})以外の場合，{\tt Fill}というメンバで塗りつぶしの色，{\tt Alpha}で塗りつぶしの透明度，{\tt Pen}で図形の縁取り線を指定できる．
これらの説明を以下に述べる．

\begin{description}
{\nopagebreak
\item[\texttt{Fill}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 塗りつぶしの色．省略した場合，"{\tt ffffff}"となる
    \item[値] 文字列．ARGBまたはRGBを各8bitで表現したものを16進法表記で記述する．Aは透明度である．
    \end{description}
}
\vspace{-1zw}
{\nopagebreak
\item[\texttt{Alpha}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 塗りつぶしの色の透明度．省略した場合，255となる
    \item[値] 数値．0～255の値
    \end{description}
}
\vspace{-1zw}
\item[\texttt{Pen}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 縁取り線を指定する．
    \item[値] オブジェクト．オブジェクトのメンバとして以下が使える
    
        \begin{description}
        {\samepage
        \item[\texttt{Color}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 線の色．省略した場合，"{\tt 000000}"となる
            \item[値] 文字列．ARGBあるいはRGBを各8bitで表現したものを16進法表記で記述する．Aは透明度である
            \end{description}
        }{\nopagebreak
        \item[\texttt{Alpha}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 文字列の透明度．省略した場合，255になる
            \item[値] 数値．0～255の値
            \end{description}
        }{\nopagebreak
        \item[\texttt{Width}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 線の幅．省略した場合は，1となる
            \item[値] 数値
            \end{description}
        }
        \clearpage
        {\nopagebreak
        \item[\texttt{DashStyle}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 線種の指定．省略した場合，"{\tt Solid}"となる
            \item[値] 文字列．{\tt "Dash"}：ダッシュ，{\tt "DashDot"}：ダッシュとドットの繰り返し，{\tt "DashDotDot"}：ダッシュと 2 つのドットの繰り返し，{\tt "Dot"}：ドット，{\tt "Solid"}：実線，のいずれか
            \end{description}
        }
        \end{description}
    \end{description}
\end{description}

\ref{subsec:visualization}小節において，図形を参照する際に引数を与えることができ，任意の属性に引数の値を割り当てることができると述べた．
そのため，与えられた引数は，"{\tt ARG}{\it n}"で参照できることとした．

表\ref{shapeSample}において，図形{\tt svcShapes}は3つの基本図形(四角形，文字列，文字列)で構成されており，四角形の{\tt Pen}の{\tt Color}と{\tt Fill}が"\verb|${ARG0}|"，文字列のそれぞれの{\tt Text}が"\verb|${ARG1}|"，"\verb|${ARG2}|"となっている．
これは，図形{\tt svcShapes}が3つの引数をもつことを示している．
たとえば，可視化ルールにおいて図形{\tt svcShapes}を参照する場合は，\verb|svcShapes(ff0000,act_tsk,ercd=0)|のように記述する．
この場合，1つ目の引数として"{\tt ff0000}"，2つ目の引数として"{\tt act\_tsk}"，3つ目の引数として"{\tt ercd=0}"を与えており，それぞれが．\verb|${ARG0}|，\verb|${ARG1}|，\verb|${ARG2}|と置き換えられる．
引数をとらない図形を参照する場合は，図形の名前のみで参照できる．

このように，図形に引数を与えることで，図形の属性を外部から指定できるようになり，属性違いのために組み合わせ毎に図形を多量に定義しなければならないような状況を避けることができる．

\subsubsection{可視化ルールの定義}

可視化ルールの定義は，\ref{subsec:visualization}小節にて述べた可視化ルールを形式化したものである．

可視化ルールの定義は{\tt VisualizeRules}というメンバ名の値にオブジェクトとして記述する．
このオブジェクトのメンバ名には可視化ルールの名前を記述する．
そして，その値に可視化ルールの定義を記述する．

表\ref{visualizeRuleSample}に{\tt toppers}をターゲットとする可視化ルールを定義した例を示す．
例では，{\tt taskStateChange}と{\tt callSvc}の2つの可視化ルールを定義している．

{\begin{table}[p]
\footnotesize
\bkcounttrue
\begin{breakbox}
\setlength{\baselineskip}{\normalbaselineskip}
\begin{verbatim}
{
  "toppers":{
    "VisualizeRules":{
      "taskStateChange":{
        "DisplayName":"状態遷移",
        "Target":"Task",
        "Shapes":{
          "stateChangeEvent":{
            "DisplayName":"状態",
            "From":"${TARGET}.state",
            "To"  :"${TARGET}.state",
            "Figures":{
              "${FROM_VAL}==RUNNING" :"runningShapes",
              "${FROM_VAL}==RUNNABLE":"runnableShapes"
            }
          },
          "activateHappenEvent":{
            "DisplayName":"起動",
            "When"   :"${TARGET}.activate()",
            "Figures":"activateShapes"
          }
        }
      },
      "callSvc":{
        "DisplayName":"システムコール",
        "Target":"Task",
        "Shapes":{
          "callSvcEvent":{
            "DisplayName":"システムコール",
            "From":"${TARGET}.enterSVC()",
            "To"  :"${TARGET}.leaveSVC(${FROM_ARG0})",
            "Figures":{
              "${FROM_ARG0}==slp_tsk||${FROM_ARG0}==dly_tsk"
                :"svcShapes(ff0000,${FROM_ARG0}(${FROM_ARG1}),${TO_ARG1})",
              "${FROM_ARG0}!=slp_tsk&&${FROM_ARG0}!=dly_tsk"
                :"svcShapes(ffff00,${FROM_ARG0}(${FROM_ARG1}),${TO_ARG1})"
            }
          }
        }
      }
    }
  }
}
\end{verbatim}
\end{breakbox}
\caption{可視化ルールファイルで可視化ルールを定義した例}
\label{visualizeRuleSample}
\end{table}}

可視化ルールの定義に用いるメンバは{\tt DisplayName}，{\tt Target}，{\tt Shapes}である．
これらについて，以下に詳述する．

\begin{description}
{\nopagebreak
\item[\texttt{DisplayName}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 可視化ルールの表示名．省略した場合は可視化ルールの名前になる
    \item[値] 文字列
    \end{description}
}{\nopagebreak
\item[\texttt{Target}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 可視化ルールを適用するリソースタイプ
    \item[値] 文字列
    \end{description}
}
\clearpage
{\nopagebreak
\item[\texttt{Shapes}] \mbox{}
    \vspace{-1zw}
    \begin{description}
    \setlength{\itemsep}{-1.5\itemsep}
    \item[説明] 図形群の定義を記述する
    \item[値] オブジェクト．メンバ名に図形群の名前，メンバの値として図形群の定義をオブジェクトとして与える．その際，以下のメンバが使える
    
        \begin{description}
        {\samepage
        \item[\texttt{DisplayName}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 図形群の表示名．省略した場合は図形群の名前になる
            \item[値] 文字列
            \end{description}
        }{\nopagebreak
        \item[\texttt{From}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 図形群を構成する図形のワールド変換に適用される開始イベント
            \item[値] イベント指定形式文字列
            \end{description}
        }{\nopagebreak
        \item[\texttt{To}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 図形群を構成する図形のワールド変換に適用される終了イベント
            \item[値] 標準形式トレースログの形式の文字列
            \end{description}
        }{\nopagebreak
        \item[\texttt{When}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 図形群を構成する図形のワールド変換に適用されるイベント．開始時刻と終了時刻が同じ場合に用いる
            \item[値] イベント指定形式文字列
            \end{description}
        }{\nopagebreak
        \item[\texttt{Figures}]  \mbox{}
            \vspace{-0.25zw}
            \begin{description}
            \setlength{\itemsep}{-1.5\itemsep}
            \item[説明] 図形群を構成する図形の定義
            \item[値] 文字列，配列，オブジェクトのいずれか．文字列の場合は図形の参照，オブジェクトの場合はメンバ名に条件，値に図形の参照を記述する．配列の要素には，これら文字列かオブジェクトを記述できる．オブジェクトと配列はネストして記述することができる．
            \end{description}
        }
        \end{description}
    
    \end{description}
}
\end{description}

可視化ルールのイベント期間の指定には，イベント期間として適用するトレースログを，条件として必要な情報を標準形式トレースログの形式で記述する．
たとえば，リソースの属性が変わったときをイベント期間に指定したいときは，標準形式トレースログの形式で属性名まで記述すればよい．
また，属性の値が特定の値に変わったときをイベント期間に指定したいときは，標準形式トレースログの形式で値まで記述すればよい．
リソースの振る舞いをイベント期間として指定したい場合は，標準形式トレースログの形式で振る舞い名と"{\tt ()}"を記述すればよく，特定の引数をとるときに条件を絞りたいときはその引数を"{\tt ()}"内に記述すればよい．

イベント期間の指定でリソースを指定する際，{\tt Target}指定がしてある場合は，\verb|${TARGET}|という置換マクロで，リソースファイルで定義したリソースタイプ{\tt Target}の各リソースの名前に適時置換することができる．

表\ref{visualizeRuleSample}の{\tt taskStateChange}を例に説明する．
{\tt Target}には{\tt Task}が指定してある．
このとき，リソースファイルにリソースタイプ{\tt Task}のリソースとして{\tt Task1}，{\tt Task2}，{\tt Task3}が定義してある場合は，{\tt From}と{\tt To}の\verb|${TARGET}|はこれらのリソース名に置換され，{\tt Task1.state}，{\tt Task2.state}，{\tt Task3.state}となる．

{\tt Target}指定がないとき，{\tt To}を指定する際に{\tt From}で一致したトレースログのリソースを指定したい場合は，置換マクロ\verb|${FROM_TARGET}|を記述すればよい．
また，{\tt From}で属性値の変化イベントを指定したとき，{\tt From}で一致したトレースログの属性の値を{\tt To}で指定したいときは置換マクロ\verb|${FROM_VAL}|を記述すればよい．
同じように，{\tt From}で振る舞いの発生イベントを指定したとき，{\tt From}で一致したトレースログの振る舞いの引数を{\tt To}で指定したいときは置換マクロ\verb|${FROM_ARG|{\it n}\verb|}|を記述すればよい．
{\it n}には何番目の引数かを0からで記述する．

これらの置換マクロは図形の参照を記述する際にも利用できる．
{\tt To}で一致したトレースログの属性値変化の値は\verb|${TO_VAL}|，振る舞いの引数は\verb|${TO_ARG|{\it n}\verb|}|という置換マクロで指定できる．
また，{\tt Target}指定がないときに{\tt To}で一致したトレースログのリソースを指定したいときは置換マクロ\verb|${TO_TARGET}|を用いればよい．
イベント期間指定が{\tt When}のときは，一致したトレースログのリソースを\verb|${TARGET}|，属性の値を\verb|${VAL}|，振る舞いの引数を\verb|${ARG|{\it n}\verb|}|で指定する．


\section{TraceLogVisualizerのその他の機能}

本節では，標準形式変換と可視化データ生成の他にTLVが備える機能について詳述する．

\subsection{マーカー}
TLVでは，可視化表示部にマーカーと呼ぶ印を指定の時刻に配置することができる
注目するべきイベントの発生時刻にマーカーを配置することで，可視化表示内容の理解を補助することができる．

マーカーとマーカーの間には，その間の時間が表示されるので，ソフトウェアの計測を行うことができる．
マーカーには名前を付けることができ，色の指定が可能である．
また，マーカーはマウス操作で選択することができ，拡大縮小などの各種操作に利用される．
マーカーは階層構造で管理し，階層ごとに表示の切り替え，マーカー間時間の表示などを行うことができる．

\subsection{可視化表示部の制御}

可視化表示ツールでは，可視化表示部を制御する操作性が使い勝手に大きく影響するため，TLVでは目的や好みに合わせて様々な操作で制御を行えるようにした．
TLVでは，可視化表示部の制御として，表示領域の拡大縮小，移動を行うことができる．
これらの操作方法として，キーボードによる操作，マウスによる操作，値の入力による操作の3つの方法を提供した．

マウスによる操作は，クリックによる操作，ホイールによる操作，選択による操作がある．
クリックによる操作はカーソルを虫眼鏡カーソルに変更してから行う．
左クリックでカーソル位置を中心に拡大，右クリックで縮小を行う．
また，左ダブルクリックを行うことでクリック箇所が中心になるように移動する．
ホイールによる操作は，コントロールキーを押しながらホイールすることで移動を行い，シフトキーを押しながら上へホイールすることでカーソル位置を中心に拡大，下へスクロールすることで縮小する．
選択による操作では，マウス操作により領域を選択し，その領域が表示領域になるように拡大する．

キーボードによる操作は，可視化表示部において方向キーを押すことで行い，微調整するのに適している．
左キーで表示領域を左に移動し，右キーで右に移動する．
上キーでカーソル位置，または選択されたマーカーを中心に表示領域を縮小し，下キーで拡大する．

値の入力による操作では，より詳細な制御を行うことができる．
可視化表示部の上部にはツールバーが用意されており，そこで表示領域の開始時刻と終了時刻を直接入力することができる．

\subsection{マクロ表示}

TLVの要求分析を行った際，可視化表示部で拡大した場合に全体の内どの領域を表示しているのかを知りたいという要求があった．
そのため，TLVでは，マクロビューアというウィンドウを実装した．

マクロビューアでは，トレースログに含まれるイベントの最小時刻から最大時刻までを常に可視化表示しているウィンドウで，可視化表示部で表示している時間を半透明の色で塗りつぶして表示する．
塗りつぶし領域のサイズをマウスで変更することができ，それに対応して可視化表示部の表示領域を変更することができる．

マクロビューアでは可視化表示部と同じように，キーボード，マウスにより拡大縮小，移動の制御を行うことができる．

\subsection{トレースログのテキスト表示}

TLVでは，標準形式トレースログをテキストで表示するウィンドウを実装した．
ここでは，トレースログの内容を確認することができる．

可視化表示部とテキスト表示ウィンドウは連携しており，テキスト表示ウィンドウでマウスを移動すると，カーソル位置にあるトレースログの時刻にあわせて可視化表示部のカーソルが表示されたり，ダブルクリックすることで対応する時刻に可視化表示部を移動することができる．
また，可視化表示部でダブルクリックすることで，ダブルクリック位置にある図形に対応したトレースログが，テキスト表示ウィンドウの先頭に表示されるようになっている．

\subsection{可視化表示項目の表示非表示切り替え}

TLVでは，可視化表示する項目を可視化ルールにより変更，追加することができるが，それらの表示を可視化ルールやリソースを単位で切り替えることができる．
これらの操作は，リソースウィンドウと可視化ルールウィンドウで行う．
リソースウィンドウではリソースファイルで定義されたリソースを，リソースタイプやグループ化可能な属性毎にツリービュー形式で表示しており，チェックの有無でリソース毎に表示の切り替えを行える．
同じように，可視化ルールウィンドウでは，可視化ルールごとに表示の切り替えを行える．
