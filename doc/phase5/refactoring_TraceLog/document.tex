\documentclass[a4j]{jsarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{listings}
\usepackage{here}
\newcommand{\figref}[1]{図\ref{#1}}

\lstset{language=C,%
        basicstyle=\footnotesize,%
        commentstyle=\textit,%
        classoffset=1,%
        keywordstyle=\bfseries,%
	frame=tRBl,framesep=5pt,%
	showstringspaces=false,%
        numbers=left,stepnumber=1,numberstyle=\footnotesize%
	}%


\title{組込みRTOS向けアプリケーション開発支援ツール\\
TLV（トレース ログ ヴィジュアライザー）\\
フェーズ5 リファクタリング仕様書}
\begin{document}
\maketitle
\titlepage

\section*{改訂履歴}
\begin{table}[h]
 \centering
 \begin{tabular}{|c|c|c|c|} \hline
  版番& 日付&    更新内容& 更新者\\ \hline\hline
  1.0 & 10/4/23& 新規作成& 市原大輔\\ \hline
  1.1 & 10/5/11& \shortstack{リファクタリング後の例変更。説明の具体化・明確化。\\
  クラス図の変更・追加。リファクタリング報告書追加。}& 市原大輔\\ \hline
 \end{tabular}
\end{table}
\clearpage

\tableofcontents
\clearpage

\section{はじめに}
\subsection{本書の目的}
本書の目的は、文部科学省先導的ITスペシャリスト育成推進プログラム「OJLに
  よる最先端技術適応能力を持つIT人材育成拠点の形成」プロジェクトにおけ
る、OJL科目ソフトウェア工学実践研究の研究テーマである「組込みRTOS向けア
  プリケーション開発支援ツールの開発」に対して、その開発するソフトウェ
アに対する設計を記述することである。

本書は特に、フェーズ5におけるリファクタリング作業に関する記述を行う。

\subsection{本書の適用範囲}
本書は、組込みMPRTOS向けアプリケーション開発支援ツールの開発プロジェク
ト（以下本プロジェクト）のフェーズ5におけるリファクタリング作業に関する
記述を行う。

\subsection{用語の定義/略語の説明}

\begin{table}[h]
 \centering
 \caption{用語定義}
 \begin{tabular}{|p{8em}|p{36em}|} \hline
  用語・略語& 定義・説明\\ \hline \hline
  TLV& Trace Log Visualizer\\ \hline
  MPRTOS& マルチプロセッサ対応リアルタイムオペレーティングシステム\\
  \hline
  トレースログファイル&
      RTOSのトレースログ機能を用いて出力したトレースログや、
      シミュレータなどが出力するトレースログをファイルにしたもの\\
  \hline
  標準形式トレースログファイル&
      本ソフトウェアが扱うことの出来る形式をもつトレースログファイル。
      各種トレースログファイルは、この共通形式トレースログファイルに
      変換することにより本ソフトウェアで扱うことが出来るようになる。 \\
  \hline
  変換ルール  &
  トレースログファイルを標準形式トレースログファイルに変換する際に用いられるルール。
  \\
  \hline
  可視化ルール  &
  標準形式トレースログファイルを可視化する際に用いられるルール。
  \\
  \hline
  TLVファイル &
      本ソフトウェアが中間形式として用いるファイル。
      前述の標準形式トレースログファイルは、このTLVファイルの一部である。 \\
  \hline
  \\
  \hline
  EBNF &
      Extended Backus?Naur Formの略。 \\
  \hline

 \end{tabular}
\end{table}

\subsection{概要}
本書では、組込みMPRTOS向けアプリケーション開発支援ツールの
ソフトウェアの仕様を記述する。
本書は特に、フェーズ5におけるリファクタリング作業に関する記述を行う。

\part{リファクタリング仕様書}
\section{概要説明}
\subsection{リファクタリングを実施する理由}
現状の\verb!TraceLog!クラス(クラス概要は\ref{sec:tl}参照)では、標準形式トレースログのパースにおいて、Listing\ref{rex}のような
複雑な正規表現を計8回適用している。これは、Objectなどの要素1つにつき1行の正規表現で
取得するためである。こうすることで、TimeやValue等の有無に関わらず
\footnote{可視化ルールファイルには、Timeがない、Valueがない、AttributeNameがない等といった
不完全な標準形式トレースログが記述されている。}
パースできるようにしている。
しかし、このような複雑な正規表現は、可読性が低く保守が難しいため、リファクタリングを実施する。

リファクタリング後のTLVは、標準形式トレースログのパースを専用のパーサに任せる。
パーサは、TLV変換ルール・可視化ルールマニュアル(rule-maual.pdf)の「2.1.2標準形式トレースログの定義」
にあるEBNFのようにコードを記述することで、構文を直感的に理解できるようになる。
コード例をListing\ref{refacted}に示す。

また、重複したコードおよび生成規則変更時の変更箇所も減らすことができるため、保守性も向上する。
例えば、Timeを囲む記号\verb!"[","]"!を\verb!"<",">"!にするとき、従来の正規表現を用いた
方法では、8行すべての正規表現を変更する必要があるが、リファクタリング後は1箇所で済むようになる。
生成規則を追加する場合でも、従来の方法では8行の正規表現の中から変更箇所を探さねばならないが、
リファクタリング後は、EBNFのように記述されているため、変更箇所が明確であるので見落としを減らせる。
しかしながら、このような構文の変更は稀であるため、一番のメリットは構文を直感的に理解できるようになる
ことである。

\begin{lstlisting}[caption=リファクタリング前のコード例,label=rex]
m = Regex.Match(_log, @"^(\[[^\]]+\])?(?<objectType>[^\[\]\(\)\.]+)\([^\)]+\)(\.[^\s]+)?$");
	if (m.Success)
		ObjectType = m.Groups["objectType"].Value;
	HasObjectType = m.Success;
\end{lstlisting}

\begin{lstlisting}[caption=リファクタリング後に表現したいコード例,label=refacted]
public abstract class MiniMLParsers<TInput> : CharParsers<TInput>{
    public MiniMLParsers() {
        Whitespace = Rep(Char(' ').OR(Char('\t').OR(Char('\n')).OR(Char('\r'))));
        WsChr =  chr => Whitespace.AND(Char(chr));
        Id =     from w in Whitespace
                 from c in Char(char.IsLetter)
                 from cs in Rep(Char(char.IsLetterOrDigit))
                 select cs.Aggregate(c.ToString(),(acc,ch) => acc+ch);
        Ident =  from s in Id where s != "let" && s != "in" select s;
        LetId =  from s in Id where s == "let" select s;
        InId =   from s in Id where s == "in" select s;
        Term1 = (from x in Ident 
                 select (Term)new VarTerm(x))
                .OR(
                (from u1 in WsChr('(') 
                 from t in Term 
                 from u2 in WsChr(')') 
                 select t));
        Term =  (from u1 in WsChr('\\')
                 from x in Ident
                 from u2 in WsChr('.')
                 from t in Term
                 select (Term)new LambdaTerm(x,t))
                .OR(
                (from letid in LetId
                 from x in Ident
                 from u1 in WsChr('=')
                 from t in Term
                 from inid in InId
                 from c in Term
                 select (Term)new LetTerm(x,t,c)))
                .OR(
                (from t in Term1
                 from ts in Rep(Term1)
                 select (Term)new AppTerm(t,ts)));
        All =    from t in Term from u in WsChr(';') select t;
    }
   
    public Parser<TInput, char[]> Whitespace;
    public Func<char, Parser<TInput, char>> WsChr;
    public Parser<TInput, string> Id;
    public Parser<TInput, string> Ident;
    public Parser<TInput, string> LetId;
    public Parser<TInput, string> InId;
    public Parser<TInput, Term> Term;
    public Parser<TInput, Term> Term1;
    public Parser<TInput, Term> All;
}
\end{lstlisting}



\subsection{リファクタリングを実施する対象}\label{sec:tl}
リファクタリング対象は、\verb!TraceLog!クラス、特にそのコンストラクタである。
この\verb!TraceLog!クラスは、標準形式トレースログを構成するトークンを保持し、
標準形式トレースログを用いた処理(可視化表示など)を容易にする。

現在、標準形式トレースログのパースに正規表現を用いている箇所を
パーサを用いるように、\verb!TraceLog!コンストラクタを変更する。


\newpage
\section{変更内容}
\subsection{クラス構成}
正規表現によるパース(\verb!Regex!クラスおよび\verb!Match!クラス)を廃止し、
標準形式トレースログ用のパーサを作成して、\verb!TraceLog!クラスはそのパーサへパース処理を委譲する。
これにより、現在はパースの実装が\verb!TraceLog!クラスに直書きされているため
パースの実装方法を変更するのが困難であるのが、
\verb!TraceLog!クラスとパースの実装を分離することでパーサの交換が容易になり、
パーサの実装方法変更が容易になる。

今回の変更に伴う影響範囲は、\verb!TraceLog!クラス以外に存在しない。
リファクタリング前後のクラス図を図\ref{bclass},\ref{aclass}に示す。

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 500]{bclass.png}
\caption{リファクタリング前のクラス構成}\label{bclass}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.8\hsize,bb=0 0 660 500]{aclass.png}
\caption{リファクタリング後のクラス構成}\label{aclass}
\end{figure}


% \subsection{処理の流れ}
% リファクタリング前の処理の流れは、図\ref{before}のように、
% \verb!TraceLog!コンストラクタにて正規表現を用いたパースを行っている。

% リファクタリング後の処理の流れは、図\ref{after}のように、
% \verb!TraceLog!コンストラクタでパーサクラスのメソッドを呼び、
% パーサクラスにて標準形式トレースログのパースを行う。
% パースが終了したら、パーサクラスから結果を受け取り、各値を設定する。

% \begin{figure}[H]
% \centering
% \includegraphics[width=0.8\hsize,bb=0 0 660 512]{before.png}
% \caption{リファクタリング前の標準ログ変換処理}\label{before}
% \end{figure}

% \begin{figure}[H]
% \centering
% \includegraphics[width=0.8\hsize,bb=0 0 660 500]{after.png}
% \caption{リファクタリング後の標準ログ変換処理}\label{after}
% \end{figure}


\subsection{パーサの構成}
パーサの実装は、コードでEBNFを表現し、直感的に理解できるようにする。

例として、HaskellのパーサコンビネータライブラリParsecを参考にした次のURLにあるものが挙げられる
(コードの一部はListing\ref{refacted}参照)。
あくまで例であり、このコードを使用するか、自作など他の実装方法を用いるかは、
デバッグの容易さ、実装のしやすさ、可読性、実行速度などの要素により決定する。


\begin{verbatim}
LukeH's WebLog : Monadic Parser Combinators using C# 3.0
http://blogs.msdn.com/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
\end{verbatim}


\newpage
\part{リファクタリング報告書}
\section{概要}
本書は、Phase5で行ったリファクタリングにより変更・追加された箇所、および、
リファクタリング後のシーケンスを説明し、今回採用しなかった手法との比較や今回の実装の採用理由を記述する。


\section{コード設計}
ここでは、リファクタリングの目標であった「EBNFを表現し、直感的に理解できる」コードの紹介と、
小節にて実装に用いた手法・概念および主要メソッドの説明をする。

まず、「EBNFを表現」したコードの例をListing\ref{code1}に示す。

\begin{lstlisting}[caption=「コードでEBNFを表現」したコード例(最終更新日現在),label=code1]
var line = Char('[').Time().Char(']').Event();
...
var object_ = 
	ObjectTypeName().Char('(').AttributeCondition().Char(')')
	.OR().
	ObjectName();
...			
var typeName = Many1(() => AnyCharOtherThan('(', ')', '.'));
\end{lstlisting}


これは、次のEBNFをパースすることを示している(rule-manual.pdfの2．1.2参照)。


\begin{lstlisting}[caption=Listing\ref{code1}が表す実際のEBNF,label=ebnf1]
TraceLogLine = "[", Time, "]", Event;

Resource = ResourceTypeName, "(", AttributeCondition, ")"
	 | ResourceName;

ResourceTypeName = /[0-9a-Z_]+/;
\end{lstlisting}



このように、Listing\ref{code1}はEBNFを表現しており、正規表現によるパージングより可読性が
向上している。Listing\ref{code1}は完全なものではなく、実際にはListing\ref{code2}
のような解析メソッド内に記述され、それを組み合わせることでListing\ref{code1}を実現している。

\begin{lstlisting}[caption=解析メソッド例,label=code2]
public ITraceLogParser ObjectTypeName()
{
	Begin();

	var typeName = Many1(() => AnyCharOtherThan('(', ')', '.'));

	typeName.ObjectTypeValue = Result();
	return (ITraceLogParser)typeName.End();
}
\end{lstlisting}

\subsection{利用した概念・手法}
\subsubsection{再帰下降パーサ}
今回、実装したパーサは、スタックを利用した再帰下降パーサであり、バックトラッキングを用いている。
これは、EBNFのようにトップダウンに記述されているものを表現するのに適しているが、
バックトラッキングによる処理効率低下が懸念される。

\subsubsection{パーサ・コンビネータ}
パーサ・コンビネータとは、パーサとパーサを組み合わせることのできるコンビネータを指す。
具体的には、Manyメソッド、Many1メソッド、ORメソッドが挙げられる。
これにより、EBNFの表現やLL(k)文法のパージングを可能にしている。
しかしながら、左再帰性の除去が必要である。

\subsubsection{NullObjectパターン}


\subsection{主要メソッドの説明}
\subsubsection{Beginメソッド}
\subsubsection{Endメソッド}
\subsubsection{Resultメソッド}
\subsubsection{ORメソッド}
\subsubsection{Manyメソッド}
\subsubsection{Many1メソッド}

\section{クラス設計}
リファクタリング後のクラス図を図\ref{class}に示す。

\begin{figure}[H]
\centering
\includegraphics[width=1.\hsize,bb=0 0 728 537]{class.png}
\caption{リファクタリング後のクラス構成}\label{class}
\end{figure}

\subsection{Parserクラス}
\subsection{StackForParserクラス}
\subsection{InputStreamForParserクラス}
\subsection{NullObjectForParserクラス}
\subsection{TraceLogParserクラス}
\subsection{NullObjectOfTraceLogParserクラス}
\subsection{IParserクラス}
\subsection{ITraceLogParserクラス}


\section{シーケンス}

\section{他手法との比較}
\subsection{性能比較}



\end{document}
