% Sample file for the use of compsoft style file.
%
\documentclass[tokushusoftwareronbun]{compsoft}
%
% optional argument としては
%       ronbun, Eronbun, softwareronbun, tutorial, kaisetsu, topics, 
%       softwareshokai, forum, zadankai, bookreview, pioneer, memoriam,
%       tokushuronbun, Etokushuronbun, tokushusoftwareronbun, 
%       tokushututorial, tokushukaisetsu, 
%       tokushutopics, tokushusoftwareshokai,
%       suisenronbun, Esuisenronbun, 
%       kantogen, tokushutobira, gakkaikiji, henshu
% などがある．default は ronbun になっている.
%
% 英語論文の場合は Eronbun, Etokushuronbun（特集号の場合）, 
% Esuisenronbun（ワークショップ推薦論文の場合）を選択する．
%
% tokushuronbun, Etokushuronbun, tokushusoftwareronbun,
% tokushututorial, tokushukaisetsu, tokushutobira, 
% suisenronbun, Esuisenronbun を optionとして選んだとき
% には，preambleの中で
%       \def\tokushutitle{...} または  \def\suisentitle{...}
% のようにして特集名またはワークショップ名を定義する．
%
% アブストラクトは，日本語の論文／解説／チュートリアルの場合は和文と英文
% の双方をつける．英語論文の場合は英文 (\Eabstract) だけでよい．
%
% 巻数，号数，page もpreambleの中でsetcounterすること．
% これらの番号は印刷所で最終調整される．
% 
% Preamble
\setcounter{巻数}{16}
\setcounter{号数}{5}
\setcounter{page}{1}

\usepackage[dvips]{graphics}

% ユーザが定義したマクロなどはここに置く．ただし学会誌のスタイルの
% 再定義は原則として避けること．
\usepackage{here}
\usepackage{morefloats}
\usepackage{fancybox}
\usepackage{fancyvrb}
\usepackage{mymacros}

\begin{document}
\title{トレースログ可視化ツール \\ TraceLogVisualizer(TLV)}
%
% 和文論文の場合，姓と名の間には半角スペースを入れ，
% 複数の著者の間は全角スペースで区切る
%
\author{後藤 隼弐　本田 晋也　長尾 卓哉　高田 広章%
%
% ここにタイトル英訳（英文の場合は和訳）を書く．
%
\thanks{Visualization Tool for Trace Log. TraceLogVisualizer (TLV)}
%
% ここに著者英文表記(英文の場合は和文表記）および所属(和文および英文) を書く．
% 複数著者の所属はまとめてよい．
%
\thanks{Junji Goto, Hiroaki Takada, 名古屋大学 大学院情報科学研究科, 
Graduate School of Information Science, Nagoya University.}
\thanks{Shinya Honda, Takuya Nagao, 名古屋大学 大学院情報科学研究科 附属組込みシステム研究センター,
Center for Embedded Computing Systems,
Graduate School of Information Science, Nagoya University
}
%
% 以下は出典情報．ページ番号は印刷所で入れます．
% 1行で収めるために文字間隔を少し詰めている．
%
\thanks{}
%
% 記事カテゴリと受付日．不明の場合はxxxx年yy月zz日などでよい．
%
\thanks{[ソフトウェア論文] xx年x月xx日受付.}}
%
% 和文アブストラクト
\Jabstract{%
マルチコア環境で動作するソフトウェアのデバッグには，トレースログの解析が
有効であるが，開発者がトレースログを直接扱うのは非効率的である．そのため，
トレースログを可視化することにより解析を支援するツールが存在するが，これ
らは汎用性や拡張性に乏しいという問題がある．そこで我々は，これらの問題を
解決したトレースログ可視化ツール(TLV)を開発した．TLVは，変換ルールによ
りトレースログを標準形式に変換することで汎用性を実現し，可視化ルールによ
り可視化表示項目の追加・変更を可能にすることで拡張性を実現している．TLV
を用いて形式の異なる3種類のトレースログを可視化し，汎用性と拡張性を確認
した．
}
%
% 英文アブストラクト（本サンプルの原論文にはなし）
\Eabstract{
It is effective to debug software executed in multi-core processors by 
analyzing a trace log, but it is inefficient that developers analyze the 
trace log directly. Therefore, some visualization tools for the trace 
log had been developed before now, but there are two problems, lacks of 
general versatility and expandability. To that end, we developed 
TraceLogVisualizer(TLV), a visualization tool for the trace log that 
solved those problems. In this paper, we will discuss requirements to 
achieve general versatility and expandability, and how we achieved them.
}
%
\maketitle

\section{はじめに}
\label{sec1}

近年，組込みシステムにおいても，マルチコアプロセッサの利用が進んでいる．
その背景には，シングルプロセッサの高クロック化による性能向上効果の限界や，
消費電力の増大がある．マルチコアプロセッサシステムでは，処理の並列性を高
めることにより性能向上を実現するため，消費電力の増加を抑えることができる．
しかし，マルチコアプロセッサ環境で動作するソフトウェアのデバッグを行うの
は，シングルプロセッサ環境に比べ困難であるという問題がある．これは，各コ
アが非同期的に並列動作するため，タイミングに依存した再現性の低いバグが発
生する可能性があることや，ハードウェアの制約からコア間の同期精度が低い場
合があり，ブレークポイントやステップ実行を用いた従来のデバッグ手法が有効
ではない場合があるからである．

一方，マルチコアプロセッサ環境で有効なデバッグ手法として，プログラム実行
履歴であるトレースログを解析する手法がある．この手法が有効である理由は，
並列プログラムのデバッグを行う際に必要な情報である，プロセスが，いつ，ど
のプロセッサで，どのように動作していたかを知ることができるからである．し
かしながら，開発者がトレースログを直接解析するのは効率が悪い．図
\ref{traceLogSample}に，2コア上で動作するRTOS(Real-Time Operating 
System)が出力するトレースログの例を示す．図\ref{traceLogSample}の例では，
約430$\mu$sの間に5行のトレースログが出力されており，トレースログを収集す
る時間が長くなれば膨大な量になることを示唆している．取得する情報の粒度を
細かくしたり，処理の複雑さが増すと，出力されるトレースログの量はさらに増
大するため，デバッグを行う際に必要な情報を探し出すのが困難となる．また，
各コアのトレースログは時系列に分散して記録されているため，コア毎の動作を
解析するのが困難である．

\begin{EBNFFileWithExample}{2コア上で動作するRTOSが出力するトレースログの例}
      {traceLogSample}
      {{\tt \ [}{\it time($\mu$s)}{\tt ]:[}{\it core\_id}{\tt ]: }{\it information}}
      {A sample of trace log dumped by RTOS running on dual-core}
[60692484]:[1]: task 4 becomes WAITING.
[60692586]:[2]: leave to sns_ctx state=0.
[60692708]:[1]: dispatch from task 4.
[60692798]:[2]: enter to get_pid p_prcid=304.
[60692914]:[1]: dispatch to task 1.
\end{EBNFFileWithExample}

トレースログの解析を支援する方法として，ツールによるトレースログの可視化
があり，これまでに幾つかのツールが開発されている．具体的には，組込みシス
テム向けデバッガソフトウェアや統合開発環境の一部
\cite{PARTNER-JET,watchpoint,QNXMomentics,eBinder}やUnix系OSのトレースロ
グプロファイラ\cite{LTTV,Chime}などが存在する．しかしながら，これら既存
のツールは，特定の環境(OSやデバッグハードウェア)を対象としているため，可
視化対象となるトレースログの形式が固定されている．そのため，他の環境が出
力するトレースログを可視化することができず，汎用性に乏しいという問題があ
る．また，可視化表示する項目やその表現方法が固定である場合が多く，拡張性
に乏しいという問題もある．

そこで我々は，これらの問題を解決し，汎用性と拡張性を備えたトレースログ可
視化ツールを開発することを目的とし，TraceLogVisualizer(TLV)を開発した．
TLVは，「OJL による最先端技術適応能力を持つIT人材育成拠点の形成」の
OJL(On the Job Learning)の開発テーマとして開発し，オープンソースソフトウ
ェアとして公開している\cite{TLV}．

開発にあたり，我々は，まず，TLV内部でトレースログを一般的に扱えるよう，
トレースログを一般化した標準形式トレースログを定めた．さらに，任意の形式
のトレースログを標準形式に変換するためのルールを変換ルールとして形式化し，
ユーザがツールの外部から指定できる仕組みを提供した．次に，トレースログの
可視化表示項目やその表現方法を指示する仕組みの抽象化を行い，可視化ルール
として形式化した．また，可視化ルールをユーザが外部から指定できる仕組みを
提供した．これにより，TLVでは，トレースログの形式毎に変換ルールと可視化
ルールを外部ファイルとして用意することで可視化が可能であり，汎用性と拡張
性を実現している．

本論文は次のように構成される．まず，2章で既存のトレースログ可視化ツール
について述べる．3章では，汎用性と拡張性を実現するためのトレースログ可視
化ツールの要件と，TLVでの実現方針について述べる．4章では，要件と実現方針
に基づくTLVの設計について述べ，5章では，その実装について述べる．6章では，
複数のトレースログの可視化表示や，可視化表示項目の変更，追加を行い，TLV
の汎用性と拡張性を示す．7章で開発について述べる．最後に，8章でまとめと今
後の課題，展望を述べる．

\section{既存のトレースログ可視化ツールと問題点}

\subsection{既存のトレースログ可視化ツール}

\label{sec:previous}既存のトレースログ可視化表示ツールとしては，組込みシ
ステム向けデバッガソフトウェアや統合開発環境の一部，Unix系OSの可視化ツー
ル，波形表示用ツールなどがある．

組込みシステム向けデバッガソフトウェアには，トレースログを可視化する機能
を持つものがある．京都マイクロコンピュータ株式会社の
PARTNER\cite{PARTNER-JET}はイベントトラッカー，株式会社ソフィアシステム
ズのWatchPoint\cite{watchpoint}は，OSアナライザというトレースログを可視
化する機能を提供している．

%これら組込みシステム向けデバッガソフトウェアの一機能としての可視化ツール
%は，その性質からターゲットとなるOSやプロセッサが限定される．これは，組込
%みシステム向けデバッガは，通常，ターゲットとなるプロセッサが限られており，
%デバッガソフトウェアが対応するOSも限られているからである．また，可視化表
%示したい情報も提供されているものに限られるなど，可視化ツールとしては汎用
%性，拡張性に乏しい．

%\subsection{組込みOS向けの統合開発環境}

また，組込みOS向けの統合開発環境にもOSのトレースログを可視化するツールが
含まれている．QNX Software Systems社の自社のRTOS用の統合開発環境である
QNX Momenticsでは，システムコールや割込み，スレッド状態やメッセージなど
を可視化するQNX System Profiler\cite{QNXMomentics}を提供している．また，
イーソル株式会社のT-Kernel用の統合開発環境であるeBinder\cite{eBinder}に
は，イベントログ取得・解析ツールとしてEvenTrekが付属しており，システムコ
ール，割込み，タスクスイッチ，タスク状態遷移などを可視化することができる．

%このように，商用の組込みOS向けの統合開発環境にはOSの実行履歴を可視化表示
%する機能が搭載されている場合がある．しかしながら，これらは，各ベンダーが
%自社OSの競争力を高めるために提供しているものであり，当然ながら可視化表示
%に対応するOSは自社提供のものに限られている．また，可視化表示する情報も提
%供するものに限られており，表示のカスタマイズ機能もそれほど自由度は高くは
%ない．

%\subsection{Unix系OSのトレースログプロファイラ}

Unix系OSでは，パフォーマンスチューニングや障害解析を目的として，カーネル
の実行トレースを取得しそれを可視化するソフトウェアがいくつか開発されてい
る．Linuxの実行トレースを取得するLTTng\cite{LTTng}には，LTTV\cite{LTTV}
が，Solarisの実行トレースを取得するDtrace\cite{Dtrace}には，
Chime\cite{Chime}が可視化ツールとして提供されている．

%これらの可視化ツールは，サポートするOSがのログ形式をのみをサポートするこ
%とや，可視化表示する項目やその表現方法が固定である．


%\subsection{波形表示ツールの流用}

%任意のOS，アプリケーションのトレースログを可視化表示する手段として，波形
%表示ツールを流用する方法がある．波形表示ツールとは，Verilog等のデジタル
%回路設計用論理シミュレータの実行ログを波形で表示するソフトウェアのことを
%指す．

デジタル回路設計用論理シミュレータの実行ログには，VCD(Value Change Dump)
形式というオープンなファイルフォーマットが存在する．そのため，任意のログ
をVCD形式として出力することにより，これらのツールで可視化表示することが
可能になる．図\ref{fig:GTKWave}に，VCD形式のログの可視化に対応した波形表
示ツールGTKWaveのスクリーンショットを示す．

\begin{figure}[tb]
\begin{center}
\scalebox{0.25}{\includegraphics{img/GTKWave.eps}}
\caption{GTKWave}
\label{fig:GTKWave}
\end{center}
\end{figure}

\subsection{既存のトレースログ可視化ツールの問題点}

既存のトレースログ可視化ツールの多くは，可視化ツールとして単体で存在して
いるわけではなく，トレースログを出力するソフトウェアや開発環境の一部とし
て提供されている．そのため，読み込めるトレースログの形式が出力対象のOSや
ソフトウェアに依存しており，可視化対象となるOS，プロセッサが制限されてし
まっている．

任意の形式のログをVCDのファイル形式に変換することによりログの形式に依存
せず，GTKWaveを利用できるが，VCDはデジタル回路設計用論理シミュレータ用の
論理値を可視化するための形式であるため，表示能力に乏しく，複雑な可視化表
現は難しいという問題がある．

読み込むトレースログの形式を制限しないためには，VCDのようにトレースログ
可視化ツール用に標準化されたトレースログ形式を定める必要があると考えられ
るが，現状，公表されているものではそのようなものは確認できていない．

既存のトレースログ可視化ツールのもうひとつの問題点としては，可視化表示の
項目や形式が，提供されているものに限られていることが挙げられる．既存のト
レースログ可視化ツールで可視化表示の項目を追加，変更したり，可視化表現を
カスタマイズする機能を搭載するものは確認できていない．



\section{要件と実現方針}
\label{sec2}

本章では，トレースログ可視化ツールが汎用性と拡張性を備えるための要件と，
TLVでの実現方針についてそれぞれ説明する．

\subsection{要件}
\label{requirement}

まず，トレースログ可視化ツールの定義，ならびにその汎用性と拡張性の要件を
明確にする．

本研究では，トレースログ可視化ツールを，時系列に記録されたプログラムの実
行履歴をテキスト形式でファイル化したトレースログファイルを読み込み，その
内容をGUIを通じて時系列に可視化表示するツールとする．

可視化表示項目とは，トレースログの内容や出力元の環境，解析の目的などに基
づき区分される可視化表示する情報の単位である．具体的には，RTOSのトレース
ログの場合，``タスクの状態遷移''や``タスクのコア占有率''などが該当する．

汎用性は，ユーザがツールのバイナリを変更することなく，様々な形式のトレー
スログを可視化表示できることとする．すなわち，入力するトレースログの形式
を制限しない．

拡張性は，ユーザがツールのバイナリを変更することなく，容易に可視化表示項
目の追加・変更・削除ができることとする．


\subsection{汎用性の実現方針}
\label{versatillity_policy}

汎用性を実現するために，トレースログの標準形式を定め，可視化表示の仕組み
が標準形式にのみ依存するようにする．そして，任意の形式のトレースログを，
標準形式に変換するためのルールを変換ルールとして形式化し，ユーザが外部か
ら指定できる仕組みを提供する．

トレースログ可視化ツールが汎用性を実現するためには，可視化表示の仕組みが
特定のトレースログの形式に依存しないようにしなければならない．そのため，
様々なトレースログ形式を一般化したトレースログ形式を定め，トレースログ可
視化ツールはこの形式を扱うこととする．一般化したトレースログの形式を標準
形式と呼ぶ．

%標準形式への変換の議論
標準形式への変換は，逐次的なテキストの置き換えといった，単純なテキスト処
理では要件を満たせない場合がある．
%
例えば，RTOSが出力するトレースログを，標準形式に変換する場合を考えてみる．
RTOSにおいては，「あるタスクにディスパッチされた」という情報(以下，Aとす
る)は，暗に，「実行中のタスクがプリエンプトされた」という情報(以下，Bと
する)を含んでいる．しかしながら，RTOSの実装によっては，トレースログを出
力するコストを減らすため，Aのみをトレースログとして出力し，Bを出力しない
場合がある．このとき，Bを標準形式トレースログとして出力したい場合，Aのト
レースログを変換する際に，Aが出力された時刻に実行状態であるタスクが存在
するかどうか，また，存在する場合はどのタスクであるのか，という情報が必要
となる．そのため，これらの情報を，変換元のトレースログファイルの内容から
判断する必要がある．

このように，標準形式への変換処理においては，変換元のトレースログが暗に含
む情報を出力するため，それを出力する条件の制御，また条件を制御するために
必要な情報を取得する手段が必要である．

\subsection{拡張性の実現方針}
\label{extendability_policy}

拡張性を実現するためには，汎用的な可視化表示の仕組みを提供し，ユーザが可
視化表示項目に合わせてそれを制御できればよい．つまり，可視化表示項目毎に
可視化表示の仕組みを用意するのではなく，汎用的な可視化表示の仕組みに対し
て，可視化表示項目を実現するパラメータを指定することで可視化表示を行う．
そして，ユーザがツールの外部からパラメータを指定する手段を実現すればよい．
その際，汎用性の実現のため，可視化表示の仕組みは，標準形式のトレースログ
にのみ依存するようにしなければならない．

また，指定するパラメータは，描画処理に必要なGUIフレームワークや表示デバ
イスに依存しないことが要求される．これは，プログラムの可搬性を損なわない
ためである．

本研究では，汎用的な可視化表示の仕組みを実現するために，まず，トレースロ
グの内容から可視化表現を決定し，それを表示するまでの流れを抽象化し，本質
的な処理を洗い出す．次に，ユーザが，どの処理に，どのようなパラメータを指
定できればよいかを判断し，可視化ルールとして形式化する．そして，ユーザが
ツールの外部から可視化ルールを指定できる仕組みを提供する．

\section{設計}
\label{sec3}

本章では，前章で汎用性を実現するための手段として挙げた標準形式と変換ルー
ルと，拡張性を実現するための手段である可視化表示の仕組みの設計について説
明する．

\subsection{標準形式}
\label{sub:standartFormat}

トレースログを一般化するため，RTOSやUnix系OS，ISS(Instruction Set 
Simulator)などのトレースログの形式の調査を行った．その結果から，次のよ
うにトレースログを一般化した．

トレースログは，時系列にイベントを記録したものとした．イベントとはイベン
ト発生源の事象であり，イベント発生源の``属性の変化''，または``振る舞い''
とした．ここで，イベント発生源をリソースと呼称し，固有の識別子として名前
を持つとした．つまり，リソースとは，イベントの発生源であり，名前を持ち，
固有の属性を持つ．固有の属性としては，``属性''と``振る舞い''があり，型に
より定義される．型は，リソースタイプと呼称して固有の識別子として名前をも
つとした．属性は，リソースが固有にもつ文字列，数値，真偽値で表されるスカ
ラーデータとし，振る舞いは，リソースの行為であるとする．それぞれは固有の
識別子として名前をもつ．

例として，RTOSが出力する，「TASK1という名前のタスクの状態が，実行状態に
遷移した」という情報のトレースログを，一般化した方法で考えてみる．この場
合，TASK1がリソースであり，タスクがリソースタイプである．また，タスクの
状態は属性にあたり，その属性が実行状態という値に変化したというイベントで
あると言える．また，「TASK1という名前のタスクがセマフォを取得するシステ
ムコールを呼び出した」という情報のトレースログでは，``システムコール呼び
出し''が振る舞いとなる．

図\ref{standartFormat}に，一般化の結果を形式化したトレースログの標準形式
の定義を示す．定義には，EBNF(Extended Backus Naur Form)，および終端記
号として正規表現を用いている．正規表現はスラッシュ記号({\tt /})で挟み
記述している．

\begin{EBNFFile}{標準形式の定義}{standartFormat}{A definition of the standard format}
TraceLog = { TraceLogLine,"\n" };
TraceLogLine = "[",Time,"]",Event;
Time = /[0-9a-zA-Z]+/;
Event = Res,".",(AttrChange|BhvrHappen);
Res = ResName|ResTypeName,"(",AttrCond,")";
ResName = Name;
ResTypeName = Name;
AttrCond = BoolExp;
BoolExp = Bool|CompExp
   |BoolExp,[{LogclOpe,BoolExp}]
   |"(",BoolExp,")";
CompExp = AttrName,CompOpe,Value;
Bool = "true"|"false";
LogclOpe = "&&"|"||";
CompOpe = "=="|"!="|"<"|">"|"<="|">=";
AttrName = Name;
AttrChange = AttrName,"=",Value;
Value = /[^"\\]+/;
BhvrHappen =  BhvrName,"(",Args,")";
BhvrName = Name;
Args = [{Arg,[","]}];
Arg = /[^"\\]*/;
Name = /[0-9a-zA-Z_]+/;
\end{EBNFFile}

トレースログが記録されたファイルのデータを TraceLog，TraceLog を改行記号
で区切った１行を TraceLogLine とする．TraceLogLine は``['',``]''で時刻を
囲み，その後ろにイベント(Event)を記述するものとする．
%
時刻はTime として定義され，数値とアルファベットで構成される．アルファベ
ットが含まれるのは，10 進数以外の時刻を表現できるようにするためである．
これは，時刻の単位として「秒」以外のもの，たとえば「実行命令数」などを表
現できるように考慮したためである．この定義から，時刻には，2 進数から36 
進数までを指定できる．

イベント(Event)は，リソース(Res)と，属性の値の変化イベント
(AttributeChange)もしくは，振る舞いイベント(BehaviorHappen)をドッド``.''
で繋げることで，どのリソースの属性の値もしくは振る舞いのイベントが発生し
たかを表す．

リソースの記述方法(5行目)は，リソースの名前({\tt ResName})による直接指定
か，リソースタイプの名前と属性の条件({\tt ResTypeName(AttrCond)})による
条件指定の2通りの方法で指定できるとした．条件指定では，リソースタイプと
リソースの属性の値から，特定のリソース，または複数のリソースを表現するこ
とができる（8〜15行目）．条件指定は，\ref{versatillity_policy}節で述べた，
変換元のトレースログが暗に含む情報の表現を可能にするため導入した．

属性の値の変化イベント(17行目)と振る舞いのイベント(19行目)の記述方法は，
JavaやC++などのオブジェクト指向言語における，メンバ変数への代入と，メソ
ッドの呼び出しの記法と同様である．

\subsubsection{標準形式の例}
\label{sub:standartFormat_exp}

図\ref{standartFormatTraceLogSample}に，RTOSが出力するトレースログを標準
形式に変換した例を示す．1行目がリソースの振る舞いのイベントであり，2行目，
3行目が属性の値の変化イベントである．
%
1行目は，時刻2403010に，{\tt MAIN\_TASK}という名前のリソースが{\tt 
leaveSVC}という振る舞いを，{\tt ena\_tex}と{\tt ercd=0}を引数として発生
したことを表現している．これは，タスクである{\tt MAIN\_TASK}が，{\tt 
ena\_tex}というシステムコールを，エラーコード{\tt 0}でリターンしたことを
意味している．2行目は，タスクである{\tt MAIN\_TASK}の属性のタスク状態
({\tt state})が実行可能状態({\tt READY})となったことを意味している．

1行目，2行目はリソースを名前で直接指定しているが，3行目はリソースタイプ
の名前と属性の条件によってリソースを指定している．3行目は，時刻4496802に，
この時点でリソースタイプの名前が{\tt TASK}のリソースのうち，属性のタスク
状態({\tt state})が実行状態({\tt RUNNING})であるリソースを指定している．
そして，このリソースのタスク状態({\tt state})が実行可能状態({\tt READY})
になったことを表現している．すなわち，実行状態であるタスクがプリンプト等
により実行可能状態になったことを意味している．

\begin{EBNFFile}{標準形式トレースログの例}{standartFormatTraceLogSample}{A sample of a standard format trace log}
[2403010]MAIN_TASK.leaveSVC(ena_tex,ercd=0)
[4496099]MAIN_TASK.state=READY
[4496802]TASK(state==RUNNING).state=READY
\end{EBNFFile}

\subsection{変換ルール}
\label{sub:conv_rule}

変換ルールは，任意の形式のトレースログを，標準形式トレースログに変換する
ためのルールであり，これらの対応関係を定義したものである．標準形式への変
換は，変換ルールに基づき，テキストの変換処理を行う処理である．

標準形式への変換処理に，awkなどの既存のテキスト処理用スクリプト言語を使
用する方法がある．しかしながら，\ref{versatillity_policy}節で述べたよう
に，変換元のトレースログが暗に含む情報を出力するため，リソースの属性の初
期値や型などの情報を参照したり，リソース毎に属性の値の遷移を監視する必要
があるなど，多くの複雑な記述をする必要があり，実用的ではない．

そこで，TLVでは，出力する条件の制御を，指定された時刻の特定リソースの有
無や数，属性の値，属性値変更イベントであれば変更後の値，振る舞いイベント
であれば，その引数などを用いて論理式を記述することで行う．論理式の記述は，
それらの値を取得できるマクロを用いて行い，その際の記法には標準形式を用い
る．マクロは6種類用意している．

変換ルールを\ref{versatillity_policy}節で述べた，RTOSが出力する「あるタ
スクにディスパッチされた（$[<$時刻$>]$ dispatch to task $<$タスクID$>$）」
というトレースログを標準形式トレースに変換する例で説明する．この例では，
RTOSは，実行中のタスクがプリエンプトされたというログを出力しないため，変
換ルールにおいて，実行中(実行状態)のタスクが存在するかチェックして，存在
すれば，そのタスクがプリエンプトされたことを標準形式トレースログとして生
成する必要がある\footnote{実行中のタスクが存在しない状態で，割込みハンド
ラからタスクが起動された場合は，プリエンプトされたログは出力する必要がな
い}．

図\ref{convertRuleFile}にこの変換の変換ルールを示す．1行目は，元のトレー
スログファイルから「あるタスクにディスパッチされた」トレースログを検索す
るための正規表現であり，一致した場合に2〜9行目で指定される標準形式トレー
スログを出力する．3行目は，出力する条件の制御であり，条件中に
\verb|$EXIST{|{\it resource}\verb|}|というマクロを用いてリソース{\it 
resource}の有無を判定している．ここでは，実行状態(RUNNING)のタスクが存在
するかチェックして，存在すれば，そのタスクがプリエンプトされて実行可能状
態(RUNNABLE)となる標準形式のトレースログ(4〜5行目)を出力する．一方，8〜9
行目は，1行目の一致により無条件に出力され，ディスパッチ先のタスクにディ
スパッチしてその状態を実行状態(RUNNING)とする標準形式トレースログを出力
する．

\begin{EBNFFile}{変換ルールファイルの例}{convertRuleFile}{A sample of a convert-rule file}
  "\[(?<t>\d+)\] dispatch to task (?<id>\d+)\.":[
    {
      "$EXIST{Task(state==RUNNING)}":[
        "[${t}]$RES_NAME{Task(state==RUNNING)}.preempt()",
        "[${t}]$RES_NAME{Task(state==RUNNING)}.state=RUNNABLE",
      ]
    },
    "[${t}]$RES_NAME{Task(id==${id})}.dispatch()",
    "[${t}]$RES_NAME{Task(id==${id})}.state=RUNNING",
  ],
\end{EBNFFile}


\subsection{可視化表示の仕組み}
\label{sub:visualize_rule}

\ref{extendability_policy}節の方針に従い，トレースログの内容から可視化表
現を決定して表示するまでの流れを抽象化し，可視化表示の仕組みとして本質的
な処理を洗い出す．そして，ユーザが，どの処理に，どのようなパラメータを指
定すればよいかを判断する．

\subsubsection{可視化表示の抽象化}

トレースログ可視化ツールにおいて，可視化表示とは，可視化表示項目毎に要求
される表現(以下，可視化表現)を，トレースログの内容に従い時系列の図として
画面に描画する処理であると考えられる．ここで，画面への描画は，GUIフレー
ムワークに依存するため，可視化表示の仕組みとしては本質的ではない．そのた
め，可視化表示の仕組みは，可視化表現を，時間と高さを次元にもつ仮想的な座
標に割り当てる処理であると抽象化できる．ここで，可視化表現は，複数の図形
で構成されるものとする．図\ref{visualizing}に，抽象的な可視化表示の仕組
みを示す．

図形は，楕円や四角などの複数の基本図形で構成されていると考えることができ
る．このとき，図形を定義する座標系をローカル座標系と呼称する．
%
次に，図形をトレースログの内容に従い配置する座標である，時間と高さを次元
にもつ仮想的な座標をワールド座標系と呼称する．
%
ワールド座標系へ割り当てられた図形は，表示開始時刻と単位時間あたりのピク
セル数により表示デバイスに表示される．このとき，表示先の座標系をデバイス
座標系と呼称する．単位時間あたりに，何ピクセル数でワールド座標系をデバイ
ス座標系に割り当てるかという処理が，表示上の拡大，縮小の処理となる．

\begin{figure}[tb]
\begin{center}
\scalebox{0.45}{\includegraphics{img/visualizing.eps}}
\caption{抽象的な可視化表示の仕組み}
\label{visualizing}
\end{center}
\end{figure}

以上の可視化表示の仕組みの抽象化から，ユーザが任意の可視化表示項目を実現
するために，汎用的な可視化表示の仕組みに対して与える指示としては，どのよ
うな図形を，どの時間領域に割り当てるかということであると考えられる．

時間領域の開始時刻と終了時刻は，イベントを用いて指定することとした．つま
り，指定されたイベントが発生する時刻をトレースログより抽出することにより
表示期間を決定する．このようにして，トレースログのイベントと可視化表現を
対応付ける．ここで，開始時刻に対応するイベントを開始イベント，終了時刻に
対応するイベントを終了イベントと呼称し，表示期間をイベントで表現したもの
をイベント期間と呼称する．


\subsubsection{図形の定義と可視化ルール}

図形は楕円，多角形，四角形，線分，矢印，扇形，文字列の7種類を用意する．
図形は，形状や大きさ，位置，塗りつぶしの色，線の色，線種，透明度などの属
性を指示することができる．

どの図形をどの時間領域に割り当てるか，つまり，図形をワールド座標系のどの
領域に割り当てるかの指示は，割り当て先の領域に対して一般的でなければなら
ない．つまり，割り当て先の個々の領域をすべて指定するのではなく，ルールに
基づいて割り当てが行われるように指定されるべきである．このルールを可視化
ルールと呼称する．

すなわち，可視化は，標準形式トレースログに対して，可視化ルールを適用して，
指定された開始イベントと終了イベントに一致するイベントを標準形式トレース
ログから探し，そのイベントの時刻を割り当て先の時間領域として採用すること
で，ワールド座標系への割り当てを行う．
%ToDo実装かな?
%可視化ルールにおける，開始イベントと終了イベントの記述には標準形式を用い
%る．

\subsubsection{図形の定義と可視化ルールの例}

図\ref{fig:timeShape}に図形の定義と可視化ルールの例を示す．

図形は，位置がローカル座標の原点，大きさがワールド座標系のマッピング領域
に対して横幅100\%，縦幅80\%の長方形で色が緑色の図形をrunningShapeとして
定義している．

可視化ルール(taskBecomeRunning)では，この図形を，開始イベント
\verb|MAIN_TASK.state=RUNNING|，終了イベント\verb|MAIN_TASK.state|となる
イベント期間で表示するよう指定している．開始イベント
\verb|MAIN_TASK.state=RUNNING|は，リソース\verb|MAIN_TASK|の属性
\verb|state|の値が\verb|RUNNING|になったことを表し，終了イベント
\verb|MAIN_TASK.state|は，リソース\verb|MAIN_TASK|の属性\verb|state|の値
が単に変わったことを表している．

この可視ルールを図\ref{fig:timeShape}右側中央のトレースログに適応すると，
トレースログからイベントを抽出して時間領域を決定して，図形をワールド座標
にマッピングする．

\begin{figure}[tb]
\begin{center}
\scalebox{0.42}{\includegraphics{img/timeShape.eps}}
\caption{図形の定義と可視化ルールの例}
\label{fig:timeShape}
\end{center}
\end{figure}


\section{実装}
\label{sec4}

本章では，前章で行った設計を基にしたTLVの実装について述べる．入出力ファ
イルと処理の流れについて説明し，変換ルールや可視化ルールをどのように形式
化したか，また，それらをどの段階で適用したのかを説明する．図\ref{fig:tlv}
にTLVの構成を示す．TLVは，6種の入出力ファイルと2つの主たる処理によって構
成される．

TLVの実装言語はC\#3.0であり，統合開発環境としてMicrosoft社のVisural 
Studio 2008 Professional Editionを用いた．

%TLVのソースコードメトリクスを表\ref{sourceMetrics}に示す．

%\begin{table}[htb]
%\begin{center}
%\caption{TLVのソースコードメトリクス}
%%\ecaption{A source code metrics of TLV}
%\label{sourceMetrics}
%\begin{tabular}{l|l}
%\hline
%総行数              & 18497 \\
%ファイル平均行数    & 94.38 \\
%有効な行数          & 10332 \\
%コメント行数        & 1432 \\
%空行                & 2224 \\
%その他の行数(中括弧など) & 4509 \\
%ファイル数          & 196 \\
%クラス数            & 186 \\
%インタフェース数    & 22 \\
%列挙体              & 15 \\
%デリゲート          & 2 \\
%\hline
%\end{tabular}
%\end{center}
%\end{table}

\begin{figure}[tb]
\begin{center}
\scalebox{0.4}{\includegraphics{img/tlv.eps}}
\caption{TLVの構成}
%\ecaption{A structure of TLV}
\label{fig:tlv}
\end{center}
\end{figure}


\subsection{入出力ファイル}

トレースログをTLVにより可視化表示する際，ユーザは，トレースログファイル
とリソースファイルを用意する．トレースログファイルは，可視化対象となる環
境が出力した，任意の形式のトレースログをファイル化したものである．リソー
スファイルは，トレースログの形式や，トレースログに登場するリソースの定義，
トレースログの時刻の単位や基数，適用する変換ルールと可視化ルール及び後述
するリソースヘッダファイルの指定などを記述したファイルである．リソースフ
ァイルの例を図\ref{resourceFile}に示す．

リソースヘッダファイルと変換ルールファイルは，トレースログを出力する環境
毎に用意する．リソースヘッダファイルはリソースタイプの定義を記述したファ
イルであり，変換ルールファイルは，変換ルールを記述したファイルである．リ
ソースヘッダファイルの例を図\ref{resourceHeaderFile}に示す．変換ルールフ
ァイルの例を図\ref{convertRuleFile}に示す．

可視化ルールファイルは，可視化表示項目毎に図形と可視化ルールの定義を記述
したファイルであり，複数の可視化表示項目を一つのファイルでまとめて定義す
ることができる．可視化表示項目を追加したければ，新たな可視化ルールファイ
ルを用意すればよい．

TLVが扱う6種のファイルのうち，トレースログファイル以外はJSON(JavaScript 
Object Notation)\cite{JSON}と呼ばれるデータ記述言語を用いて記述する．
JSONは，主にウェブブラウザなどで使用されるECMA-262，revision 3準拠の
JavaScript(ECMAScript)と呼ばれるスクリプト言語のオブジェクト表記法をベー
スとしており，RFC 4627として仕様が規定されている．JSONの特徴は，構文が単
純であることである．そのため，人間にとっても読み書きが容易であり，コンピ
ュータにとっても解析が容易であるため，ユーザの記述コスト，習得コスト，ま
たファイルの解析を行う実装コストを低減することができる．

\subsection{処理の流れ}
TLVを構成する2つの主たる処理は，標準形式変換と，図形データ生成である．

標準形式変換は，任意の形式のトレースログに対して，変換ルールを適用するこ
とで標準形式のトレースログに変換する処理である．この処理では，トレースロ
グファイルとリソースファイルがユーザーから指定され，リソースファイル中で
指定されたリソースヘッダファイルと変換ルールファイルが読み込まれる．

図形データ生成は，変換された標準形式トレースログに対して可視化ルールを適
用し図形データを生成する処理である．可視化ルールファイルは，リソースファ
イル中で指定されたファイルが用いられる．

それぞれの処理で生成された標準形式トレースログと図形データは，TLVデータ
としてまとめられ可視化表示の元データとして用いられる．TLVデータはTLVファ
イルとして外部ファイルに保存することが可能であり，TLVファイルを読み込む
ことで，2つの処理を省略して可視化表示することができる．


\subsection{標準形式変換}

標準形式トレースログへの変換は，トレースログファイルを先頭から行単位で読
み込み，変換ルールファイルで定義される置換ルールに従い標準形式トレースロ
グに置換することで行われる．標準形式トレースログに含まれるリソースは，リ
ソースファイルで定義されていなければならない．リソースファイルには，各リ
ソースについて，その名前とリソースタイプ，必要であれば各属性の初期値を定
義する．また，その際に使用されるリソースタイプはリソースヘッダファイルで
定義されていなければならない．リソースヘッダファイルには各リソースタイプ
について，その名前と属性，振る舞いの定義を記述する．

図\ref{resourceHeaderFile}に，RTOSにおけるタスクを，リソースタイプとして
定義しているリソースヘッダファイルの例の一部を示す．2行目から，タスクを
{\tt Task}という名前のリソースタイプとして定義している．4行目から属性の
定義をしており，13行目から振る舞いの定義を記述している．ここでは，数値型
の{\tt id}という属性とタスクが起動したことを表す{\tt start}，終了したこ
とを表す{\tt exit}，システムコールに入ったことを表す{\tt enterSVC}という
振る舞いが定義されていることがわかる．

図\ref{resourceFile}に，リソースタイプ{\tt Task}のリソースを定義している
リソースファイルの例の一部を示す．6行目に{\tt TASK1}という名前のリソース
が定義されており，9行目から属性の初期値の値が定義されている．

\begin{EBNFFile}{リソースファイルの例の一部}{resourceFile}{A sample of a resource file}
{ "TimeScale" :"us", "TimeRadix" :10,  /* 時刻の単位と基数 */
  "ConvertRules"   :["asp"],                 /* 変換ルール */
  "VisualizeRules" :["toppers","asp"],     /* 可視化ルール */
  "ResourceHeaders":["asp"],             /* リソースヘッダ */
  "Resources":{                    /* リソースの定義始まり */
    "TASK1":{           /* TASK1という名前のリソースを定義 */
      "Type":"Task",                     /* リソースタイプ */
      "Color":"ff0000",        /* リソース固有の色(GUI用) */
      "Attributes":{                 /* 属性の初期値を指定 */
        "id"    :1,
        "atr"   :"TA_NULL",
        "pri"   :10,
        /* ... 省略 ... */
        "state" :"DORMANT"
      }
    },
    /* ... 省略 ... */
\end{EBNFFile}

\begin{EBNFFile}{リソースヘッダファイルの例の一部}{resourceHeaderFile}{A sample of a resource-header file}
{ "asp":{
    "Task":{                        /* リソースタイプの名前 */
      "DisplayName":"タスク",       /* 表示名 */
      "Attributes":{                /* 属性の定義始まり */
        "id":{                      /* 属性名 */
          "VariableType"  :"Number",/* 属性の型 */
          "DisplayName"   :"ID",    /* 属性の表示名 */
          "AllocationType":"Static",/* 値は動的か静的か */
          "CanGrouping"  :false /* 同じ属性値同士でグループ */
        },                       /* を構成できるか(GUI用) */
        /* ... 省略 ... */
      },                              /* 属性の定義終わり */
      "Behaviors":{                   /* 振る舞いの定義開始 */
        "start":{"DisplayName":"起動"},/* タスクの起動 */
        "exit":{"DisplayName":"終了"}, /* タスクの終了 */
        /* ... 省略 ... */
        "enterSVC":{           /* システムコールの呼び出し */
          "DisplayName":"サービスコールに入る",
          "Arguments":{"name":"String","args":"String"}
        },
        /* ... 省略 ... */
\end{EBNFFile}


\subsection{図形データ生成}

図形データ生成は，\ref{sub:visualize_rule}節で述べたとおり，標準形式トレ
ースログの内容と図形と可視化ルールの定義に従い，ワールド座標系に図形を割
り当てる処理である．

図形と可視化ルールの定義は可視化ルールファイルに記述する．図
\ref{visualizeRuleFile}に可視化ルールファイルの例の一部を示す．2行目から
10行目までが図形の定義であり，それ以降が可視化ルールの定義である．

図形としては，長方形の{\tt runningShapes}が定義されている．可視化ルール
は，RTOSのタスクの状態表示のための{\tt taskStateChange}が定義されている．
このルールは，開始イベントと終了イベントとして，リソースタイプであるタス
ク（{\tt Task}）の属性の値変更イベントを用いることを{\tt Target}で指定
している．そして，ワールド座標系に割り当てる図形を，変更後の属性の値（タ
スクの状態）によって場合分けしており，実行状態(RUNNING)の場合は，{\tt 
runningShapes}を用いる．


\begin{EBNFFile}{可視化ルールファイルの例の一部}{visualizeRuleFile}{A sample of a visualize-rule file}
{ "toppers":{
    "Shapes":{                        /* 図形の定義始まり */
      "runningShapes":[{
          "Type":"Rectangle",         /* 形状の指定(長方形) */
          "Size":"100%,80%",          /* 大きさの指定 */
          "Pen":{"Color":"ff00ff00","Width":1},/* 線種の指定 */
          "Fill":"6600ff00"           /* 塗りつぶしの指定 */
        }],
      /* ... 省略 ... */
    },                                /* 図形の定義終わり */
    "VisualizeRules":{        /* 可視化ルールの定義始まり */
      "taskStateChange":{
        "DisplayName":"状態遷移", /* 可視化ルールの表示名 */
        "Target":"Task",        /* 適用するリソースタイプ */
        "Shapes":{                /* 表示項目の指定 */
          "stateChangeEvent":{
            "DisplayName":"状態", /* 表示項目の表示名 */
            "From":"${TARGET}.state", /* 開始イベント */
            "To"  :"${TARGET}.state", /* 終了イベント */
            "Figures":{               /* 表示する図形 */
              "${FROM_VAL}==RUNNING" :"runningShapes",
              "${FROM_VAL}==READY":"readyShapes"
              /* ... 省略 ... */
            }
          },
          /* ... 省略 ... */
        }
      },                      /* 可視化ルールの定義終わり */
      /* ... 省略 ... */
\end{EBNFFile}


\section{評価}
\label{sec5}

図\ref{fig:aspTLVscreenShot}に，シングルプロセッサ用RTOSである
TOPPERS/ASPカーネル(以下，ASPカーネル)\cite{TOPPERS}が出力するトレース
ログを，TLVを用いて可視化表示した結果を示す．タスクの状態遷移やシステム
コールの出入り，その際の引数，返値を可視化表示できていることがわかる．こ
のとき，変換ルールは約28行であり，可視化ルールは168行であった．また，リ
ソースヘッダファイルは44行であった．標準形式への変換処理に要した時間は，
トレースログファイルが353行の場合で約2秒であった．

\begin{figure*}[t]
\begin{center}
\scalebox{0.72}{\includegraphics{img/aspTLVscreenShot.eps}}
\caption{TOPPERS/ASPカーネルのトレースログの可視化表示}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TOPPERS/ASP}
\label{fig:aspTLVscreenShot}
\end{center}
\end{figure*}

次に，ASPカーネルをマルチコアプロセッサ用に拡張したTOPPERS/FMPカーネル
(以下，FMPカーネル)\cite{FMP}が出力するトレースログの可視化表示を行った．
FMPカーネルが出力するトレースログの形式は，ASPカーネルが出力するトレース
ログの形式に，プロセッサの番号を付加した形式になっている．また，FMPカー
ネルの可視化表示項目は，ASPカーネルの可視化表示項目に加え，そのタスクを
実行しているプロセッサを背景色で区別するように拡張したものが要求される．
そのため，ASPカーネル用の変換ルールと可視化ルールをベースに拡張を行った．
その結果，変換ルールファイルは32行，可視化ルールファイルは232行，リソー
スヘッダファイルは50行となった．図\ref{fig:fmpTLVscreenShot}に，FMPカー
ネルが出力するトレースログを，TLV用いて可視化表示した結果を示す．タスク
の状態遷移を表示している箇所に，背景色で実行コアを区別し表現できているこ
とがわかる．これにより，拡張性が確認できた．

\begin{figure*}[t]
\begin{center}
\scalebox{0.7}{\includegraphics{img/fmpTLVscreenShot.eps}}
\caption{マルチプロセッサ対応RTOS(TOPPERS/FMPカーネル)のトレースログの
 可視化表示}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TOPPERS/FMP}
\label{fig:fmpTLVscreenShot}
\end{center}
\end{figure*}

最後に，RTOSのトレースログとは形式の異なるトレースログの可視化を行い，汎
用性の確認を試みる．RTOSのトレースログとは形式の異なるトレースログとして，
ここでは，組込みコンポーネントシステムTECS(TOPPERS Embedded Component 
System)\cite{TECS}のトレースログを用いた．図\ref{fig:tecsTLVscreenShot}
に，組み込みコンポーネントシステムであるTECSのトレースログをTLV用いて可
視化表示した結果を示す．図\ref{fig:tecsTLVscreenShot}より，コンポーネン
トの呼び出し関係が可視化表示できていることがわかる．このとき，変換ルール
は15行であり，可視化ルールは88行であった．また，リソースヘッダファイルは
47行であった．

\begin{figure*}[t]
\begin{center}
\scalebox{0.78}{\includegraphics{img/tecsTLVscreenShot.eps}}
\caption{TECSのトレースログを可視化表示}
%\ecaption{A screenshot of TLV visualizing a trace log dumped by TECS}
\label{fig:tecsTLVscreenShot}
\end{center}
\end{figure*}


\section{開発}

\subsection{OJL}

TLVは，On the Job Learning(OJL)の開発テーマとして開発された．OJLとは，
企業で行われているソフトウェア開発プロジェクトを教材とする実践教育であり，
製品レベルの実システムの開発を通じて創造的な思考力を身につけるとともに，
単なる例題にとどまらない，現実の開発作業を担うことにより，納期，予算とい
った実社会の制約を踏まえたソフトウェア開発の実際について学ぶことを目的と
している．

\subsection{開発体制とスケジュール}

TLVはプロジェクトベースで開発が行われた．企業出身者2名と教員1名がプロジ
ェクトマネージャを務め，筆者を含む学生3名と企業出身者2名が開発実務を行っ
た．プロジェクトの進捗，成果物，情報の管理は，グループウェアやバグトラッ
キングシステム，ソースコードリポジトリ，Wikiといったネットワークアプリケ
ーションを用いて行われた．また，週に一度ミーティングを行い，開発実務者に
よる進捗の報告や，プロジェクトマネージャによる開発スケジュールの調整や指
導が行われた．

プロジェクトは約9ヶ月を通じて3フェーズに分けて実施された．フェーズを分割
した主な理由は，段階的な要求取得，目標設定や人員入れ替え時期，学期との同
期のためである．フェーズ1はプロトタイプの実装として約3ヶ月かけて行われ，
GUIの評価や要求の再取得，アプリケーションドメインを通じた設計方法の探索
を行うことを目的に行われた．

フェーズ1は，トレースログの対象をASPカーネルに絞り，可視化表示項目もタス
クの状態遷移のみとし，標準形式トレースログへの変換や，可視化ルールの適用
による可視化表示は行わないなど，目的の達成に必要な要件のみの実装に努めた．
フェーズ1での実装成果物の総行数は約9000行(有効行数5000行)であった．フェ
ーズ1の成果物はTLVの開発関係者とRTOS開発者および利用者の数名に利用され，
意見や要求の収集を行った．その結果，ユーザインタフェース，追加の機能要求，
可視化表現項目について意見が得られた．フェーズ1では，プロトタイプの実装
という位置づけであったため，開発プロセスを設定せずに開発を行った．その結
果，実装中心の開発になってしまい，進捗管理が曖昧になってしまった．

フェーズ2は約5ヶ月かけて行われ，標準形式変換ルールファイルによる標準形式
トレースログへの変換や，可視化ルールファイルによる可視化表現の外部プラグ
イン化の実装など，汎用性，拡張性を実現する主機能の実装を目的に行われた．
フェーズ2では，フェーズ1での反省を踏まえ，開発プロセスを導入した．導入し
た開発プロセスはユースケース駆動のアジャイルソフトウェア開発であり，詳細
は次節で後述する．

フェーズ3は約1ヶ月かけて行われ，リソースヘッダファイル，変換ルールファイ
ル，可視化ルールファイルの充実を図るとともに，TLVの汎用性，拡張性の確認
を行うことを目的として行われた．

\subsection{開発プロセス}
\label{subsec6_2}

フェーズ2において，TLVの開発は，ユースケース駆動のアジャイルソフトウェア
開発プロセスを用いて行われた．本節では，TLVの開発において，ユースケース
駆動アジャイルソフトウェア開発の各工程で実践した内容について詳述する．

アジャイルソフトウェア開発では，反復(イテレーション)と呼ばれる短い期間を
単位に反復して開発を行い，計画ではなく状況において適応的に対応することを
重視してソフトウェア開発を行う．1つのイテレーション内では1つの機能に対し
て設計，実装，テスト，文書化といった工程を完結して行う．図\ref{fig:agile}
にユースケース駆動アジャイルソフトウェア開発の例を示す．TLVの開発ではユ
ースケースを機能の単位としてイテレーションを反復して実施した．

\begin{figure}[tb]
\begin{center}
\scalebox{0.4}{\includegraphics{img/agile.eps}}
\caption{ユースケース駆動アジャイルソフトウェア開発}
%\ecaption{An use case driven agile software development}
\label{fig:agile}
\end{center}
\end{figure}



\subsubsection{外部設計とプロジェクト管理}

外部設計では，機能要求からユースケースを洗い出すことからはじまる．

フェーズ2ではまず，フェーズ1で行った評価の結果と，フェーズ2の実施概要に
ついて，プロジェクト計画書として文書化した．次に，フェーズ2で実装するTLV
の機能を，要求仕様書として文書化した．そして，機能をユースケースを単位に
定義し，ユースケース図を作成した．図\ref{fig:usecase}にTLVのユースケース
図を示す．

\begin{figure}[tb]
\begin{center}
\scalebox{0.4}{\includegraphics{img/usecase.eps}}
\caption{TLVのユースケース図の例}
%\ecaption{An example of use case diagram of TLV}
\label{fig:usecase}
\end{center}
\end{figure}

TLVの機能をユースケースを単位に定義した結果，全ユースケース数は36個であ
った．そして，ユースケース内のクラスの定義をクラス図として，クラス間の連
携の流れをシーケンス図として作成した．図\ref{fig:class}に作成したクラス
図の例を示す．また，図\ref{fig:sequence}に作成したシーケンス図の例を示す．

また，ユースケースを工程毎に分けた進捗表を作成し，これを用いて進捗管理を
行い，複数のメンバーでユースケースや工程で分担して実施した．

\begin{figure}[tb]
\begin{center}
\scalebox{0.4}{\includegraphics{img/class.eps}}
\caption{TLVのクラス図の例}
%\ecaption{An example of class diagram of TLV}
\label{fig:class}
\end{center}
\end{figure}

\begin{figure}[tb]
\begin{center}
\scalebox{0.4}{\includegraphics{img/sequence.eps}}
\caption{TLVのシーケンス図の例}
%\ecaption{An example of sequence diagram of TLV}
\label{fig:sequence}
\end{center}
\end{figure}

\subsubsection{内部設計}

内部設計は文書化せずに，ソースコードのコメントを記述することで行った．外
部設計で作成したクラス図を元に，インタフェースのみを記述したスケルトンク
ラスを記述し，メソッドのコメントとして，入出力(引数，返値)の説明，どの
ような機能を実装するべきかといった説明を記述する．

\subsubsection{単体テスト}

単体テストは，実装の前にテストケースを作成し，それをパスするように実装を
行うテストファースト方式を採用した．

TLVのテストは，統合開発環境に付属するユニットテストフレームワークを用い
て実装，実施した．ユニットテストフレームワークは，クラスのメソッドの定義
を元に，テストケースのスケルトンを自動生成する仕組みを搭載しており，テス
ト工程作業の大幅な省力化を図ることができる．スケルトンは，引数の組み合わ
せと期待値を開発者が入力するように生成されており，これらを入力する作業が
実質的なテストケースの実装作業となる．

ユニットテストの単位はメソッドだが，単純なアクセサメソッドはテストの対象
外とした．その結果，491メソッドがユニットテストの対象となった．

単体テストの実装はテストケースの記述であり，ユニットテストフレームワーク
が出力するテストコードのスケルトンに必要な情報を追記する．


\subsubsection{単体実装}

単体テストの実装が終わったらクラスの実装を行う．クラスの実装は，単体テス
トを実施しながら，テスト項目のをすべてをパスするかどうかを試しながら行う．

テストの実施とクラスの実装は反復して行う．テスト結果は記録されるため，文
書化する必要がなく，素早くデバッグを行うことができた．

1つのクラスの実装が終わればユースケース内の次のクラスの内部設計に移る．


\subsubsection{結合テストと結合実装}

ユースケース内のクラスをすべて実装したら，ユースケース内のクラスを結合し
てユースケースとして駆動する形に実装する．この際も，テストケースの実装を
先に行ってから実装を開始する．結合テストのテスト項目をすべてをパスしたら，
1つのイテレーションの完了であり，次のユースケースの外部設計を開始する．

\section{おわりに}
\label{sec7}

本論文では，トレースログ可視化ツールであるTLVについて，背景と既存ツール
の問題点，それを解決するための要件，要件を満たすための方法とその実装，評
価について述べた．

既存ツールの問題点としては汎用性と拡張性の欠如を挙げ，それを解決する要件
として，トレースログの標準化と標準形式への変換の仕組みの提供，また可視化
表示の仕組みの汎用化とパラメータ指示の形式化が必要であることを述べた．

そして，TLVにおける要件の実装方法として，標準形式変換と図形データの生成，
変換ルールファイル，可視化ルールファイル，リソースヘッダファイル，リソー
スファイルについて説明した．

最後にTLVを用いて，シングルコアプロセッサ用RTOSやマルチコアプロセッサ用
RTOS，組込みコンポーネントシステムなど，形式が異なる様々なトレースログの
可視化を試み汎用性の確認を行った．また，可視化表示項目の変更，追加を試み
拡張性の確認を行った．その結果，変換ルールファイルと可視化ルールファイル，
リソースヘッダファイルの拡張によりそれらが実現可能であることを示した．

今後の課題としては，現状の変換ルールや可視化ルールの記述では実現できない，
計算の必要な可視化表示項目について検討することが挙げられる．たとえば，
RTOSにおけるCPU使用率やタスクのコア占有率の可視化表示などがある．これに
は，可視化ルールを現状の単純なイベントの指定ではなく，イベントの状態遷移
で指定できるようにする方法や，変換ルールをスクリプト言語化する方法などが
考えられる．

\begin{adjustvboxheight} % needed only when Appendix follows
\begin{thebibliography}{99}
\bibitem{TLV} TraceLogVisualizer(TLV)\\
http://www.toppers.jp/tlv.html.

\bibitem{PARTNER-JET}
JTAG ICE PARTNER-Jet，\\
http://www.kmckk.co.jp/jet/.

\bibitem{watchpoint}
WatchPointデバッガ，\\
https://www.sophia-systems.co.jp/.

\bibitem{QNXMomentics}
QNX Momentics Tool Suite，\\
http://www.qnx.co.jp/products/tools/.

\bibitem{eBinder}
eBinder，\\
http://www.esol.co.jp/embedded/ebinder.html.

\bibitem{LTTng}

Mathieu Desnoyers and Michel Dagenais.: The lttng tracer : A low impact 
performance and behavior monitor for gnu/linux. In OLS (Ottawa Linux 
Symposium) 2006, pp.209--224, 2006.

\bibitem{LTTV}
Mathieu Desnoyers and Michel Dagenais, "OS Tracing for Hardware, Driver 
and Binary Reverse Engineering in Linux," CodeBreakers Journal Article, 
vol.4, no.1, 2007.

\bibitem{Dtrace}
R. McDougall, J. Mauro, and B. Gregg.: Solaris(TM) Performance and Tools: 
DTrace and MDB Techniques for Solaris 10 and OpenSolaris. Pearson 
Professional, 2006.

\bibitem{Chime}
OpenSolaris Project: Chime Visualization Tool for DTrace，\\
http://opensolaris.org/os/project/dtrace-chime/.

\bibitem{RFC3164}
RFC3164 The BSD syslog Protocol，\\
http://www.ietf.org/rfc/rfc3164.txt.

\bibitem{JSON}
RFC4627 The application/json Media Type for JavaScript Object Notation (JSON)，\\
http://tools.ietf.org/html/rfc4627.

\bibitem{TOPPERS}
TOPPERS Project，\\
http://www.toppers.jp/.

\bibitem{FMP}
本田晋也，高田広章， ITRON仕様OSの機能分散マルチプロセッサ拡張, 電子情報通信学会論文誌 D, Apr 2008. 

\bibitem{TECS}

Takuya Azumi, Masanari Yamamoto, Yasuo Kominami, Nobuhisa Takagi, 
Hiroshi Oyama and Hiroaki Takada, "A New Specification of Software 
Components for Embedded Systems," Proceedings of the 10th IEEE 
International Symposium on Object and Component-Oriented Real-Time 
Distributed Computing (ISORC 2007), pp.45--50, 2007.

\end{thebibliography}
\end{adjustvboxheight} % needed only when Appendix follows

\end{document}
