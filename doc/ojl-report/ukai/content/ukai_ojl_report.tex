\documentclass[11pt,a4j,titlepage]{jsarticle}

\usepackage[dviout]{graphicx}
\usepackage{misc}
\usepackage{tabularx}
\usepackage{amsmath,amssymb}
\usepackage{multirow}
\usepackage{subfigure}
\usepackage{ascmac}
\usepackage{slashbox}
\usepackage{subfigure}
\usepackage{eclbkbox}
\usepackage{mymacros}
\setcounter{tocdepth}{3}


\begin{document}
 \title{OJL報告書\\　\\
  {\huge トレースログ可視化ツール（TLV）\\ に対するイベント検索機能の追加}
  \vspace{5.0cm}
   \author{
    {\huge 350902054 鵜飼　真充}　\\　\\
    {\Large 名古屋大学大学院 情報科学研究科} \\
    {\Large 情報システム学専攻}
   }
  \date{2011年2月}
 }

\maketitle

\renewcommand{\thefootnote}{\arabic{footnote}}

\newcommand\fgref[1]{図~\ref{fig:#1}}
\newcommand\tbref[1]{表~\ref{tb:#1}}

\renewcommand{\bibname}{参考文献}
\renewcommand{\listfigurename}{付 図}
\renewcommand{\listtablename}{付 表}

\makeatletter
    \renewcommand{\thefigure}{%
    \thesection.\arabic{figure}}
    \@addtoreset{figure}{section}
\makeatother

\makeatletter
   \renewcommand{\thetable}{%
   \thesection.\arabic{table}}
   \@addtoreset{table}{section}
\makeatother

 \begin{abstract}
%アブスト
 \end{abstract}

 %%目次
 \tableofcontents
 \clearpage

 %section1
\section{はじめに}
近年，PC，サーバ，組込みシステム等，用途を問わずマルチプロセッサの利用が
進んでいる．その背景として，シングルプロセッサの高クロック化による性能向
上の限界や，消費電力・発熱の増大があげられる．マルチプロセッサシステムで
は処理の並列性を高めることにより性能向上を実現するため，消費電力の増加を
抑えられる．

組込みシステムにおいては，機械制御とGUI など要件の異なるサブシステム毎に
プロセッサを使用する例があるなど，従来から複数のプロセッサを用いるマルチ
プロセッサシステムが存在していたが，部品点数の増加によるコスト増を招くた
め避けらていた．しかし，近年は，1 つのプロセッサ上に複数の実行コアを搭載
したマルチコアプロセッサの登場により低コストで利用することが可能になり，
低消費電力要件の強い，組込みシステムでの利用が増加している．

マルチプロセッサ環境では，処理の並列性からプログラムの挙動が非決定的にな
り，タイミングによってプログラムの挙動が異なる．そのため，ブレークポイン
トやステップ実行を用いたシングルプロセッサ環境で用いられているデバッグ手
法を用いることができない．そのため，マルチプロセッサ環境では，プログラム
実行履歴であるトレースログの解析によるデバッグ手法が主に用いられる．トレ
ースログを解析することで，各プロセスが，いつ，どのプロセッサで，どのよう
な動作したかというプログラムのデバッグに必要な情報が全て記録される．しか
し，膨大な量となるトレースログから特定の情報を探し出すのが困難である．さ
らに，各プロセッサのログが時系列に分散して記録されるため，逐次的にトレー
スログを解析することも困難である．そのため，開発者が直接トレースログを解
析するのは効率が悪い．

トレースログの解析を支援するために，多くのトレースログ可視化ツールが開発
されている．組込みシステム向けデバッガソフトウェアや統合開発環境の一部，
Unix 系OS のトレースログプロファイラなどが存在する．しかし，これら既存の
ツールが扱うトレースログは，OS やデバッグハードウェアごとに異なるため，
可視化対象が限定されおり，汎用性に乏しい．さらに，可視化表示項目が提供さ
れているものに限られ，追加や変更が容易ではなく，拡張性に乏しい．

そこでOJL１期生の後藤を中心に汎用性と拡張性を備えたトレースログ可視化ツ
ールTraceLogVisualizer(TLV) が開発された\cite{Goto}．TLV 内部でトレースログ
を抽象的に扱えるよう，トレースログを一般化した標準形式トレースログを定
め，任意の形式のトレースログを標準形式トレースログに変換する仕組みを変
換ルールとして形式化した．標準形式トレースログから図形データを生成する
仕組みを抽象化し，可視化ルールとして形式化した．TLV では，変換ルールと
可視化ルールを外部ファイルとして与えることで，汎用性と拡張性を実現
している．

TLVはリリースされた後も、OJL２期生の水野、柳澤が開発を引き継ぎ、新たな
機能追加、保守が行われた[cite].主な追加機能としては、CPU 利用率といった、
複数のログを解析しなければならない複雑な可視化を実現するスクリプト拡張
機能、デバッグを効率化するために可視化図形の中に任意の文字列を挿入可能
にしたアプリログ機能があげられる．また、TLVの処理の遅さを改善するための
リファクタリングも行われた．

本OJLでも引き続きTLVへの機能追加と保守を行った．ユーザからTLVへの要求
を抽出し，特に要望の強かったイベントの検索機能の実装を行った．

TLVではタスクや周期ハンドラといったリソースの状態遷移や強制終了といった
イベントを時間ごとに可視化するため，視覚的にリソースの挙動が分かるよう
になっている．しかし，それでもログが長くなると全範囲をチェックする負担
は大きい．そのため，検索機能を用いることでデバッグの負担が軽くなる．

また，これまでTLVには変換ルール，可視化ルールの誤りを詳細に伝えられる検
証機能が存在していなかった．そのため本OJLにおいて検証機能の導入を検討し
た．しかし，十分な能力を持ったライブラリを見つけることができず，一から
開発するのはコストが高いと判断したため、導入を見送った．

最後に本報告書の構成を述べる．2章ではTLVの設計思想とその機能を述べる．
3章では本OJLの開発プロセスやスケジュール管理といったプロジェクト管理に
ついて述べる．4章ではユーザからの要求の詳細について述べる．5章では検索
機能について述べる．6章ではルール検証機能について述べる

\clearpage
%section2
\section{トレースログ可視化ツール(TLV)}

\subsection{TLVにおける汎用性と拡張性}
TLVは，汎用性と拡張性を実現することを目標としている．

汎用性とは，可視化表示したいトレースログの形式を制限しないことであり，可視化表
示の仕組みをトレースログの形式に依存させないことによって実現する．具体的には，ま
ず，トレースログを抽象的に扱えるように，トレースログを一般化した標準形式トレース
ログを定義する．そして，任意の形式のトレースログを標準形式トレースログに変換する
仕組みを，変換ルールとして形式化する．変換ルールの記述で任意のトレースログが標準
形式トレースログに変換することができるため，あらゆるトレースログの可視化に対応す
ることが可能となる．

拡張性とは，トレースログに対応する可視化表現をユーザレベルで拡張できることを表
し，トレースログから可視化表示を行う仕組みを抽象化し，それを可視化ルールとして形
式化して定義することで実現する．可視化ルールを記述することにより，トレースログ内
の任意の情報を自由な表現方法で可視化することが可能になる．

\subsection{標準形式トレースログ}
\subsubsection{トレースログの抽象化}
TLVでは任意のトレースログを扱うために，全てのログをTLVの定める標準形式
トレースログに変換してから可視化処理を行う．全てのログに対応できる標準
形式を定めるにあたり，トレースログの性質を調べ，抽象化を行う必要があった．
次に示す6項目がTLVにおいて抽象化されたトレースログである．

\begin{itemize}
   \item {\bf トレースログ}：\\
        時系列にイベントを記録したもの．
  \item {\bf イベント}：\\
        リソースの属性の値の変化，リソースの振る舞い．
  \item {\bf リソース}：\\
        イベントの発生源，固有の名前，属性を持つ．
  \item {\bf リソースタイプ}：\\
        リソースの型，リソースの属性，振る舞いを特徴付ける．
  \item {\bf 属性}：\\
        リソースが固有にもつ情報．文字列，数値，真偽値のいずれかで表現さ
        れるスカラーデータで表される．
  \item {\bf 振る舞い}：\\
        リソースの行為．主に属性の値の変化を伴わない行為をイベントとして
        記録するために用いることを想定している．振る舞いは任意の数のスカ
        ラーデータを引数として受け取ることができる．
\end{itemize}

\subsubsection{標準形式トレースログの定義}

標準形式トレースログは，前小節で抽象化したトレースログを形式化したものである．
標準形式トレースログの定義は，EBNF(Extended Backus Naur Form)および終端
記号として正規表現を用いている．正規表現はスラッシュ記号({\tt /})で挟む．

トレースログは，時系列にイベントを記録したものであるので，１つのログには
時刻とイベントが含まれる．トレースログが記録されたファイルのデー
タを\verb|TraceLog|，\verb|TraceLog|を改行記号で区切った１行を
\verb|TraceLogLine|とすると，これらは次のEBNFで表現される．

\begin{EBNF}
TraceLog = { TraceLogLine,"\n" };
TraceLogLine = "[",Time,"]",Event;
\end{EBNF}

\verb|TraceLogLine|は"\verb|[|","\verb|]|"で時刻を囲み，その後ろにイベン
トを記述する．

時刻は\verb|Time|として定義され，次に示すように数値とアルファベットで
構成する．

\begin{EBNF}
Time = /[0-9a-Z]+/;
\end{EBNF}

アルファベットが含まれるのは，10進数以外の時刻を表現できるようにするためである．
これは，時刻の単位として「秒」以外のもの，たとえば「実行命令数」などを表
現できるように考慮したためである．この定義により，時刻には，2進数から36進
数までを指定できる．

前小節にて，イベントをリソースの属性の値の変化，リソースの振る舞いと抽象化した．
そのため，イベントは次のように定義されている．

\begin{EBNF}
Event = Resource,".",(AttributeChange|BehaviorHappen);
\end{EBNF}

{\tt Resource}はリソースを表し，{\tt AttributeChange}は属性の値の変化イ
ベント，{\tt BehaviorHappen}は振る舞いイベントを表す．リソースはリソース
名による直接指定，あるいはリソースタイプ名と属性条件による条件指定の2通
りの指定が可能である．

リソースの定義を次に示す．

\begin{EBNF}
Resource = ResourceName
         | ResourceTypeName,"(",AttributeCondition,")";
ResourceName = Name;
ResourceTypeName = Name;
Name = /[0-9a-Z_]+/;
\end{EBNF}

リソースとリソースタイプの名前は数値とアルファベット，アンダーバーで構成
される．{\tt AttributeCondition}は属性条件指定記述である．これは次のよう
に定義される．

\begin{EBNF}
AttributeCondition = BooleanExpression;
BooleanExpression = Boolean
   |ComparisonExpression
   |BooleanExpression,[{LogicalOpe,BooleanExpression}]
   |"(",BooleanExpression,")";
ComparisonExpression = AttributeName,ComparisonOpe,Value;
Boolean = "true"|"false";
LogicalOpe = "&&"|"||";
ComparisonOpe = "=="|"!="|"<"|">"|"<="|">=";
\end{EBNF}

属性条件指定は，論理式で表され，命題として属性の値の条件式を，
等価演算子や比較演算子を用いて記述可能である．

{\tt AttributeName}はリソースの名前であり，リソース名やリソースタイプ名
と同様に，次のように定義されている．

\begin{EBNF}
AttributeName = Name;
\end{EBNF}

イベントの定義にて，\verb|AttributeChange|は属性の値の変化を，
\verb|BehaviorHappen|は振る舞いを表現しているとした．これらは，
リソースとドット"\verb|.|"でつなげることでそのリソース固有のも
のであることを示す．リソースの属性の値の変化と振る舞いは次の
ように定義されている．

\begin{EBNF}
AttributeChange = AttributeName,"=",Value;
Value = /[^"\\]+/;
BehaviorHappen =  BehaviorName,"(",Arguments,")";
BehaviorName = Name;
Arguments = [{Argument,[","]}];
Argument = /[^"\\]*/;
\end{EBNF}

属性の変化イベントは，属性名と変化後の値を代入演算子でつなぐことで記述
し，振る舞いイベントは，振る舞い名に続けてカンマで区切った引数を括弧
"{\tt ()}"で囲み記述する．


\subsubsection{標準形式トレースログの例}
前小節の定義を元に記述した，標準形式トレースログの例を表
\ref{standartFormatTraceLogSample}に示す．

\begin{File}{標準形式トレースログの例}{standartFormatTraceLogSample}
[2403010]MAIN_TASK.leaveSVC(ena_tex,ercd=0)
[4496099]MAIN_TASK.state=READY
[4496802]TASK(state==RUNNING).state=READY
\end{File}

1行目がリソースの振る舞いイベントであり，2行目，3行目が属性の値の変化イベントである．
1行目の振る舞いイベントには引数が指定されている．

1行目，2行目はリソースを名前で直接指定しているが，3行目はリソースタイプ
と属性の条件
によってリソースを特定している．

\subsection{トレースログの可視化}
TLVにおいてトレースログを可視化するまでには、様々な処理やデータが必要となる．
本節では，まずTLVの可視化プロセスについて述べ，各ステップで使用されるデー
タについて言及する．最後に可視化処理の具体例を示す．

\subsubsection{可視化プロセス}
TLVにおいてトレースログを可視化するまでのプロセスを\fgref{TLVProcess}に
示す．

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=6cm]{fig/section2/TLVProcess.eps}
  \caption{TLVにおける可視化プロセス}
\label{fig:TLVProcess}
  \end{center}
\end{figure}

トレースログファイルとリソースファイルをTLVに入力すると，リソースヘッダ
ファイルと変換ルールファイルを用いて標準形式トレースログへの変換が行われ
る．リソースファイルは，入力したトレースログの中の可視化したいリソースに
ついて，名称やその他の属性を定義したものである．また，リソースヘッダファ
イルではリソースタイプが定義されている．

続いて，標準形式トレースログに対して可視化ルールファイルの定義に従い，
表示する図形データを作成する．この図形データは標準形式トレースログととも
にTLVデータとして保存され，次回以降に同じログを可視化する際に使用するこ
とで可視化の高速化が実現される．

最後に，生成された図形データをもとにTLV上で可視化表示がなされ，可視化処
理のプロセスが終了する．

\subsubsection{変換ルール}　\\
　変換ルールは，トレースログを標準形式に変換する際の変換規則を示したもの
であり，各規則はJSON記法で記述される．TLVの利用者は，自分が使用したい形
式のログを標準形式に変換するための規則を記述することになる．なお，ASP，
FMP，TEXの出力するトレースログ形式に対する変換ルールは，すでにTLVで作成済みで
ある．\fgref{ConverterRule}に変換ルールの一例を示す．

1行目の正規表現では，変換を適用するログのパターンを定義している．このパ
ターンにマッチしたログがあると，TLVはその後に続く正規表現の形へ変換を行
う．変換語のログは標準形式トレースログに則ったログである．

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=9cm]{fig/section2/ConverterRule.eps}
  \caption{変換ルールの一部}
\label{fig:ConverterRule}
  \end{center}
\end{figure}

\subsubsection{可視化ルール}　\\
　可視化ルールは，標準形式トレースログを図形データに落とし込むための規則
を定義したものであり，変換ルールと同様にJSON記法で記述される．TLV利用者
は自分が図形表示させたいイベントについて規則を記述する．ASP，FMP，TEXで
表示できると便利であると予想される図形については既にTLVで定義済みである．
\fgref{VisualizeRule}に変換ルールの一例を示す．

TLVでは，図形データを可視化ルールとイベントをキーにして管理してい
る．1行目の''taskStateChange''が可視化ルール名，5行目の''stateChangeEvent''
がイベント名である．そして次の2行でイベントの開始と終了を示すログパター
ンを定義した部分であり、マッチするログを発見すると，そのログのイベントが
次行以降で定義されている図形と対応付けられる．ここで定義されている図形は
``runningShapse''と''runnableShapes''であり，これらの形やサイズといった
図形データも可視化ルールの中で定義する．

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=9cm]{fig/section2/VisualizeRule.eps}
  \caption{可視化ルールの一部}
\label{fig:VisualizeRule}
 \end{center}
\end{figure}


\subsubsection{具体的な可視化例}
　ここまでに可視化プロセス，変換ルール，可視化ルールについて述べたが，実
際にそれらがどのようにトレースログに適用されながら可視化が行われるかの具
体例を\fgref{VisualizeExample}に示す．

時刻1000と1100に発生したイベントを記録した任意形式のトレースログをTLVに
入力することを考える．TLVはこのログを標準形式に変換するためのルールを変
換ルール群から探して適用する。時刻1000のログにはConverRule内の最初の変換
規則が適用される．同様に時刻1100のログには2番目の規則が適用され，標準形
式トレースログへと変換される．次に，TLVは標準形式トレースログに対しては
可視化ルールを適用し，図形データを生成する．今回は''taskStateChange''ルー
ルが適用できるため，そのルールで示されている図形 ``runningShape''の生成
が行われ，最終的に図形としてタイムライン上で表示する．

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=12cm]{fig/section2/VisualizeExample.eps}
  \caption{可視化例}
  \label{fig:VisualizeExample}
  \end{center}
\end{figure}


以上のような可視化を入力された全てのログに対して適用することで，
TLVは最終的に\fgref{TLV_SS}に示すように全区間の可視化を完了させる．

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=12cm]{fig/section2/TLV.eps}
  \caption{可視化終了後のTLV}
\label{fig:TLV_SS}
  \end{center}
\end{figure}


\subsection{TraceLogVisualizer のその他の機能}
　TLVに実装されている可視化処理以外の機能を以下に示す．
\begin{itemize}
\item{\bf マーカー}：\\
     \fgref{TLV_SS}の中央部をタイムラインと呼ぶ．タイムライン上の任意の
     位置にマーカーと呼ぶ目印を配置することができ，注目すべきイベントに
     マーカーを置くことで解析の補助となる．
\item{\bf 可視化表示部の制御}：\\
     可視化表示ツールでは，可視化表示部を制御する操作性が使い勝手に大き
     く影響するため，TLV では目的や好みに合わせて様々な操作で制御が行え
     る．可視化表示部の制御として，表示領域の拡大縮小，移動を行うことが
     できる．
\item{\bf マクロ表示}：\\
     タイムライン上では，ある一定時間の範囲だけが可視化表示されている．
     マクロ表示機能は現在の表示範囲がトレースログ全体のうちのどの部分か
     を知るための機能である．マクロビューアにトレースログ全体が可視化
     されており，現在表示している範囲に薄いマスクをかぶせることで，一
     目で表示箇所が分かるようになっている．
\item{\bf トレースログのテキスト表示}：\\
     図形表示だけでは何が起きているか分かりづらいことがある．そのため
     TLVでは標準形式に変換されたトレースログをトレースログウィンドウに
     表の形で表示させている．
\item{\bf 可視化表示項目の表示/非表示の切り替え}：\\
     可視化された図形の表示/非表示をTLV実行中に切り替える機能である．
     リソースエクスプローラでリソースを選択した場合は，タイムライン上の該当
     リソースの行が消える．可視化ルールウィンドウでルールを選択した場合
     は，そのルールによって可視化される該当リソースの図形が非表示になる．
\item{\bf アプリログ機能}：\\
     タイムライン上に任意の文字列を書き込む機能．書き出したい文字列を
     変換前のトレースログの中に所定の形式で埋め込むことで，指定したリソー
     ス行の指定した時刻に文字列が書き込まれる．
\item{\bf スクリプト拡張機能}：\\
     標準形式変換の際に変換ルールを用いず，利用者が独自のスクリプトで標
     準形式変換を可能にする機能．利用者が慣れ親しんだ言語で変換処理を記
     述できる．また，スクリプトにCPU利用率などの統計情報を集計するコード
     を記述することで，それをタイムライン上にグラフとして表示するという
     複雑な可視化も可能である．
\end{itemize}

\clearpage
\subsection{本OJLで追加した機能}
本OJLでTLVに追加した機能について述べる。

\paragraph{イベント検索機能}　\\
　TLVを用いて長いログを解析する際，特定のイベントの発生時刻を様々な条件
を考慮しつつ検索できる機能が必要であるという要求が利用者から得られた．
そこで本OJLでは，TLVにイベント検索機能を実装した．詳細は\ref{EventSearch}
章で述べる．

\paragraph{スクリーンショット機能}　\\
利用者からの要求でタイムラインだけのスクリーンショットを撮ることが
できる機能が欲しいという要求が出たため、本OJLで実装を行った．

\paragraph{リソース状態の追加}　\\
　既存の可視化ルールに対して，「ディパッチ禁止状態」，「CPUロック状態」，
「割り込み禁止状態」を可視化するためのルールを追加した．
\fgref{AddedFigures}におけるタイムライン上の丸枠で囲まれた3つの図形が
今回新たに追加した図形である．\\

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=6cm]{fig/section2/AddedFigures.eps}
  \caption{追加図形}
\label{fig:AddedFigures}
  \end{center}
\end{figure}

\paragraph{JSON Validator（開発途中）}　\\
　現状のTLVには，ルールファイルにJSON記述違反がある場合にも詳しいエラー
内容を利用者に通知する機能を持っていない．そのため，利用者からJSON検証機
能の要求があった．そこで本OJLでは，Json.NET[参照]が提供するJSONパースラ
イブラリを用いてルールファイルの検証機能の開発に取り組んだ．しかし，ライ
ブラリで使用できるJSONスキーマでは，ルールファイルの検証に対して能力不足
であることが判明したため，現在は開発を一時中断している状況である．

\clearpage

%section3
\section{実績}
\subsection{開発プロセス}
TLV は，OJL(On the Job Learning) の開発テーマとして開発された．OJL とは，企
業で行われているソフトウェア開発プロジェクトを教材とする実践教育である．
製品レベルの実システムの開発を通じて創造的な思考力を身につけるとともに，
生産現場で行われている実際の開発に関わることにより，納期，予算といった制
約を踏まえたソフトウェア開発を学ぶことを目的としている．

TLV はプロジェクトベースで開発が行われ，本年度は企業出身者2 名と教員2 名がプ
ロジェクトマネージャを務め，筆者含む学生5 名が開発実務を行った．進捗の報告は，週
に1 度のミーティングと週報の提出により行った．

\paragraph{開発フェーズ}
TLVの開発はOJL一期生から現在まで継続して行われている。半年を1つの開発フェ
ーズと規定し、各フェーズにおいてTLVに必要な機能の実装を行うというスパイ
ラルモデル型の開発形態をとってきた。\fgref{Phase}に各フェーズの作業内容
と、各フェーズの担当者を示す。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=11cm]{fig/section3/Phase.eps}
  \caption{開発フェーズ}
\label{fig:Phase}
  \end{center}
\end{figure}


\paragraph{本OJL以前に実施されたフェーズ}　\\
　フェーズ1からフェーズ3にかけては、一期生、二期生よりTLVのプロトタイプ開
発が行われた\cite{Goto}。

フェーズ4では、二期生によってスクリプト拡張機能
\cite{mizuno}、アプリログ機能\cite{yanagi}がTLVに追加され、TLVのTOPPERS
内部向け公開が行われた。

\paragraph{本OJLで実施されたフェーズ}　\\
　フェーズ5ではルール検証機能の実現可能性の調査と、TLVのリファクタリング
案の検討を行った。また、TLVを使用したユーザから要求抽出を行い、TLVに追加
すべき機能を検討した。

フェーズ6では、TLVのリファクタリングを行った。また、ユーザからの要望が高
かったイベント検索機能、統計情報・リソース属性表示機能の開発に着手した。

フェーズ7では、フェーズ6に引き続きイベント検索機能の開発と、統計情報・リ
ソース属性表示機能の開発を行った。


\subsection{開発スケジュール}
本OJLで実施したフェーズ5,フェーズ6,フェーズ7の開発スケジュールについて述
べる。

\paragraph{フェーズ5}　\\
{\bf 期間}：　2009年度後期\\
{\bf 実施内容}：
 \begin{itemize}
  \item TLVのコードリーディングを行った
  \item ルール検証機能JSON Validator の開発を通して、C＃とTLVの学習を行った
  \item 標準形式変換の高速化を検討した
  \item フェーズ4までに累積していた不具合・要望への対処を行った
  \item ユーザからの要求抽出を行った
 \end{itemize}
{\bf スケジュール}：\\
　フェーズ5のスケジュールを\fgref{Phase5_Schedule}に示す。
開発に参加してから約1月半にわたり、TLVの開発言語であるＣ＃をルール
検証機能JSON Validator の開発を通して学習した。それと並行する形で
TLVのコードリーディングを行いTLVに関する知識を深めた。12月からは、より深
い部分のコードリーディングを行いつつ、可視化速度のボトルネックになってい
た標準形式ログへの変換の高速化を検討し、リファクタリング案を作成した。
また12月半ばから、累積していた不具合・要望への対処を行った。\\　\\
{\bf 成果}：　\\
　JSON Validator は、開発に使用していたJSONパース用のライブラリに能力不
足が発見されたため、スケジュールの都合もあって開発を中断することになった。
しかし、Ｃ＃の学習、検証機能の開発に必要な機能の洗い出しという面で成果が
あった。

また、6つのクラス、合計1590行を対象とするTLVのコードリーディングによって、
可視化処理の根幹部分である標準形式変換、図形変換の処理について理解が深まっ
た。さらに標準形式変換の処理にたいするリファクタリング案を作成した。

\fgref{Phase5_Schedule}には載せていないが、2月中旬にTLVユーザから
TLVに必要な機能の聞き取りを行った。その結果、イベントの検索機能、統計情
報・リソース属性情報機能が必要であるという知見を得られた。

フェーズ5における不具合・要望への対処は、プロジェクト全体で22個、そのう
ち筆者自身の対処数は3個であった。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=14cm]{fig/section3/Phase5_Schedule.eps}
  \caption{フェーズ5のスケジュール}
\label{fig:Phase5_Schedule}
  \end{center}
\end{figure}

\paragraph{フェーズ6}　\\
{\bf 期間}：　2009年度後期\\
{\bf 実施内容}：
 \begin{itemize}
  \item TLVのGUI部分に関するコードリーディングを行った
  \item イベント検索機能の一つである簡易検索機能を実装した
  \item リリース作業を担当した
  \item フェーズ5までに累積していた不具合、要望への対処を行った
 \end{itemize}
{\bf スケジュール}：\\
　フェーズ6のスケジュールを\fgref{Phase6_Schedule}に示す。
フェーズ6ではイベント検索機能の開発を行うことになった。そこでまずTLVを構
成するGUI部品について理解を深めるために、GUIに関連する部分のコードリーディ
ングを行った。それと並行してイベント検索機能の実現可能性を調査を行った。
3月終了時点で実現可能であること判断し、その後コードリーディングを継続し
ながら仕様定義、詳細設計、実装、テストを6月下旬までに行い、簡易検索機能
を開発した。簡易検索機能に関しては5章で詳細を述べる。また7月上旬から下旬に
かけて、それまでに累積していた不具合・要望への対処を行った。\\　\\
{\bf 成果}：\\
　（対象クラス数、合計行数を調べておく）TLVのGUI部分に関するコードリーディ
ングにより、TLVの構成を理解した。また、イベント検索機能をどう実現するか
の知見を得た。

TLVユーザから要望のあった検索機能の実現を全て実現するには非常に多くの工
数がかかり、フェーズ6内で終了できないと判断した。そのため、イベント検索
機能を簡易検索、詳細検索という二つの機能に分割し、フェーズ6では簡易検索
を実装した。

4月にフェーズ5での成果をまとめたTLV.1.1.2のリリースを行った。

フェーズ6における不具合・要望への対処は、プロジェクト全体で10個、そのう
ち筆者自身の対処数は8個であった。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=14cm]{fig/section3/Phase6_Schedule.eps}
  \caption{フェーズ6のスケジュール}
\label{fig:Phase6_Schedule}
  \end{center}
\end{figure}

\paragraph{フェーズ7}　\\
{\bf 期間}：　2009年度後期\\
{\bf 実施内容}：
 \begin{itemize}
  \item 詳細検索機能を実装した
  \item リリース作業を担当した
  \item フェーズ6までに累積していた不具合、要望への対処を行った
 \end{itemize}
{\bf スケジュール}：\\
　フェーズ7のスケジュールを\fgref{Phase7_Schedule}に示す。
フェーズ7では、フェーズ6で実装した簡易検索機能をもとに、より複雑な検索を
行う詳細検索機能の開発を行った。8月上旬から10月下旬にかけての3か月間で仕
様定義、詳細設計、実装、テストまでを行った。詳細検索機能に関しては第5章
で詳細を述べる。11月からはそれまでに累積していた不具合・要望への対処を
行った。　\\　\\　\\　\\
{\bf 成果}：\\
　詳細検索の一機能として、イベント間のタイミングを検索条件に指定可能なタ
イミング検索をTLVに実装した。

8月にフェーズ6での成果をまとめたTLV.1.2のリリースを行った。また、12月に
詳細検索を搭載したTLV1.3rcをTOPPERS内部向けにリリースした。

フェーズ7における不具合・要望への対処は、プロジェクト全体で14個、そのう
ち筆者自身の対処数は12個であった。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=14cm]{fig/section3/Phase7_Schedule.eps}
  \caption{フェーズ7のスケジュール}
\label{fig:Phase7_Schedule}
  \end{center}
\end{figure}

\clearpage

\subsection{チケット終了率}
　本OJLにおけるチケットの発生と消化についてまとめたグラフを
\fgref{TicketReport}に示す。グラフの横軸は期間を表す。横軸の
始まりは本OJLの開始直前である2009年9月、終わりはOJL作業の実質的な
終了月である12月までとなっている。グラフの縦軸はチケット数であり、
上側の曲線がチケットの累積数数、下側の曲線がチケットの累積消化数
を表わす。

本OJL開始から終わりまで、ほとんどの期間でチケットの発生数が消化数を若干
とはいえ上回っている。曲線の概形からいうとプロジェクトは発展途上であり、
これからもチケットは今のペースで増加することが予想される。そのため、
不具合修正、要望への対応を行う時間を今よりも確保し、消化率を上げる必要が
ある。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=11cm]{fig/section3/ticket.eps}
  \caption{チケット累積件数}
\label{fig:TicketReport}
  \end{center}
\end{figure}

\subsection{発表実績}
\paragraph{過去の発表実績}　\\
　平成21 年度情報処理学会第139 回システムLSI 設計技術(SLDM) 研究会において
発表\cite{Goto2} を行ない，情報処理学会山下記念研究賞/学生奨励賞を受賞し
た．

Embedded Technology 2009(ET2009)\footnote{http://www.jasa.or.jp/et/} に
おいて，ブース出展及びTLV の一般公開についてプレス発表を行なった

\paragraph{本OJLにおける発表実績}　\\
　第2回名古屋大学組込みシステム研究センターシンポジウムで
\footnote{http://www.nces.is.nagoya-u.ac.jp/news/sympo2010.html}
ポスター発表を行った。

\subsection{活用事例}
名古屋大学大学院情報科学研究科付属組込みシステム研究センター
(NCES)\footnote{http://www.nces.is.nagoya-u.ac.jp/}内の7件の
プロジェクトのうち，2件のプロジェクトによって利用されている．
また，同NCES のコンソーシアム型共同研究によっても利用されている．

\clearpage
%section4
\section{要求抽出}
\subsection{ユーザからの要求抽出}　
　本プロジェクトでは、開発者・利用者用のメーリングリストが用意されてお
り、不具合や要望があればメールですぐに伝えられるようになっている。TLVの
開発では、メールで寄せられた意見に基づいて不具合修正、機能の追加に対応し
てきた。

フェーズ5終盤において、それまで着手してきた大型の案件が一通り終了し、新
しい機能の追加を検討段階へと進んだ。それまでにユーザから寄せられたいくつ
かの要望の優先順位を決定すること、新たな機能についての要望を獲得すること
を目的として、2010年2月17日にユーザミーティングを行った。

参加者は、開発者と利用者合わせて約１０人であった。まずTLVの機能概要につ
いて利用者に説明し、その後累積している課題を報告した。最後に利用者から
追加機能について意見を求めた。


\subsection{要求された機能} \label{requireFunction}
ユーザから要望があった追加機能について以下で述べる。

\subsubsection{検索機能}
TLVでは各リソースの挙動を様々な形と色の図形で表示する。例えば\fgref{FigurePattern}
に示した図形では、緑の四角形がリソースが実行状態であること、赤い直線がタ
スクが待ち状態であること、黄色い直線がタスクが実行可能状態にあることを表
す。\fgref{FigurePattern}は全体として、タスクが実行状態から、待ち状態、実行
可能状態を経て、再度実行状態になったことを示している。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=9cm]{fig/section4/FigurePattern.eps}
  \caption{図形パターン}
\label{fig:FigurePattern}
  \end{center}
\end{figure}

TLVはトレースログを可視化することで、デバッグのコストを減らすことを目的
としたツールである。しかしログが長くなれば、可視化されていたとしても解
析にコストがかかってしまう。そこで、注目するリソースについて図形パターン
を指定、もしくはどのような状態になったのかという条件を指定し、画面上の
該当する時刻へと即座に移動、もしくは該当する時刻を列挙するという検索機
能が欲しいという要望があった。


\subsubsection{統計情報の表示}
TLVの開発思想は、トレースログを可視化し、ログ1行1行を読まなくても済む
ようにすることでデバッグコストを下げるというものであり、ログを図形化する
だけの機能しか持たせていない。しかし、どの時刻に何が起きているかを表示す
るだけでなく、どの時刻で、もしくはどの範囲でリソースがどれだけ動いている
か、どれだけプリエンプとされたかという統計的な情報を表示できれば、それも
デバッグの大きな支援になる。そのため、ユーザの指定した区間における統計情報
を表示する機能が欲しいという要望があった。

統計情報として得たいという要望のあったものを以下に示す
\begin{itemize}
  \item CPU利用率
  \item タスクの実行回数
  \item イベント数
  \item 起動回数
  \item アイドル時間
  \item プリエンプト回数
  \item ディスパッチ回数
  \item 起動までの時間
  \item デッドラインミス回数
  \item デッドラインまでの時間
  \item タスク割り当ての不均衡具合
\end{itemize}


\subsubsection{標準形式ログの読込み機能}
TLVの処理速度が遅く、可視化に非常に多くの時間がかかってしまうため、高
速化してほしいという要望が本ミーティング以前からあった。本OJLではTLVに対
してプロファイリングを行い、処理のボトルネックとなっている部分が標準トレ
ースログへの変換処理であることまで突き止めており、解決のアプローチとして
変換処理コードのリファクタリングを行っている。

一方ミーティングにおいて、最初からOSに標準トレースログを出力させるように
し、それをTLVに読込ませるというアプローチが提案された。これならば、そも
そも変換処理が発生しないため、可視化までの速度は大幅に向上する。
そこで標準形式ログを入力として使用できるようにしてほしいという要望があっ
た。これを実現する場合、TLVの既存プロセスは\fgref{FormalizedLogProcessor}
のようにする必要がある。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=6cm]{fig/section4/FormalizedLogProcessor.eps}
  \caption{標準形式ログ入力機能を導入した場合のプロセス}
\label{fig:FormalizedLogProcessor}
  \end{center}
\end{figure}

\subsubsection{凡例表示機能}
TLVでは、表示される図形が何を意味しているかを伝える機能が存在していな
い。そのため、TLVに習熟していないユーザにとっては \fgref{FigurePattern}
のような簡単な図形パターンでさえ、そのパターンがどんな意味を持っているか
を理解するのが難しい。そこで、ユーザに分かりやすく図形の情報を伝える機能
が欲しいという要望があった。

実現方式としては次の2つが考えられる。
\begin{itemize}
 \item 変換ルールファイルと可視化ルールファイルから動的に図形情報を取得
       し、図形にマウスポインタが当った際に表示する、もしくはサブウィン
       ドウに図形とともに表示する。
 \item 図形情報ファイルを用意しておき、マウスポインタが当る、もしくはサ
       ブウィンドウに図形とともに表示する。
\end{itemize}

\subsection{本OJLで対応する要求}
\ref{requireFunction}節で述べた機能はTLVに全て実装する予定である。しか
しOJLには期限が定められているため、優先順位を決定する必要がある。

　４つの機能のうち検索機能と統計情報表示機能は、ユーザからの要望が大き
かったものである。また、これらは開発工数が大きいと予想される。そのため、
これらの機能から開発を始めることが望ましい。

今回の要求抽出はフェーズ5終了直前に行われたものである。続くフェーズ6では
筆者を含めて開発人員は２人であるため、２つの機能をそれぞれが担当する形で
開発を行うこととした。筆者は検索機能を担当した。検索機能の詳細については
続く5章で述べる。


\clearpage
%section5
\section{イベント検索機能}\label{EventSearch}
\subsection{実現可能性の調査}
要求された検索機能は、リソースの図形パターン、もしくは、リソースの状態を
指定してマッチする時刻を探し出すというものであった。そこで、検索機能の実
現可能性を調査した。

まずタイムライン上に表示された図形が、プログラム内部でどのような情報とと
もに保存されているかを調べたところ、次の情報を持っていることが分かった。

\begin{enumerate}
 \item 図形の開始時刻
 \item 図形の終了時刻
 \item 図形の形（線、長方形 etc）、高さ、幅、色
 \item 図形が表現するイベントの名前（状態遷移、強制終了 etc）
 \item そのイベントが属するルールの名前
\end{enumerate}

パターン検索を単純に実装する場合、検索条件に図形の名前を指定できるように
し、該当する図形の描画が始まる時刻をヒットさせるという方法が考えられる。
しかし、図形が名前を持っていないため、この方法は不可能である。次に図形の
色や形を指定して検索する方法も考えたが、目的のパターンを検索するにはやは
り図形の意味を検索条件として指定できた方が良いため、この方法も見送った。
パターン検索として一番良いものは、図形をグラフィカルに作成し、そのパターンに
マッチする箇所を探すという方法であるが、作成した図形パターンと上記図形情
報とのマッチング処理と図形作成機能の実装は非常にコストが高いと予想され、
本OJLでは実現が難しいと考えられる。以上の考察から、図形パターン検索に関
しては本OJLでは実現不可能と判断した。


一方、リソースの状態を指定するという検索方法については、4番のイベント名
利用すれば実現できそうである。イベントは可視化ルールの中で定義されており、
例えば実行中のタスクが変化したことを示す''runningTaskChangeEvent''や、タ
スクの状態遷移が起きたことを示す''stateChangeEvent''といったものがある。
これを検索条件として指定できれば、検索者も直観的に検索条件を作成できると
考えられる。そこで本OJLではイベント検索機能の実装を進めることにした。

\subsection{開発プロセス}
検索機能に対するユーザからの要求では、複数のイベントを組合わせた複雑な
条件で検索を行いたいというものがあった。例えば「タスクAにおいて起動イベン
トが発生した時刻のうち、その時刻の1秒以内に終了イベントが発生した時刻を
検索する」というような、イベント間に時間制約を課した検索が挙げられる。
このような複雑な検索を実装するためには、まず1つのイベントを検索する機能を
実装し、それを複数イベントに拡張するという手順を踏む必要がある。

実現可能性の調査が終了した段階ではTLVのコードに習熟できておらず、1つのイ
ベントの検索のコード作成はおろか、検索条件入力用のインタフェース、、検索
結果の表示といったGUI関連のコード作成にも多くの時間が必要になると予想さ
れた。そのため、検索機能を単独のイベントを検索する「簡易イベント検索」と、
複数のイベントを組合わせて検索を行う「詳細イベント検索」とに分割した。
フェーズ6ではコード学習を行いながら簡易イベント検索を実装し、それをもと
にしてフェーズ7で詳細検索を実装するという開発プロセスをとることにした。
これは小さな機能を徐々に開発しながら製品を組み立てていくスパイラルモデル
型の開発プロセスである。

\subsection{簡易イベント検索機能}　
\subsubsection{機能仕様}
　簡易イベント検索の仕様を以下に記述する。

 \paragraph{検索条件}　\\
　図形データの中に保持されているルール名とイベント名は、可視化ルールファ
イルから得られた情報である。\fgref{visrule}に可視化ルールファイルの
一部を示す。1行目の''taskStateChange''がルール名であり、4行目の
``stateChangeEvent''がイベント名である。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=9cm]{fig/section5/visrule.eps}
  \caption{可視化ルールの一部}
\label{fig:visrule}
  \end{center}
\end{figure}

　簡易イベント検索では、例えば「タスク1が実行状態になった時刻を探す」と
いうような検索を行うため、検索条件には少なくともイベント名とイベント詳細
が必要になる。また、TLVではイベント名の重複が許されているため、イベント
名から目的の図形一意に決定するためにはルール名も検索条件として必要になる。
よって検索条件と指定する項目は以下の4条件となる。以降では、この4条件を
{\bf 基本条件}と呼ぶ。

\begin{itemize}
  \item リソース名
  \item ルール名
  \item イベント名
  \item イベント詳細
\end{itemize}

\paragraph{検索操作のためのGUI}　\\
　検索にともなう操作としては、検索条件の指定、検索の実行、検索
結果の表示があり、これらを行うためのGUIが必要になる。簡易イベン
ト検索では4つの検索条件指定ボックスと検索実行ボタンだけあればよ
いため、、別途フォームは用意せず、TraceLogDisplay上でそれぞれ次
のように実現する。

\begin{itemize}
 \item 検索条件の指定：　\\
 TraceLogDisplayPanel上のタイムライン上部に条件指定用のコンボボックスを
 一列に配置する。リソース名だけを指定必須とし、各条件が指定されるごとに
 次の条件を指定するためのコンボボックスを順次出現させる。
 \item 検索の実行：　\\
 検索条件指定ボックスの後方に、「後方検索」、「前方検索」、「全体検索」
 の順にボタンを配置する。検索開始の初期時刻は、ボタンが押された際のタイ
 ムライン上のカーソル位置が示す時刻とする。
 \item 検索結果の表示：　\\
 検索結果はタイムライン上でカーソルを該当時刻へ動かす、もしくはマーカー
 を出現させることで表現する。後方検索、 前方検索の場合は検索時刻にカー
 ソルを移動させ、同時に画面をカーソルの位置に移動させる。全体検索の場
 合は全ての検索時刻にマーカーを引き、画面移動はしない。
\end{itemize}
\subsubsection{ユースケース}
  定義した仕様をもとに、ユーザが簡易イベント検索を行う際のユースケース
を\fgref{SimpleSearchUC}に示す。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=11cm]{fig/section5/SimpleSearchUC.eps}
  \caption{簡易イベント検索のユースケース}
\label{fig:SimpleSearchUC}
  \end{center}
\end{figure}

\begin{itemize}
 \item {\bf リソース名を指定する}：\\
       ユーザがドロップダウンボックスを操作してリソース名を指定する。指
       定がなされたらルール名用のドロップダウンボックスが出現する。
 \item {\bf ルール名を指定する}：\\
       ユーザがドロップダウンボックスを操作してルール名を指定する。指定
       がなされたらイベント名用のドロップダウンボックスが出現する。
 \item {\bf イベント名を指定する}：\\
       ユーザがドロップダウンボックスを操作してイベント名を指定する。
       指定されたイベントが詳細情報を指定できるものである場合、イベ
       ント詳細用のドロップダウンボックスが出現する。
 \item {\bf イベント詳細を指定する}：\\
       ユーザがドロップダウンボックスを操作してイベントの詳細を指定する。
 \item {\bf 前方検索を実行する}：\\
       ユーザが前方検索を実行する。該当する時刻があれば、その時刻が画面
       の中心なるように画面が動く。また、その時刻にカーソルが出現する。
       該当時刻がない場合はその旨を伝えるポップアップウィンドウが出現す
       る。
 \item {\bf 後方検索を指定する}：\\
       ユーザが後方検索を実行する。該当する時刻があれば、その時刻が画面
       の中心なるように画面が動く。また、その時刻にカーソルが出現する。
       該当時刻がない場合はその旨を伝えるポップアップウィンドウが出現す
       る。
 \item {\bf 全体検索を実行する}：\\
       ユーザが後方検索を実行する。該当する時刻があれば、全ての該当にマー
       カーが出現する。該当時刻がない場合はその旨を伝えるポップアップウ
       ィンドウが出現する。
\end{itemize}
\clearpage

\subsubsection{設計}

\paragraph{クラス設計}　\\
　簡易イベント検索は、1つのイベントを検索する機能であり、複数のイベントを
組み合わせて検索する詳細イベント検索の基礎となる。そのため、簡易イベント
検索のクラス設計で最も重要なことは、可能な限り詳細検索イベント機能を低コ
ストで実装できるようにすることである。これを踏まえて\fgref{SimpleSearchClass}
のように簡易イベント検索を実現するクラスを設計した。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=11cm]{fig/section5/SimpleSearchClass.eps}
  \caption{簡易イベント検索を実現するクラス}
\label{fig:SimpleSearchClass}
  \end{center}
\end{figure}

SearchConditionクラスは、基本条件を保持するクラスとして設計した。
詳細イベント検索の実装の際に検索条件が増えた場合は、このクラスに
条件を追加する形で拡張する。

詳細イベント検索では、様々な検索方法があると予想される。例えば、今回実装
するイベント間のタイミングを考慮した検索方法がある。また、イベントの発生
回数を考慮した検索方法であったり、イベントの継続時間を指定する検索などが
あげられる。こうした検索方法を１つのクラスで実現しようとすると、クラスの
責務が重くなりすぎるため、検索方法ごとに検索クラスを用意することが望
ましい。さらに、ユーザに検索方法を指定させるなど、検索方法が動的に決定さ
れるような仕組みにする場合は、検索処理と検索クラスの生成を分離できる
とよい。そのため、インタフェース TraceLogSearcherを用意し、全ての検索処
理クラスが実装するようにする。このようにすることで、生成された検索ク
ラスを意識することなく検索処理が行える。
\\
\\

\paragraph{シーケンス}　\\
　前方検索が実行された際に、各クラスがどのように動作するかを
\fgref{SimpleSearchSequence}に示す。なお、シーケンスの解説のために、
各メッセージの名前は実際のメソッド名ではなく、そのメッセージによっ
て起きる動作内容としてある。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=14cm]{fig/section5/SimpleSearchSequence.eps}
  \caption{簡易イベント検索のシーケンス}
\label{fig:SimpleSearchSequence}
  \end{center}
\end{figure}

TraceLogDisplayPanel上で検索条件が入力され、前方検索ボタンが押されると
検索条件を保持するSearchConditionクラスが作成される。
TraceLogDisplayPanelではSimpleSearchクラスの検索メソッドを利用するため、
List<VisualizeLog>とSearchConditionが検索用データとして渡される。
その後TraceLogDisplayPanelからSimpleSearchの前方検索メソッドが呼び出され
る。SimpleSearchではList<VisualizeLog>から順番にイベントログを取り出し、
SearchConditionとのマッチングを行う。該当するログが見つかった時点でその
ログをTraceLogDisplayPanelへ返す。TraceLogDisplayPanelでは返されたログ
の時刻へカーソルを移動させる、もしくはログが返ってこなかった場合は検索条
件に該当するイベントが存在しない旨をポップアップウィンドウで表示する。


\subsubsection{実装画面}
　簡易イベント検索機能の実装画面を\fgref{SimpleSearchGUI}に示す。画像上
部の２行目のツールストライプが簡易イベント検索に関する操作を行う部分であ
る。検索条件指定部で検索条件を入力し、検索実行部で３つのボタンのうちどれ
かを押すことで検索が実行される。後方検索、前方検索の場合はカーソルが該当
時刻に移動し、全体検索の場合は該当時刻全てにマーカーが引かれる。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=11cm]{fig/section5/SimpleSearchGUI.eps}
  \caption{簡易イベント検索機能の実装画面}
\label{fig:SimpleSearchGUI}
  \end{center}
\end{figure}

\subsection{詳細イベント検索機能}
\subsubsection{機能仕様}
　詳細イベント検索の仕様を以下に記述する。
\paragraph{検索条件}　\\
　詳細イベント検索は、複数のイベントや、ある時点でのリソースの属性値など、
複数の検索条件を組み合わせて目的のパターンを発見する機能である。検索条件
の組み合わせが異なれば、処理の方式、検索条件の入力GUIも大きく異なるため、
組み合わせの種類（以後、検索方法と呼ぶ）ごとに検索処理クラス、GUIを作
成することになる。

今回実装を行う検索方法は、イベントの発生タイミングを考慮した検索であり、
{\bf タイミング検索}と呼ぶ。例えば「タスク1に実行状態への状態遷移イベン
トが起きた時刻のうち、タスク1においてその時刻から5mm秒後以上後に強制終了イ
ベントが発生している時刻」というような検索条件を指定できる。タイミング検
索では、「実行状態への状態遷移イベント」が最終的に検索する時刻を指定する
条件であり、「5mm秒以降に強制終了イベントが発生」が検索対象イベントを絞
込む条件となる。以後、前者を{\bf 基本条件}、後者を{\bf 絞込み条件}と呼ぶ。
また、基本条件で検索される時刻を{\bf 基準時}と呼ぶ。

基本条件で指定できる条件は、簡易イベント検索で指定できた以下の４条件であ
る。
\begin{itemize}
 \item リソース名
 \item ルール名
 \item イベント名
 \item イベント詳細
\end{itemize}

絞込み条件で指定できる条件は、この4条件に次の3条件を加えたものである。
\begin{itemize}
  \item タイミング
  \item 時間
  \item 条件の否定
\end{itemize}

タイミングとして指定できる条件は次の4つである。時間単位は秒以外にも ミリ
秒、マイクロ秒など任意である（リソースファイルで指定された時間単位となる）。

\begin{itemize}
  \item ○○秒以内（基準時以前）
  \item ○○秒以内（基準時以降）
  \item ○○秒以上前
  \item ○○秒以上後
\end{itemize}

基準時に対する上記4つのタイミングの関係を図\fgref{Timing}に示す。
\begin{figure}[h]
 \begin{center}
 \includegraphics[width=11cm]{fig/section5/Timing.eps}
  \caption{基準時とタイミングの関係}
\label{fig:Timing}
  \end{center}
\end{figure}


\paragraph{検索操作のためのGUI}　\\
　詳細イベント検索では検索条件が複雑になるため、別途フォームを用意し、
その中で検索条件の作成、検索の実行などの検索にともなう操作を行う。
各操作の仕様を次に示す。

\begin{itemize}
  \item 検索条件の追加：　\\
        詳細イベント検索では複数の検索条件を指定可能であるため、それらを
        指定する領域を順次画面上に追加していく必要がある。基本条件とそれ
        に対する絞込み条件（複数可）をまとめて{\bf 条件セット}と呼ぶ。
        基本条件を設定する領域の下に、絞込み条件を設定する領域を順次追加し
        ていくようにする。なお、詳細イベント検索では複数の条件セットを指
        定可能とする。また、1つの基本条件に対して複数の絞込み条件が存在
        する場合、基本条件と絞込み条件の関係はすべてAND 、もしくはORのみ
        とする。つまり、全てANDの場合は、基本条件*（絞込み条件1 + 絞込み条件
        2 ・・・）となり、全てORの場合は、基本条件 * 絞込み条件1 * 絞込
        み条件2・・・となる。
  \item 検索条件の指定：　\\
        リソース名やルール名といった条件の指定には間イベント検索と同じく
        コンボボックスを使用しドロップダウンリストからユーザに条件を指定
        させる。
  \item 検索の実行：　\\
        簡易イベント検索と同じ3種類の検索ボタンを用意する。また作成した条
        件セット全てを用いた検索と、条件セットの一部だけを使用した検索両
        方が可能とする。
  \item 結果表示：　\\
        簡易イベント検索と同様
\end{itemize}
\subsubsection{ユースケース}
  定義した仕様をもとに、ユーザが詳細イベント検索を行う際のユースケース
を\fgref{DetailSearchUC}に示す。Detail Search Panel は詳細検索用の画面
であり、検索条件の作成を行う領域であるCondition Setting Area と、
それ以外の操作を行う領域である Operation Area で構成される。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=12cm]{fig/section5/DetailSearchUC.eps}
  \caption{詳細イベント検索のユースケース}
\label{fig:DetailSearchUC}
  \end{center}
\end{figure}

\paragraph{Search Operation Area におけるユースケース}
\begin{itemize}
  \item {\bf カーソルを移動させる}：　\\
        TraceLogDisplayPanel上のカーソル（検索開始地点）を移動させる。
  \item {\bf 基本条件を追加する}：　\\
        1つの基本条件を設定するための領域を条件作成領域に追加す
        る。すでに基本条件の設定領域が存在している場合は、その下に新たに
        基本条件設定用の領域が追加される。
  \item {\bf 全ての条件セットで検索を行う}：　\\
        全ての条件セットを用いて前方検索、後方検索、全体検索を行う。
        前方検索、後方検索では、各条件セットで検索された時刻のうち、
        もっとも検索開始地点に近い時刻へカーソルが移動する。
\end{itemize}

\paragraph{Search Condition Setting Area におけるユースケース}
\begin{itemize}
  \item {\bf 基本条件を設定する}：　\\
        リソース名、ルール名、イベント名、イベント詳細を設定する。
        リソース名が指定されると、ルール名の指定ボックスが出現する、と
        いうように、順次指定ボックスが追加されていく。
  \item {\bf 基本条件を削除する}：　\\
        条件作成領域から基本条件とそれに対する絞込み条件を削除する
  \item {\bf 絞込み条件を追加する}：　\\
        基本条件の設定領域の下に、絞込み条件を設定するための領域を追加す
        る。
  \item {\bf 絞込み条件を設定する}：　\\
        リソース名、ルール名、イベント名、イベント詳細、タイミング、タイ
        ミング値、条件の否定を指定する。
  \item {\bf 絞込み条件を削除する}：　\\
        条件作成領域から対象の絞込み条件設定領域を削除する
  \item {\bf 基本条件と絞込み条件のAND、OR関係を設定する}：　\\
        基本条件に絞込み条件が複数存在している場合、ANDのみかORのみを選
        択する。
  \item {\bf 1つの条件セットで検索を行う}：　\\
        条件セット1だけを用いて、前方検索、後方検索、全体検索を行う。
\end{itemize}

\subsubsection{設計}
\paragraph{クラス設計}　\\
　詳細イベント検索を実現するためのクラス群を\fgref{DetailSearchClass}に
示す。赤枠で囲った画面構成クラス群と、青枠で囲ったタイミング検索クラス
が\fgref{SimpleSearchClass}からの変更点である。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=13cm]{fig/section5/DetailSearchClass.eps}
  \caption{詳細イベント検索を実現するクラス}
\label{fig:DetailSearchClass}
  \end{center}
\end{figure}

タイミング検索処理を行うクラスが DetailSearchWithTimingである。
SimpleSearchで行われる検索処理に、タイミングによるフィルタをかける処理で
あるため、SimpleSearchを継承させた。

詳細イベント検索フォームの中核をなすのがDetailSearchPanelである。
DetailSearchPanelの詳細な構成を\fgref{DetailSearchPanel}に示す。図中で名前
に''*''がついているクラスは、DetailSearchPanel上で複数存在できるクラスである。
DetailSearchPanelは、「検索条件の設定GUIの追加を簡単にする」という
コンセプトのもとで設計した。そのため、1つの条件セットを設定するパネルで
あるConditionSettingPanelを用意し、条件セットが追加されるたびに
ConditionSettingAreaに追加していく構造にした。さらに、
ConditionSettingPanelには条件1つにつき1つの条件保持パネルを追加していく
構造にし、こちらも簡単に条件を追加できるようにしてある。

条件保持パネルにはインタフェースConditionPanelを実装させ、パネル内に保持
されている条件をConditionSettingPanelが受け取る際に、getSearchCondition
メソッドを介するようにした。そのためCOnditionSettingPanelは自分に張り付
いている条件パネルの種類を考慮する必要がなくなる。これ利点は、この先様々
な詳細検索が実装され、条件パネルの種類が増えた際にも、
ConditionSettinPanelに変更を加える必要がなくなることである。


\begin{figure}[h]
 \begin{center}
 \includegraphics[width=9cm]{fig/section5/DetailSearchPanel.eps}
  \caption{DetailSearchPanelの構成}
\label{fig:DetailSearchPanel}
  \end{center}
\end{figure}

基本条件は、この先様々な検索方法を実装することになった場合でも共通して
使用される。つまり、各検索を行うためのフォームでも基本条件設定用のGUIが
必要になる。そのため、基本条件を設定するためのGUIがこのポーネント化され
ていることが望ましい。よって、基本条件設定用に BaseConditionPanel
クラスを\fgref{BaseConditionPanel}のような構造をもつクラスとして設計した。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=8cm]{fig/section5/BaseConditionPanel.eps}
  \caption{BaseConditionPanelの構成}
\label{fig:BaseConditionPanel}
  \end{center}
\end{figure}

今回実装するタイミング検索では、絞込み条件には基本条件とその他３つの条件
を設定できる。そのため、絞込み条件設定用のRefiningConditionPanelクラスは
BaseConditionPanelを継承させる形で設計した。RefiningConditionPanelの構造
を\fgref{RefiningConditionPanel}に示す。絞込み条件はDetailSearchPanel上
で頻繁に追加されることになるが、条件指定用のGUIがパネルにまとまっている
ため、絞込み条件が追加されても\fgref{DetailSearchPanel}に示したように、
ConditionSettingPanelに順次RefiningConditionPanelを追加するだけでよく、
設計コンセプトが活きているといえる。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=8cm]{fig/section5/RefiningConditionPanel.eps}
  \caption{RefiningConditionPanelの構成}
\label{fig:RefiningConditionPanel}
  \end{center}
\end{figure}

\clearpage
\paragraph{シーケンス}　\\
　前方検索が実行された際に、各クラスがどのように動作するかを
\fgref{DetailSearchSequence}に示す。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=15cm]{fig/section5/DetailSearchSequence.eps}
  \caption{詳細イベント検索のシーケンス}
\label{fig:DetailSearchSequence}
  \end{center}
\end{figure}

DetailSearchPanel において前方検索の実行ボタンが押されると、まず
ConditionSettingPanelから全ての条件セット（SearchConditionの組）を取得す
る。続いてタイミング検索を担当する DetailSearchWithTiming に
１つの条件セットとイベントログが渡され、さらにDetailSearchWithTiming が
 基本条件の検索を担当する SimpleSearchに基本条件とイベントログを渡す。
 ここまでで検索条件の設定が終了する。

続いてDetailSearchPanelが検索実行命令をDetailSearchWithTimingに出し、
基本条件に合致するイベントログの検索を開始する。この処理は
DetailSearchWithTimingがSimpleSearchへ委譲する形で行われる。
SimpleSearchは基本条件に合致するイベントログを見つけると、その
ログをDetailSearchWithTimingに返す。見つからなければDetailSearchPanelへ
その旨を通知する。なお、シーケンス図では省略しているが、条件の照合は
SimpleFilerが担当している。そしてDetailSearchWithTimingは、返されたログ
と絞込み条件の照合を行い、合致する場合にはDetailSearchPanelへと渡す。
合致しなければ、返されたログの時刻を基準時として再度前方検索に戻る。
ここでの条件の照合は SmipleFilterとTimingFilter が行う（SimpleFilterを
TimingFilterでデコレートする形で処理が行われる）。

DetailSearchPanelでは、検索条件を満たすイベントログが返ってくると、
TraceLogDisplayPanel上のカーソルをログの時刻に移動させる処理を行う。
もしも条件セットが複数ある場合には、次の条件セットを用いて再度前方検索を
行い、最終的に複数のログが検索にヒットすると、検索開始時刻に最も近い
時刻へとカーソルを移動させる。
\clearpage

\subsubsection{実装画面}
　詳細イベント検索フォームの実装画面を\fgref{DetailSearchPanelExample}に
示す。

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=12cm]{fig/section5/DetailSearchPanelExample.eps}
  \caption{詳細イベント検索フォーム}
\label{fig:DetailSearchPanelExample}
  \end{center}
\end{figure}

上部の検索操作領域では、検索開始時刻の設定、基本条件の追加、検索の実
行ができる。基本条件の追加ボタンが押されると、条件設定領域に条件設定パネ
ルが追加されていく。各条件設定パネルでは、基本条件の作成と、絞込み条件の
追加・編集ができ、さらにそのパネル内の条件だけを使用した検索も可能となっ
ている。ここで実行された検索結果は、簡易イベント検索と同様に
TraceLogDisplayパネルのタイムライン上に、カーソル、もしくはマーカーによっ
て表示される。

\subsection{考察}

\paragraph{タイミング検索の有用性}　\\


\paragraph{設計についての考察}　\\

今回実装したタイミング検索は詳細イベント検索のうちの1つであり、将来的に
もっとたくさんの検索方法を用意する予定である。例えばタスクAが10回目の実
行状態になった時刻を探すという回数指定検索があげられる。

詳細イベント検索では、検索方法ごとに条件の指定が複雑になるため、それぞれ
に専用のフォーム

各フィルタをクラスとして用意し、自由に組み合わせられるようにすれば、新規
に検索クラスを実装する場合には過去に実装したフィルタを取込むことができる。
さらに、既存の検索クラスに指定できる検索条件を追加したくなった際にも、
フィルタを追加するだけでよくなる。この仕組みを実現する方法として、
Decoratorパターンが利用できる。\fgref{ApplyingDecorator}にDecorator
パターンを適用した場合のクラス図を示す。

\fgref{ApplyingDecorator}は、

\begin{figure}[h]
 \begin{center}
 \includegraphics[width=9cm]{fig/section5/ApplyingDecorator.eps}
  \caption{Decoratorパターンの導入例}
　\label{fig:ApplyingDecorator}
  \end{center}
\end{figure}




\clearpage

\section{おわりに}
\subsection{まとめ}
組込システムにおいてマルチコアプロセッサの利用が進むとともに、シングル
コア環境で行われている従来のデバッグ方法では対応できなくなってきた。
マルチコアプロセッサは各コアが並列に動作するため、プログラムの挙動が非決
定的になるため再現性が保証されず、ブレークポイントを用いたステップ実行に
よる解析といった、実行中のデバッグではバグを確実に発見できない。

そのためマルチコア環境でのデバッグでは、プログラムの実行ログであるトレー
スログを解析する手法が有効とされている。しかし、トレースログはリソースの
挙動を逐一記録したログであり、サイズが大きくなりがちである。これを開発者
が手動で解析するには大きなコストが必要になり、非効率的である。そこでトレー
スログを可視化するツールが様々な組織によって開発されている。しかしながら、
既存の可視化ツールは、それぞれが特定の形式のトレースログしか扱えず汎用性
に乏しい。また、可視化できる項目も限られている。

こうした背景をもとにして、様々な形式のトレースログを利用者が望む形で可視
化することができるという汎用性を持ったトレースログ可視化ツールTLVが開発
された\cite{Goto}\cite{Goto2}。TLVではトレースログを一般化した標準形式
トレースログを定義しており、任意の形式のトレースログを標準形式ログへと変
換する仕組みを変換ルールとして形式化した。また、トレースログの可視化表示
を指示する仕組みを抽象化し、可視化ルールとして形式化した。この2つの仕組
みによってTLVでは汎用性、拡張性を実現している。

本OJLは、OJL1期生と2期生が開発してきたTLVに対して機能追加を行う目的で実
施した。まず利用者から要求抽出を行い、その中で要望の強かったイベント検索
機能の実装を行った。要求された検索方法は、特定のイベントをその他のイベン
トの発生タイミングを考慮しながら検索するというものであり、処理が非常に複
雑になると予想された。そのため、1つのイベントを検索する簡易イベント検索と、
利用者からの要求にあったタイミング検索を実現する詳細イベント検索に分割
し、まず簡易イベント検索を実装し、それを拡張して詳細イベント検索を実装し
た。イベント検索機能によって、膨大な可視化領域から目的のパターンを即座に
発見できるようになり、デバッグコストを低下させることができた。

本OJLでは詳細検索としてタイミング検索のみを実装したが、利用者から要望が
あるたびに新たな検索方法を実装していく。そのためコードの再利用性、拡張性
が重要になる。検索を行うにはその操作を行うためのGUIが必要になるが、その
開発コストは高いと予想された。そのため、設計の際にはGUIの再利用性を考慮
し、検索条件を指定するGUIのコンポーネント化し、低コストで新規検索手法の
導入が可能になるようにした。

今後の課題としては、利用者からの要求抽出によって新たな検索手法を獲得する
こと、以前から要望の強かったTLVの高速化があげられる。

\subsection{所感}

\clearpage
 \bibliographystyle{junsrt}
 \bibliography{ojl_report}
\clearpage

\end{document}